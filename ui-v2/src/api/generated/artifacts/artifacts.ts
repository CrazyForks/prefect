/**
 * Generated by orval v7.5.0 🍺
 * Do not edit manually.
 * Prefect Prefect REST API
 * OpenAPI spec version: 0.1.0
 */
import { useMutation, useQuery, useSuspenseQuery } from "@tanstack/react-query";
import type {
	DataTag,
	DefinedInitialDataOptions,
	DefinedUseQueryResult,
	MutationFunction,
	QueryFunction,
	QueryKey,
	UndefinedInitialDataOptions,
	UseMutationOptions,
	UseMutationResult,
	UseQueryOptions,
	UseQueryResult,
	UseSuspenseQueryOptions,
	UseSuspenseQueryResult,
} from "@tanstack/react-query";
import type {
	Artifact,
	ArtifactCollection,
	ArtifactCreate,
	ArtifactUpdate,
	BodyCountArtifactsArtifactsCountPost,
	BodyCountLatestArtifactsArtifactsLatestCountPost,
	BodyReadArtifactsArtifactsFilterPost,
	BodyReadLatestArtifactsArtifactsLatestFilterPost,
	HTTPValidationError,
} from "../../models";

/**
 * @summary Create Artifact
 */
export type createArtifactArtifactsPostResponse = {
	data: Artifact | HTTPValidationError;
	status: number;
	headers: Headers;
};

export const getCreateArtifactArtifactsPostUrl = () => {
	return `http://prefect.grose.click/api/artifacts/`;
};

export const createArtifactArtifactsPost = async (
	artifactCreate: ArtifactCreate,
	options?: RequestInit,
): Promise<createArtifactArtifactsPostResponse> => {
	const res = await fetch(getCreateArtifactArtifactsPostUrl(), {
		...options,
		method: "POST",
		headers: { "Content-Type": "application/json", ...options?.headers },
		body: JSON.stringify(artifactCreate),
	});

	const body = [204, 205, 304].includes(res.status) ? null : await res.text();
	const data: createArtifactArtifactsPostResponse["data"] = body
		? JSON.parse(body)
		: {};

	return {
		data,
		status: res.status,
		headers: res.headers,
	} as createArtifactArtifactsPostResponse;
};

export const getCreateArtifactArtifactsPostMutationOptions = <
	TError = HTTPValidationError,
	TContext = unknown,
>(options?: {
	mutation?: UseMutationOptions<
		Awaited<ReturnType<typeof createArtifactArtifactsPost>>,
		TError,
		{ data: ArtifactCreate },
		TContext
	>;
	fetch?: RequestInit;
}): UseMutationOptions<
	Awaited<ReturnType<typeof createArtifactArtifactsPost>>,
	TError,
	{ data: ArtifactCreate },
	TContext
> => {
	const mutationKey = ["createArtifactArtifactsPost"];
	const { mutation: mutationOptions, fetch: fetchOptions } = options
		? options.mutation &&
			"mutationKey" in options.mutation &&
			options.mutation.mutationKey
			? options
			: { ...options, mutation: { ...options.mutation, mutationKey } }
		: { mutation: { mutationKey }, fetch: undefined };

	const mutationFn: MutationFunction<
		Awaited<ReturnType<typeof createArtifactArtifactsPost>>,
		{ data: ArtifactCreate }
	> = (props) => {
		const { data } = props ?? {};

		return createArtifactArtifactsPost(data, fetchOptions);
	};

	return { mutationFn, ...mutationOptions };
};

export type CreateArtifactArtifactsPostMutationResult = NonNullable<
	Awaited<ReturnType<typeof createArtifactArtifactsPost>>
>;
export type CreateArtifactArtifactsPostMutationBody = ArtifactCreate;
export type CreateArtifactArtifactsPostMutationError = HTTPValidationError;

/**
 * @summary Create Artifact
 */
export const useCreateArtifactArtifactsPost = <
	TError = HTTPValidationError,
	TContext = unknown,
>(options?: {
	mutation?: UseMutationOptions<
		Awaited<ReturnType<typeof createArtifactArtifactsPost>>,
		TError,
		{ data: ArtifactCreate },
		TContext
	>;
	fetch?: RequestInit;
}): UseMutationResult<
	Awaited<ReturnType<typeof createArtifactArtifactsPost>>,
	TError,
	{ data: ArtifactCreate },
	TContext
> => {
	const mutationOptions =
		getCreateArtifactArtifactsPostMutationOptions(options);

	return useMutation(mutationOptions);
};
/**
 * Retrieve an artifact from the database.
 * @summary Read Artifact
 */
export type readArtifactArtifactsIdGetResponse = {
	data: Artifact | HTTPValidationError;
	status: number;
	headers: Headers;
};

export const getReadArtifactArtifactsIdGetUrl = (id: string) => {
	return `http://prefect.grose.click/api/artifacts/${id}`;
};

export const readArtifactArtifactsIdGet = async (
	id: string,
	options?: RequestInit,
): Promise<readArtifactArtifactsIdGetResponse> => {
	const res = await fetch(getReadArtifactArtifactsIdGetUrl(id), {
		...options,
		method: "GET",
	});

	const body = [204, 205, 304].includes(res.status) ? null : await res.text();
	const data: readArtifactArtifactsIdGetResponse["data"] = body
		? JSON.parse(body)
		: {};

	return {
		data,
		status: res.status,
		headers: res.headers,
	} as readArtifactArtifactsIdGetResponse;
};

export const getReadArtifactArtifactsIdGetQueryKey = (id: string) => {
	return [`http://prefect.grose.click/api/artifacts/${id}`] as const;
};

export const getReadArtifactArtifactsIdGetQueryOptions = <
	TData = Awaited<ReturnType<typeof readArtifactArtifactsIdGet>>,
	TError = HTTPValidationError,
>(
	id: string,
	options?: {
		query?: Partial<
			UseQueryOptions<
				Awaited<ReturnType<typeof readArtifactArtifactsIdGet>>,
				TError,
				TData
			>
		>;
		fetch?: RequestInit;
	},
) => {
	const { query: queryOptions, fetch: fetchOptions } = options ?? {};

	const queryKey =
		queryOptions?.queryKey ?? getReadArtifactArtifactsIdGetQueryKey(id);

	const queryFn: QueryFunction<
		Awaited<ReturnType<typeof readArtifactArtifactsIdGet>>
	> = ({ signal }) =>
		readArtifactArtifactsIdGet(id, { signal, ...fetchOptions });

	return {
		queryKey,
		queryFn,
		enabled: !!id,
		...queryOptions,
	} as UseQueryOptions<
		Awaited<ReturnType<typeof readArtifactArtifactsIdGet>>,
		TError,
		TData
	> & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type ReadArtifactArtifactsIdGetQueryResult = NonNullable<
	Awaited<ReturnType<typeof readArtifactArtifactsIdGet>>
>;
export type ReadArtifactArtifactsIdGetQueryError = HTTPValidationError;

export function useReadArtifactArtifactsIdGet<
	TData = Awaited<ReturnType<typeof readArtifactArtifactsIdGet>>,
	TError = HTTPValidationError,
>(
	id: string,
	options: {
		query: Partial<
			UseQueryOptions<
				Awaited<ReturnType<typeof readArtifactArtifactsIdGet>>,
				TError,
				TData
			>
		> &
			Pick<
				DefinedInitialDataOptions<
					Awaited<ReturnType<typeof readArtifactArtifactsIdGet>>,
					TError,
					Awaited<ReturnType<typeof readArtifactArtifactsIdGet>>
				>,
				"initialData"
			>;
		fetch?: RequestInit;
	},
): DefinedUseQueryResult<TData, TError> & {
	queryKey: DataTag<QueryKey, TData, TError>;
};
export function useReadArtifactArtifactsIdGet<
	TData = Awaited<ReturnType<typeof readArtifactArtifactsIdGet>>,
	TError = HTTPValidationError,
>(
	id: string,
	options?: {
		query?: Partial<
			UseQueryOptions<
				Awaited<ReturnType<typeof readArtifactArtifactsIdGet>>,
				TError,
				TData
			>
		> &
			Pick<
				UndefinedInitialDataOptions<
					Awaited<ReturnType<typeof readArtifactArtifactsIdGet>>,
					TError,
					Awaited<ReturnType<typeof readArtifactArtifactsIdGet>>
				>,
				"initialData"
			>;
		fetch?: RequestInit;
	},
): UseQueryResult<TData, TError> & {
	queryKey: DataTag<QueryKey, TData, TError>;
};
export function useReadArtifactArtifactsIdGet<
	TData = Awaited<ReturnType<typeof readArtifactArtifactsIdGet>>,
	TError = HTTPValidationError,
>(
	id: string,
	options?: {
		query?: Partial<
			UseQueryOptions<
				Awaited<ReturnType<typeof readArtifactArtifactsIdGet>>,
				TError,
				TData
			>
		>;
		fetch?: RequestInit;
	},
): UseQueryResult<TData, TError> & {
	queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Read Artifact
 */

export function useReadArtifactArtifactsIdGet<
	TData = Awaited<ReturnType<typeof readArtifactArtifactsIdGet>>,
	TError = HTTPValidationError,
>(
	id: string,
	options?: {
		query?: Partial<
			UseQueryOptions<
				Awaited<ReturnType<typeof readArtifactArtifactsIdGet>>,
				TError,
				TData
			>
		>;
		fetch?: RequestInit;
	},
): UseQueryResult<TData, TError> & {
	queryKey: DataTag<QueryKey, TData, TError>;
} {
	const queryOptions = getReadArtifactArtifactsIdGetQueryOptions(id, options);

	const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
		queryKey: DataTag<QueryKey, TData, TError>;
	};

	query.queryKey = queryOptions.queryKey;

	return query;
}

export const getReadArtifactArtifactsIdGetSuspenseQueryOptions = <
	TData = Awaited<ReturnType<typeof readArtifactArtifactsIdGet>>,
	TError = HTTPValidationError,
>(
	id: string,
	options?: {
		query?: Partial<
			UseSuspenseQueryOptions<
				Awaited<ReturnType<typeof readArtifactArtifactsIdGet>>,
				TError,
				TData
			>
		>;
		fetch?: RequestInit;
	},
) => {
	const { query: queryOptions, fetch: fetchOptions } = options ?? {};

	const queryKey =
		queryOptions?.queryKey ?? getReadArtifactArtifactsIdGetQueryKey(id);

	const queryFn: QueryFunction<
		Awaited<ReturnType<typeof readArtifactArtifactsIdGet>>
	> = ({ signal }) =>
		readArtifactArtifactsIdGet(id, { signal, ...fetchOptions });

	return { queryKey, queryFn, ...queryOptions } as UseSuspenseQueryOptions<
		Awaited<ReturnType<typeof readArtifactArtifactsIdGet>>,
		TError,
		TData
	> & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type ReadArtifactArtifactsIdGetSuspenseQueryResult = NonNullable<
	Awaited<ReturnType<typeof readArtifactArtifactsIdGet>>
>;
export type ReadArtifactArtifactsIdGetSuspenseQueryError = HTTPValidationError;

export function useReadArtifactArtifactsIdGetSuspense<
	TData = Awaited<ReturnType<typeof readArtifactArtifactsIdGet>>,
	TError = HTTPValidationError,
>(
	id: string,
	options: {
		query: Partial<
			UseSuspenseQueryOptions<
				Awaited<ReturnType<typeof readArtifactArtifactsIdGet>>,
				TError,
				TData
			>
		>;
		fetch?: RequestInit;
	},
): UseSuspenseQueryResult<TData, TError> & {
	queryKey: DataTag<QueryKey, TData, TError>;
};
export function useReadArtifactArtifactsIdGetSuspense<
	TData = Awaited<ReturnType<typeof readArtifactArtifactsIdGet>>,
	TError = HTTPValidationError,
>(
	id: string,
	options?: {
		query?: Partial<
			UseSuspenseQueryOptions<
				Awaited<ReturnType<typeof readArtifactArtifactsIdGet>>,
				TError,
				TData
			>
		>;
		fetch?: RequestInit;
	},
): UseSuspenseQueryResult<TData, TError> & {
	queryKey: DataTag<QueryKey, TData, TError>;
};
export function useReadArtifactArtifactsIdGetSuspense<
	TData = Awaited<ReturnType<typeof readArtifactArtifactsIdGet>>,
	TError = HTTPValidationError,
>(
	id: string,
	options?: {
		query?: Partial<
			UseSuspenseQueryOptions<
				Awaited<ReturnType<typeof readArtifactArtifactsIdGet>>,
				TError,
				TData
			>
		>;
		fetch?: RequestInit;
	},
): UseSuspenseQueryResult<TData, TError> & {
	queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Read Artifact
 */

export function useReadArtifactArtifactsIdGetSuspense<
	TData = Awaited<ReturnType<typeof readArtifactArtifactsIdGet>>,
	TError = HTTPValidationError,
>(
	id: string,
	options?: {
		query?: Partial<
			UseSuspenseQueryOptions<
				Awaited<ReturnType<typeof readArtifactArtifactsIdGet>>,
				TError,
				TData
			>
		>;
		fetch?: RequestInit;
	},
): UseSuspenseQueryResult<TData, TError> & {
	queryKey: DataTag<QueryKey, TData, TError>;
} {
	const queryOptions = getReadArtifactArtifactsIdGetSuspenseQueryOptions(
		id,
		options,
	);

	const query = useSuspenseQuery(queryOptions) as UseSuspenseQueryResult<
		TData,
		TError
	> & { queryKey: DataTag<QueryKey, TData, TError> };

	query.queryKey = queryOptions.queryKey;

	return query;
}

/**
 * Update an artifact in the database.
 * @summary Update Artifact
 */
export type updateArtifactArtifactsIdPatchResponse = {
	data: void | HTTPValidationError;
	status: number;
	headers: Headers;
};

export const getUpdateArtifactArtifactsIdPatchUrl = (id: string) => {
	return `http://prefect.grose.click/api/artifacts/${id}`;
};

export const updateArtifactArtifactsIdPatch = async (
	id: string,
	artifactUpdate: ArtifactUpdate,
	options?: RequestInit,
): Promise<updateArtifactArtifactsIdPatchResponse> => {
	const res = await fetch(getUpdateArtifactArtifactsIdPatchUrl(id), {
		...options,
		method: "PATCH",
		headers: { "Content-Type": "application/json", ...options?.headers },
		body: JSON.stringify(artifactUpdate),
	});

	const body = [204, 205, 304].includes(res.status) ? null : await res.text();
	const data: updateArtifactArtifactsIdPatchResponse["data"] = body
		? JSON.parse(body)
		: {};

	return {
		data,
		status: res.status,
		headers: res.headers,
	} as updateArtifactArtifactsIdPatchResponse;
};

export const getUpdateArtifactArtifactsIdPatchMutationOptions = <
	TError = HTTPValidationError,
	TContext = unknown,
>(options?: {
	mutation?: UseMutationOptions<
		Awaited<ReturnType<typeof updateArtifactArtifactsIdPatch>>,
		TError,
		{ id: string; data: ArtifactUpdate },
		TContext
	>;
	fetch?: RequestInit;
}): UseMutationOptions<
	Awaited<ReturnType<typeof updateArtifactArtifactsIdPatch>>,
	TError,
	{ id: string; data: ArtifactUpdate },
	TContext
> => {
	const mutationKey = ["updateArtifactArtifactsIdPatch"];
	const { mutation: mutationOptions, fetch: fetchOptions } = options
		? options.mutation &&
			"mutationKey" in options.mutation &&
			options.mutation.mutationKey
			? options
			: { ...options, mutation: { ...options.mutation, mutationKey } }
		: { mutation: { mutationKey }, fetch: undefined };

	const mutationFn: MutationFunction<
		Awaited<ReturnType<typeof updateArtifactArtifactsIdPatch>>,
		{ id: string; data: ArtifactUpdate }
	> = (props) => {
		const { id, data } = props ?? {};

		return updateArtifactArtifactsIdPatch(id, data, fetchOptions);
	};

	return { mutationFn, ...mutationOptions };
};

export type UpdateArtifactArtifactsIdPatchMutationResult = NonNullable<
	Awaited<ReturnType<typeof updateArtifactArtifactsIdPatch>>
>;
export type UpdateArtifactArtifactsIdPatchMutationBody = ArtifactUpdate;
export type UpdateArtifactArtifactsIdPatchMutationError = HTTPValidationError;

/**
 * @summary Update Artifact
 */
export const useUpdateArtifactArtifactsIdPatch = <
	TError = HTTPValidationError,
	TContext = unknown,
>(options?: {
	mutation?: UseMutationOptions<
		Awaited<ReturnType<typeof updateArtifactArtifactsIdPatch>>,
		TError,
		{ id: string; data: ArtifactUpdate },
		TContext
	>;
	fetch?: RequestInit;
}): UseMutationResult<
	Awaited<ReturnType<typeof updateArtifactArtifactsIdPatch>>,
	TError,
	{ id: string; data: ArtifactUpdate },
	TContext
> => {
	const mutationOptions =
		getUpdateArtifactArtifactsIdPatchMutationOptions(options);

	return useMutation(mutationOptions);
};
/**
 * Delete an artifact from the database.
 * @summary Delete Artifact
 */
export type deleteArtifactArtifactsIdDeleteResponse = {
	data: void | HTTPValidationError;
	status: number;
	headers: Headers;
};

export const getDeleteArtifactArtifactsIdDeleteUrl = (id: string) => {
	return `http://prefect.grose.click/api/artifacts/${id}`;
};

export const deleteArtifactArtifactsIdDelete = async (
	id: string,
	options?: RequestInit,
): Promise<deleteArtifactArtifactsIdDeleteResponse> => {
	const res = await fetch(getDeleteArtifactArtifactsIdDeleteUrl(id), {
		...options,
		method: "DELETE",
	});

	const body = [204, 205, 304].includes(res.status) ? null : await res.text();
	const data: deleteArtifactArtifactsIdDeleteResponse["data"] = body
		? JSON.parse(body)
		: {};

	return {
		data,
		status: res.status,
		headers: res.headers,
	} as deleteArtifactArtifactsIdDeleteResponse;
};

export const getDeleteArtifactArtifactsIdDeleteMutationOptions = <
	TError = HTTPValidationError,
	TContext = unknown,
>(options?: {
	mutation?: UseMutationOptions<
		Awaited<ReturnType<typeof deleteArtifactArtifactsIdDelete>>,
		TError,
		{ id: string },
		TContext
	>;
	fetch?: RequestInit;
}): UseMutationOptions<
	Awaited<ReturnType<typeof deleteArtifactArtifactsIdDelete>>,
	TError,
	{ id: string },
	TContext
> => {
	const mutationKey = ["deleteArtifactArtifactsIdDelete"];
	const { mutation: mutationOptions, fetch: fetchOptions } = options
		? options.mutation &&
			"mutationKey" in options.mutation &&
			options.mutation.mutationKey
			? options
			: { ...options, mutation: { ...options.mutation, mutationKey } }
		: { mutation: { mutationKey }, fetch: undefined };

	const mutationFn: MutationFunction<
		Awaited<ReturnType<typeof deleteArtifactArtifactsIdDelete>>,
		{ id: string }
	> = (props) => {
		const { id } = props ?? {};

		return deleteArtifactArtifactsIdDelete(id, fetchOptions);
	};

	return { mutationFn, ...mutationOptions };
};

export type DeleteArtifactArtifactsIdDeleteMutationResult = NonNullable<
	Awaited<ReturnType<typeof deleteArtifactArtifactsIdDelete>>
>;

export type DeleteArtifactArtifactsIdDeleteMutationError = HTTPValidationError;

/**
 * @summary Delete Artifact
 */
export const useDeleteArtifactArtifactsIdDelete = <
	TError = HTTPValidationError,
	TContext = unknown,
>(options?: {
	mutation?: UseMutationOptions<
		Awaited<ReturnType<typeof deleteArtifactArtifactsIdDelete>>,
		TError,
		{ id: string },
		TContext
	>;
	fetch?: RequestInit;
}): UseMutationResult<
	Awaited<ReturnType<typeof deleteArtifactArtifactsIdDelete>>,
	TError,
	{ id: string },
	TContext
> => {
	const mutationOptions =
		getDeleteArtifactArtifactsIdDeleteMutationOptions(options);

	return useMutation(mutationOptions);
};
/**
 * Retrieve the latest artifact from the artifact table.
 * @summary Read Latest Artifact
 */
export type readLatestArtifactArtifactsKeyLatestGetResponse = {
	data: Artifact | HTTPValidationError;
	status: number;
	headers: Headers;
};

export const getReadLatestArtifactArtifactsKeyLatestGetUrl = (key: string) => {
	return `http://prefect.grose.click/api/artifacts/${key}/latest`;
};

export const readLatestArtifactArtifactsKeyLatestGet = async (
	key: string,
	options?: RequestInit,
): Promise<readLatestArtifactArtifactsKeyLatestGetResponse> => {
	const res = await fetch(getReadLatestArtifactArtifactsKeyLatestGetUrl(key), {
		...options,
		method: "GET",
	});

	const body = [204, 205, 304].includes(res.status) ? null : await res.text();
	const data: readLatestArtifactArtifactsKeyLatestGetResponse["data"] = body
		? JSON.parse(body)
		: {};

	return {
		data,
		status: res.status,
		headers: res.headers,
	} as readLatestArtifactArtifactsKeyLatestGetResponse;
};

export const getReadLatestArtifactArtifactsKeyLatestGetQueryKey = (
	key: string,
) => {
	return [`http://prefect.grose.click/api/artifacts/${key}/latest`] as const;
};

export const getReadLatestArtifactArtifactsKeyLatestGetQueryOptions = <
	TData = Awaited<ReturnType<typeof readLatestArtifactArtifactsKeyLatestGet>>,
	TError = HTTPValidationError,
>(
	key: string,
	options?: {
		query?: Partial<
			UseQueryOptions<
				Awaited<ReturnType<typeof readLatestArtifactArtifactsKeyLatestGet>>,
				TError,
				TData
			>
		>;
		fetch?: RequestInit;
	},
) => {
	const { query: queryOptions, fetch: fetchOptions } = options ?? {};

	const queryKey =
		queryOptions?.queryKey ??
		getReadLatestArtifactArtifactsKeyLatestGetQueryKey(key);

	const queryFn: QueryFunction<
		Awaited<ReturnType<typeof readLatestArtifactArtifactsKeyLatestGet>>
	> = ({ signal }) =>
		readLatestArtifactArtifactsKeyLatestGet(key, { signal, ...fetchOptions });

	return {
		queryKey,
		queryFn,
		enabled: !!key,
		...queryOptions,
	} as UseQueryOptions<
		Awaited<ReturnType<typeof readLatestArtifactArtifactsKeyLatestGet>>,
		TError,
		TData
	> & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type ReadLatestArtifactArtifactsKeyLatestGetQueryResult = NonNullable<
	Awaited<ReturnType<typeof readLatestArtifactArtifactsKeyLatestGet>>
>;
export type ReadLatestArtifactArtifactsKeyLatestGetQueryError =
	HTTPValidationError;

export function useReadLatestArtifactArtifactsKeyLatestGet<
	TData = Awaited<ReturnType<typeof readLatestArtifactArtifactsKeyLatestGet>>,
	TError = HTTPValidationError,
>(
	key: string,
	options: {
		query: Partial<
			UseQueryOptions<
				Awaited<ReturnType<typeof readLatestArtifactArtifactsKeyLatestGet>>,
				TError,
				TData
			>
		> &
			Pick<
				DefinedInitialDataOptions<
					Awaited<ReturnType<typeof readLatestArtifactArtifactsKeyLatestGet>>,
					TError,
					Awaited<ReturnType<typeof readLatestArtifactArtifactsKeyLatestGet>>
				>,
				"initialData"
			>;
		fetch?: RequestInit;
	},
): DefinedUseQueryResult<TData, TError> & {
	queryKey: DataTag<QueryKey, TData, TError>;
};
export function useReadLatestArtifactArtifactsKeyLatestGet<
	TData = Awaited<ReturnType<typeof readLatestArtifactArtifactsKeyLatestGet>>,
	TError = HTTPValidationError,
>(
	key: string,
	options?: {
		query?: Partial<
			UseQueryOptions<
				Awaited<ReturnType<typeof readLatestArtifactArtifactsKeyLatestGet>>,
				TError,
				TData
			>
		> &
			Pick<
				UndefinedInitialDataOptions<
					Awaited<ReturnType<typeof readLatestArtifactArtifactsKeyLatestGet>>,
					TError,
					Awaited<ReturnType<typeof readLatestArtifactArtifactsKeyLatestGet>>
				>,
				"initialData"
			>;
		fetch?: RequestInit;
	},
): UseQueryResult<TData, TError> & {
	queryKey: DataTag<QueryKey, TData, TError>;
};
export function useReadLatestArtifactArtifactsKeyLatestGet<
	TData = Awaited<ReturnType<typeof readLatestArtifactArtifactsKeyLatestGet>>,
	TError = HTTPValidationError,
>(
	key: string,
	options?: {
		query?: Partial<
			UseQueryOptions<
				Awaited<ReturnType<typeof readLatestArtifactArtifactsKeyLatestGet>>,
				TError,
				TData
			>
		>;
		fetch?: RequestInit;
	},
): UseQueryResult<TData, TError> & {
	queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Read Latest Artifact
 */

export function useReadLatestArtifactArtifactsKeyLatestGet<
	TData = Awaited<ReturnType<typeof readLatestArtifactArtifactsKeyLatestGet>>,
	TError = HTTPValidationError,
>(
	key: string,
	options?: {
		query?: Partial<
			UseQueryOptions<
				Awaited<ReturnType<typeof readLatestArtifactArtifactsKeyLatestGet>>,
				TError,
				TData
			>
		>;
		fetch?: RequestInit;
	},
): UseQueryResult<TData, TError> & {
	queryKey: DataTag<QueryKey, TData, TError>;
} {
	const queryOptions = getReadLatestArtifactArtifactsKeyLatestGetQueryOptions(
		key,
		options,
	);

	const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
		queryKey: DataTag<QueryKey, TData, TError>;
	};

	query.queryKey = queryOptions.queryKey;

	return query;
}

export const getReadLatestArtifactArtifactsKeyLatestGetSuspenseQueryOptions = <
	TData = Awaited<ReturnType<typeof readLatestArtifactArtifactsKeyLatestGet>>,
	TError = HTTPValidationError,
>(
	key: string,
	options?: {
		query?: Partial<
			UseSuspenseQueryOptions<
				Awaited<ReturnType<typeof readLatestArtifactArtifactsKeyLatestGet>>,
				TError,
				TData
			>
		>;
		fetch?: RequestInit;
	},
) => {
	const { query: queryOptions, fetch: fetchOptions } = options ?? {};

	const queryKey =
		queryOptions?.queryKey ??
		getReadLatestArtifactArtifactsKeyLatestGetQueryKey(key);

	const queryFn: QueryFunction<
		Awaited<ReturnType<typeof readLatestArtifactArtifactsKeyLatestGet>>
	> = ({ signal }) =>
		readLatestArtifactArtifactsKeyLatestGet(key, { signal, ...fetchOptions });

	return { queryKey, queryFn, ...queryOptions } as UseSuspenseQueryOptions<
		Awaited<ReturnType<typeof readLatestArtifactArtifactsKeyLatestGet>>,
		TError,
		TData
	> & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type ReadLatestArtifactArtifactsKeyLatestGetSuspenseQueryResult =
	NonNullable<
		Awaited<ReturnType<typeof readLatestArtifactArtifactsKeyLatestGet>>
	>;
export type ReadLatestArtifactArtifactsKeyLatestGetSuspenseQueryError =
	HTTPValidationError;

export function useReadLatestArtifactArtifactsKeyLatestGetSuspense<
	TData = Awaited<ReturnType<typeof readLatestArtifactArtifactsKeyLatestGet>>,
	TError = HTTPValidationError,
>(
	key: string,
	options: {
		query: Partial<
			UseSuspenseQueryOptions<
				Awaited<ReturnType<typeof readLatestArtifactArtifactsKeyLatestGet>>,
				TError,
				TData
			>
		>;
		fetch?: RequestInit;
	},
): UseSuspenseQueryResult<TData, TError> & {
	queryKey: DataTag<QueryKey, TData, TError>;
};
export function useReadLatestArtifactArtifactsKeyLatestGetSuspense<
	TData = Awaited<ReturnType<typeof readLatestArtifactArtifactsKeyLatestGet>>,
	TError = HTTPValidationError,
>(
	key: string,
	options?: {
		query?: Partial<
			UseSuspenseQueryOptions<
				Awaited<ReturnType<typeof readLatestArtifactArtifactsKeyLatestGet>>,
				TError,
				TData
			>
		>;
		fetch?: RequestInit;
	},
): UseSuspenseQueryResult<TData, TError> & {
	queryKey: DataTag<QueryKey, TData, TError>;
};
export function useReadLatestArtifactArtifactsKeyLatestGetSuspense<
	TData = Awaited<ReturnType<typeof readLatestArtifactArtifactsKeyLatestGet>>,
	TError = HTTPValidationError,
>(
	key: string,
	options?: {
		query?: Partial<
			UseSuspenseQueryOptions<
				Awaited<ReturnType<typeof readLatestArtifactArtifactsKeyLatestGet>>,
				TError,
				TData
			>
		>;
		fetch?: RequestInit;
	},
): UseSuspenseQueryResult<TData, TError> & {
	queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Read Latest Artifact
 */

export function useReadLatestArtifactArtifactsKeyLatestGetSuspense<
	TData = Awaited<ReturnType<typeof readLatestArtifactArtifactsKeyLatestGet>>,
	TError = HTTPValidationError,
>(
	key: string,
	options?: {
		query?: Partial<
			UseSuspenseQueryOptions<
				Awaited<ReturnType<typeof readLatestArtifactArtifactsKeyLatestGet>>,
				TError,
				TData
			>
		>;
		fetch?: RequestInit;
	},
): UseSuspenseQueryResult<TData, TError> & {
	queryKey: DataTag<QueryKey, TData, TError>;
} {
	const queryOptions =
		getReadLatestArtifactArtifactsKeyLatestGetSuspenseQueryOptions(
			key,
			options,
		);

	const query = useSuspenseQuery(queryOptions) as UseSuspenseQueryResult<
		TData,
		TError
	> & { queryKey: DataTag<QueryKey, TData, TError> };

	query.queryKey = queryOptions.queryKey;

	return query;
}

/**
 * Retrieve artifacts from the database.
 * @summary Read Artifacts
 */
export type readArtifactsArtifactsFilterPostResponse = {
	data: Artifact[] | HTTPValidationError;
	status: number;
	headers: Headers;
};

export const getReadArtifactsArtifactsFilterPostUrl = () => {
	return `http://prefect.grose.click/api/artifacts/filter`;
};

export const readArtifactsArtifactsFilterPost = async (
	bodyReadArtifactsArtifactsFilterPost: BodyReadArtifactsArtifactsFilterPost,
	options?: RequestInit,
): Promise<readArtifactsArtifactsFilterPostResponse> => {
	const res = await fetch(getReadArtifactsArtifactsFilterPostUrl(), {
		...options,
		method: "POST",
		headers: { "Content-Type": "application/json", ...options?.headers },
		body: JSON.stringify(bodyReadArtifactsArtifactsFilterPost),
	});

	const body = [204, 205, 304].includes(res.status) ? null : await res.text();
	const data: readArtifactsArtifactsFilterPostResponse["data"] = body
		? JSON.parse(body)
		: {};

	return {
		data,
		status: res.status,
		headers: res.headers,
	} as readArtifactsArtifactsFilterPostResponse;
};

export const getReadArtifactsArtifactsFilterPostMutationOptions = <
	TError = HTTPValidationError,
	TContext = unknown,
>(options?: {
	mutation?: UseMutationOptions<
		Awaited<ReturnType<typeof readArtifactsArtifactsFilterPost>>,
		TError,
		{ data: BodyReadArtifactsArtifactsFilterPost },
		TContext
	>;
	fetch?: RequestInit;
}): UseMutationOptions<
	Awaited<ReturnType<typeof readArtifactsArtifactsFilterPost>>,
	TError,
	{ data: BodyReadArtifactsArtifactsFilterPost },
	TContext
> => {
	const mutationKey = ["readArtifactsArtifactsFilterPost"];
	const { mutation: mutationOptions, fetch: fetchOptions } = options
		? options.mutation &&
			"mutationKey" in options.mutation &&
			options.mutation.mutationKey
			? options
			: { ...options, mutation: { ...options.mutation, mutationKey } }
		: { mutation: { mutationKey }, fetch: undefined };

	const mutationFn: MutationFunction<
		Awaited<ReturnType<typeof readArtifactsArtifactsFilterPost>>,
		{ data: BodyReadArtifactsArtifactsFilterPost }
	> = (props) => {
		const { data } = props ?? {};

		return readArtifactsArtifactsFilterPost(data, fetchOptions);
	};

	return { mutationFn, ...mutationOptions };
};

export type ReadArtifactsArtifactsFilterPostMutationResult = NonNullable<
	Awaited<ReturnType<typeof readArtifactsArtifactsFilterPost>>
>;
export type ReadArtifactsArtifactsFilterPostMutationBody =
	BodyReadArtifactsArtifactsFilterPost;
export type ReadArtifactsArtifactsFilterPostMutationError = HTTPValidationError;

/**
 * @summary Read Artifacts
 */
export const useReadArtifactsArtifactsFilterPost = <
	TError = HTTPValidationError,
	TContext = unknown,
>(options?: {
	mutation?: UseMutationOptions<
		Awaited<ReturnType<typeof readArtifactsArtifactsFilterPost>>,
		TError,
		{ data: BodyReadArtifactsArtifactsFilterPost },
		TContext
	>;
	fetch?: RequestInit;
}): UseMutationResult<
	Awaited<ReturnType<typeof readArtifactsArtifactsFilterPost>>,
	TError,
	{ data: BodyReadArtifactsArtifactsFilterPost },
	TContext
> => {
	const mutationOptions =
		getReadArtifactsArtifactsFilterPostMutationOptions(options);

	return useMutation(mutationOptions);
};
/**
 * Retrieve artifacts from the database.
 * @summary Read Latest Artifacts
 */
export type readLatestArtifactsArtifactsLatestFilterPostResponse = {
	data: ArtifactCollection[] | HTTPValidationError;
	status: number;
	headers: Headers;
};

export const getReadLatestArtifactsArtifactsLatestFilterPostUrl = () => {
	return `http://prefect.grose.click/api/artifacts/latest/filter`;
};

export const readLatestArtifactsArtifactsLatestFilterPost = async (
	bodyReadLatestArtifactsArtifactsLatestFilterPost: BodyReadLatestArtifactsArtifactsLatestFilterPost,
	options?: RequestInit,
): Promise<readLatestArtifactsArtifactsLatestFilterPostResponse> => {
	const res = await fetch(
		getReadLatestArtifactsArtifactsLatestFilterPostUrl(),
		{
			...options,
			method: "POST",
			headers: { "Content-Type": "application/json", ...options?.headers },
			body: JSON.stringify(bodyReadLatestArtifactsArtifactsLatestFilterPost),
		},
	);

	const body = [204, 205, 304].includes(res.status) ? null : await res.text();
	const data: readLatestArtifactsArtifactsLatestFilterPostResponse["data"] =
		body ? JSON.parse(body) : {};

	return {
		data,
		status: res.status,
		headers: res.headers,
	} as readLatestArtifactsArtifactsLatestFilterPostResponse;
};

export const getReadLatestArtifactsArtifactsLatestFilterPostMutationOptions = <
	TError = HTTPValidationError,
	TContext = unknown,
>(options?: {
	mutation?: UseMutationOptions<
		Awaited<ReturnType<typeof readLatestArtifactsArtifactsLatestFilterPost>>,
		TError,
		{ data: BodyReadLatestArtifactsArtifactsLatestFilterPost },
		TContext
	>;
	fetch?: RequestInit;
}): UseMutationOptions<
	Awaited<ReturnType<typeof readLatestArtifactsArtifactsLatestFilterPost>>,
	TError,
	{ data: BodyReadLatestArtifactsArtifactsLatestFilterPost },
	TContext
> => {
	const mutationKey = ["readLatestArtifactsArtifactsLatestFilterPost"];
	const { mutation: mutationOptions, fetch: fetchOptions } = options
		? options.mutation &&
			"mutationKey" in options.mutation &&
			options.mutation.mutationKey
			? options
			: { ...options, mutation: { ...options.mutation, mutationKey } }
		: { mutation: { mutationKey }, fetch: undefined };

	const mutationFn: MutationFunction<
		Awaited<ReturnType<typeof readLatestArtifactsArtifactsLatestFilterPost>>,
		{ data: BodyReadLatestArtifactsArtifactsLatestFilterPost }
	> = (props) => {
		const { data } = props ?? {};

		return readLatestArtifactsArtifactsLatestFilterPost(data, fetchOptions);
	};

	return { mutationFn, ...mutationOptions };
};

export type ReadLatestArtifactsArtifactsLatestFilterPostMutationResult =
	NonNullable<
		Awaited<ReturnType<typeof readLatestArtifactsArtifactsLatestFilterPost>>
	>;
export type ReadLatestArtifactsArtifactsLatestFilterPostMutationBody =
	BodyReadLatestArtifactsArtifactsLatestFilterPost;
export type ReadLatestArtifactsArtifactsLatestFilterPostMutationError =
	HTTPValidationError;

/**
 * @summary Read Latest Artifacts
 */
export const useReadLatestArtifactsArtifactsLatestFilterPost = <
	TError = HTTPValidationError,
	TContext = unknown,
>(options?: {
	mutation?: UseMutationOptions<
		Awaited<ReturnType<typeof readLatestArtifactsArtifactsLatestFilterPost>>,
		TError,
		{ data: BodyReadLatestArtifactsArtifactsLatestFilterPost },
		TContext
	>;
	fetch?: RequestInit;
}): UseMutationResult<
	Awaited<ReturnType<typeof readLatestArtifactsArtifactsLatestFilterPost>>,
	TError,
	{ data: BodyReadLatestArtifactsArtifactsLatestFilterPost },
	TContext
> => {
	const mutationOptions =
		getReadLatestArtifactsArtifactsLatestFilterPostMutationOptions(options);

	return useMutation(mutationOptions);
};
/**
 * Count artifacts from the database.
 * @summary Count Artifacts
 */
export type countArtifactsArtifactsCountPostResponse = {
	data: number | HTTPValidationError;
	status: number;
	headers: Headers;
};

export const getCountArtifactsArtifactsCountPostUrl = () => {
	return `http://prefect.grose.click/api/artifacts/count`;
};

export const countArtifactsArtifactsCountPost = async (
	bodyCountArtifactsArtifactsCountPost: BodyCountArtifactsArtifactsCountPost,
	options?: RequestInit,
): Promise<countArtifactsArtifactsCountPostResponse> => {
	const res = await fetch(getCountArtifactsArtifactsCountPostUrl(), {
		...options,
		method: "POST",
		headers: { "Content-Type": "application/json", ...options?.headers },
		body: JSON.stringify(bodyCountArtifactsArtifactsCountPost),
	});

	const body = [204, 205, 304].includes(res.status) ? null : await res.text();
	const data: countArtifactsArtifactsCountPostResponse["data"] = body
		? JSON.parse(body)
		: {};

	return {
		data,
		status: res.status,
		headers: res.headers,
	} as countArtifactsArtifactsCountPostResponse;
};

export const getCountArtifactsArtifactsCountPostMutationOptions = <
	TError = HTTPValidationError,
	TContext = unknown,
>(options?: {
	mutation?: UseMutationOptions<
		Awaited<ReturnType<typeof countArtifactsArtifactsCountPost>>,
		TError,
		{ data: BodyCountArtifactsArtifactsCountPost },
		TContext
	>;
	fetch?: RequestInit;
}): UseMutationOptions<
	Awaited<ReturnType<typeof countArtifactsArtifactsCountPost>>,
	TError,
	{ data: BodyCountArtifactsArtifactsCountPost },
	TContext
> => {
	const mutationKey = ["countArtifactsArtifactsCountPost"];
	const { mutation: mutationOptions, fetch: fetchOptions } = options
		? options.mutation &&
			"mutationKey" in options.mutation &&
			options.mutation.mutationKey
			? options
			: { ...options, mutation: { ...options.mutation, mutationKey } }
		: { mutation: { mutationKey }, fetch: undefined };

	const mutationFn: MutationFunction<
		Awaited<ReturnType<typeof countArtifactsArtifactsCountPost>>,
		{ data: BodyCountArtifactsArtifactsCountPost }
	> = (props) => {
		const { data } = props ?? {};

		return countArtifactsArtifactsCountPost(data, fetchOptions);
	};

	return { mutationFn, ...mutationOptions };
};

export type CountArtifactsArtifactsCountPostMutationResult = NonNullable<
	Awaited<ReturnType<typeof countArtifactsArtifactsCountPost>>
>;
export type CountArtifactsArtifactsCountPostMutationBody =
	BodyCountArtifactsArtifactsCountPost;
export type CountArtifactsArtifactsCountPostMutationError = HTTPValidationError;

/**
 * @summary Count Artifacts
 */
export const useCountArtifactsArtifactsCountPost = <
	TError = HTTPValidationError,
	TContext = unknown,
>(options?: {
	mutation?: UseMutationOptions<
		Awaited<ReturnType<typeof countArtifactsArtifactsCountPost>>,
		TError,
		{ data: BodyCountArtifactsArtifactsCountPost },
		TContext
	>;
	fetch?: RequestInit;
}): UseMutationResult<
	Awaited<ReturnType<typeof countArtifactsArtifactsCountPost>>,
	TError,
	{ data: BodyCountArtifactsArtifactsCountPost },
	TContext
> => {
	const mutationOptions =
		getCountArtifactsArtifactsCountPostMutationOptions(options);

	return useMutation(mutationOptions);
};
/**
 * Count artifacts from the database.
 * @summary Count Latest Artifacts
 */
export type countLatestArtifactsArtifactsLatestCountPostResponse = {
	data: number | HTTPValidationError;
	status: number;
	headers: Headers;
};

export const getCountLatestArtifactsArtifactsLatestCountPostUrl = () => {
	return `http://prefect.grose.click/api/artifacts/latest/count`;
};

export const countLatestArtifactsArtifactsLatestCountPost = async (
	bodyCountLatestArtifactsArtifactsLatestCountPost: BodyCountLatestArtifactsArtifactsLatestCountPost,
	options?: RequestInit,
): Promise<countLatestArtifactsArtifactsLatestCountPostResponse> => {
	const res = await fetch(
		getCountLatestArtifactsArtifactsLatestCountPostUrl(),
		{
			...options,
			method: "POST",
			headers: { "Content-Type": "application/json", ...options?.headers },
			body: JSON.stringify(bodyCountLatestArtifactsArtifactsLatestCountPost),
		},
	);

	const body = [204, 205, 304].includes(res.status) ? null : await res.text();
	const data: countLatestArtifactsArtifactsLatestCountPostResponse["data"] =
		body ? JSON.parse(body) : {};

	return {
		data,
		status: res.status,
		headers: res.headers,
	} as countLatestArtifactsArtifactsLatestCountPostResponse;
};

export const getCountLatestArtifactsArtifactsLatestCountPostMutationOptions = <
	TError = HTTPValidationError,
	TContext = unknown,
>(options?: {
	mutation?: UseMutationOptions<
		Awaited<ReturnType<typeof countLatestArtifactsArtifactsLatestCountPost>>,
		TError,
		{ data: BodyCountLatestArtifactsArtifactsLatestCountPost },
		TContext
	>;
	fetch?: RequestInit;
}): UseMutationOptions<
	Awaited<ReturnType<typeof countLatestArtifactsArtifactsLatestCountPost>>,
	TError,
	{ data: BodyCountLatestArtifactsArtifactsLatestCountPost },
	TContext
> => {
	const mutationKey = ["countLatestArtifactsArtifactsLatestCountPost"];
	const { mutation: mutationOptions, fetch: fetchOptions } = options
		? options.mutation &&
			"mutationKey" in options.mutation &&
			options.mutation.mutationKey
			? options
			: { ...options, mutation: { ...options.mutation, mutationKey } }
		: { mutation: { mutationKey }, fetch: undefined };

	const mutationFn: MutationFunction<
		Awaited<ReturnType<typeof countLatestArtifactsArtifactsLatestCountPost>>,
		{ data: BodyCountLatestArtifactsArtifactsLatestCountPost }
	> = (props) => {
		const { data } = props ?? {};

		return countLatestArtifactsArtifactsLatestCountPost(data, fetchOptions);
	};

	return { mutationFn, ...mutationOptions };
};

export type CountLatestArtifactsArtifactsLatestCountPostMutationResult =
	NonNullable<
		Awaited<ReturnType<typeof countLatestArtifactsArtifactsLatestCountPost>>
	>;
export type CountLatestArtifactsArtifactsLatestCountPostMutationBody =
	BodyCountLatestArtifactsArtifactsLatestCountPost;
export type CountLatestArtifactsArtifactsLatestCountPostMutationError =
	HTTPValidationError;

/**
 * @summary Count Latest Artifacts
 */
export const useCountLatestArtifactsArtifactsLatestCountPost = <
	TError = HTTPValidationError,
	TContext = unknown,
>(options?: {
	mutation?: UseMutationOptions<
		Awaited<ReturnType<typeof countLatestArtifactsArtifactsLatestCountPost>>,
		TError,
		{ data: BodyCountLatestArtifactsArtifactsLatestCountPost },
		TContext
	>;
	fetch?: RequestInit;
}): UseMutationResult<
	Awaited<ReturnType<typeof countLatestArtifactsArtifactsLatestCountPost>>,
	TError,
	{ data: BodyCountLatestArtifactsArtifactsLatestCountPost },
	TContext
> => {
	const mutationOptions =
		getCountLatestArtifactsArtifactsLatestCountPostMutationOptions(options);

	return useMutation(mutationOptions);
};
