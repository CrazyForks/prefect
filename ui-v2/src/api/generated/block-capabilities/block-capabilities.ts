/**
 * Generated by orval v7.5.0 🍺
 * Do not edit manually.
 * Prefect Prefect REST API
 * OpenAPI spec version: 0.1.0
 */
import { useQuery, useSuspenseQuery } from "@tanstack/react-query";
import type {
	DataTag,
	DefinedInitialDataOptions,
	DefinedUseQueryResult,
	QueryFunction,
	QueryKey,
	UndefinedInitialDataOptions,
	UseQueryOptions,
	UseQueryResult,
	UseSuspenseQueryOptions,
	UseSuspenseQueryResult,
} from "@tanstack/react-query";
import type { HTTPValidationError } from "../../models";

/**
 * @summary Read Available Block Capabilities
 */
export type readAvailableBlockCapabilitiesBlockCapabilitiesGetResponse = {
	data: string[] | HTTPValidationError;
	status: number;
	headers: Headers;
};

export const getReadAvailableBlockCapabilitiesBlockCapabilitiesGetUrl = () => {
	return `http://prefect.grose.click/api/block_capabilities/`;
};

export const readAvailableBlockCapabilitiesBlockCapabilitiesGet = async (
	options?: RequestInit,
): Promise<readAvailableBlockCapabilitiesBlockCapabilitiesGetResponse> => {
	const res = await fetch(
		getReadAvailableBlockCapabilitiesBlockCapabilitiesGetUrl(),
		{
			...options,
			method: "GET",
		},
	);

	const body = [204, 205, 304].includes(res.status) ? null : await res.text();
	const data: readAvailableBlockCapabilitiesBlockCapabilitiesGetResponse["data"] =
		body ? JSON.parse(body) : {};

	return {
		data,
		status: res.status,
		headers: res.headers,
	} as readAvailableBlockCapabilitiesBlockCapabilitiesGetResponse;
};

export const getReadAvailableBlockCapabilitiesBlockCapabilitiesGetQueryKey =
	() => {
		return [`http://prefect.grose.click/api/block_capabilities/`] as const;
	};

export const getReadAvailableBlockCapabilitiesBlockCapabilitiesGetQueryOptions =
	<
		TData = Awaited<
			ReturnType<typeof readAvailableBlockCapabilitiesBlockCapabilitiesGet>
		>,
		TError = HTTPValidationError,
	>(options?: {
		query?: Partial<
			UseQueryOptions<
				Awaited<
					ReturnType<typeof readAvailableBlockCapabilitiesBlockCapabilitiesGet>
				>,
				TError,
				TData
			>
		>;
		fetch?: RequestInit;
	}) => {
		const { query: queryOptions, fetch: fetchOptions } = options ?? {};

		const queryKey =
			queryOptions?.queryKey ??
			getReadAvailableBlockCapabilitiesBlockCapabilitiesGetQueryKey();

		const queryFn: QueryFunction<
			Awaited<
				ReturnType<typeof readAvailableBlockCapabilitiesBlockCapabilitiesGet>
			>
		> = ({ signal }) =>
			readAvailableBlockCapabilitiesBlockCapabilitiesGet({
				signal,
				...fetchOptions,
			});

		return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
			Awaited<
				ReturnType<typeof readAvailableBlockCapabilitiesBlockCapabilitiesGet>
			>,
			TError,
			TData
		> & { queryKey: DataTag<QueryKey, TData, TError> };
	};

export type ReadAvailableBlockCapabilitiesBlockCapabilitiesGetQueryResult =
	NonNullable<
		Awaited<
			ReturnType<typeof readAvailableBlockCapabilitiesBlockCapabilitiesGet>
		>
	>;
export type ReadAvailableBlockCapabilitiesBlockCapabilitiesGetQueryError =
	HTTPValidationError;

export function useReadAvailableBlockCapabilitiesBlockCapabilitiesGet<
	TData = Awaited<
		ReturnType<typeof readAvailableBlockCapabilitiesBlockCapabilitiesGet>
	>,
	TError = HTTPValidationError,
>(options: {
	query: Partial<
		UseQueryOptions<
			Awaited<
				ReturnType<typeof readAvailableBlockCapabilitiesBlockCapabilitiesGet>
			>,
			TError,
			TData
		>
	> &
		Pick<
			DefinedInitialDataOptions<
				Awaited<
					ReturnType<typeof readAvailableBlockCapabilitiesBlockCapabilitiesGet>
				>,
				TError,
				Awaited<
					ReturnType<typeof readAvailableBlockCapabilitiesBlockCapabilitiesGet>
				>
			>,
			"initialData"
		>;
	fetch?: RequestInit;
}): DefinedUseQueryResult<TData, TError> & {
	queryKey: DataTag<QueryKey, TData, TError>;
};
export function useReadAvailableBlockCapabilitiesBlockCapabilitiesGet<
	TData = Awaited<
		ReturnType<typeof readAvailableBlockCapabilitiesBlockCapabilitiesGet>
	>,
	TError = HTTPValidationError,
>(options?: {
	query?: Partial<
		UseQueryOptions<
			Awaited<
				ReturnType<typeof readAvailableBlockCapabilitiesBlockCapabilitiesGet>
			>,
			TError,
			TData
		>
	> &
		Pick<
			UndefinedInitialDataOptions<
				Awaited<
					ReturnType<typeof readAvailableBlockCapabilitiesBlockCapabilitiesGet>
				>,
				TError,
				Awaited<
					ReturnType<typeof readAvailableBlockCapabilitiesBlockCapabilitiesGet>
				>
			>,
			"initialData"
		>;
	fetch?: RequestInit;
}): UseQueryResult<TData, TError> & {
	queryKey: DataTag<QueryKey, TData, TError>;
};
export function useReadAvailableBlockCapabilitiesBlockCapabilitiesGet<
	TData = Awaited<
		ReturnType<typeof readAvailableBlockCapabilitiesBlockCapabilitiesGet>
	>,
	TError = HTTPValidationError,
>(options?: {
	query?: Partial<
		UseQueryOptions<
			Awaited<
				ReturnType<typeof readAvailableBlockCapabilitiesBlockCapabilitiesGet>
			>,
			TError,
			TData
		>
	>;
	fetch?: RequestInit;
}): UseQueryResult<TData, TError> & {
	queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Read Available Block Capabilities
 */

export function useReadAvailableBlockCapabilitiesBlockCapabilitiesGet<
	TData = Awaited<
		ReturnType<typeof readAvailableBlockCapabilitiesBlockCapabilitiesGet>
	>,
	TError = HTTPValidationError,
>(options?: {
	query?: Partial<
		UseQueryOptions<
			Awaited<
				ReturnType<typeof readAvailableBlockCapabilitiesBlockCapabilitiesGet>
			>,
			TError,
			TData
		>
	>;
	fetch?: RequestInit;
}): UseQueryResult<TData, TError> & {
	queryKey: DataTag<QueryKey, TData, TError>;
} {
	const queryOptions =
		getReadAvailableBlockCapabilitiesBlockCapabilitiesGetQueryOptions(options);

	const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
		queryKey: DataTag<QueryKey, TData, TError>;
	};

	query.queryKey = queryOptions.queryKey;

	return query;
}

export const getReadAvailableBlockCapabilitiesBlockCapabilitiesGetSuspenseQueryOptions =
	<
		TData = Awaited<
			ReturnType<typeof readAvailableBlockCapabilitiesBlockCapabilitiesGet>
		>,
		TError = HTTPValidationError,
	>(options?: {
		query?: Partial<
			UseSuspenseQueryOptions<
				Awaited<
					ReturnType<typeof readAvailableBlockCapabilitiesBlockCapabilitiesGet>
				>,
				TError,
				TData
			>
		>;
		fetch?: RequestInit;
	}) => {
		const { query: queryOptions, fetch: fetchOptions } = options ?? {};

		const queryKey =
			queryOptions?.queryKey ??
			getReadAvailableBlockCapabilitiesBlockCapabilitiesGetQueryKey();

		const queryFn: QueryFunction<
			Awaited<
				ReturnType<typeof readAvailableBlockCapabilitiesBlockCapabilitiesGet>
			>
		> = ({ signal }) =>
			readAvailableBlockCapabilitiesBlockCapabilitiesGet({
				signal,
				...fetchOptions,
			});

		return { queryKey, queryFn, ...queryOptions } as UseSuspenseQueryOptions<
			Awaited<
				ReturnType<typeof readAvailableBlockCapabilitiesBlockCapabilitiesGet>
			>,
			TError,
			TData
		> & { queryKey: DataTag<QueryKey, TData, TError> };
	};

export type ReadAvailableBlockCapabilitiesBlockCapabilitiesGetSuspenseQueryResult =
	NonNullable<
		Awaited<
			ReturnType<typeof readAvailableBlockCapabilitiesBlockCapabilitiesGet>
		>
	>;
export type ReadAvailableBlockCapabilitiesBlockCapabilitiesGetSuspenseQueryError =
	HTTPValidationError;

export function useReadAvailableBlockCapabilitiesBlockCapabilitiesGetSuspense<
	TData = Awaited<
		ReturnType<typeof readAvailableBlockCapabilitiesBlockCapabilitiesGet>
	>,
	TError = HTTPValidationError,
>(options: {
	query: Partial<
		UseSuspenseQueryOptions<
			Awaited<
				ReturnType<typeof readAvailableBlockCapabilitiesBlockCapabilitiesGet>
			>,
			TError,
			TData
		>
	>;
	fetch?: RequestInit;
}): UseSuspenseQueryResult<TData, TError> & {
	queryKey: DataTag<QueryKey, TData, TError>;
};
export function useReadAvailableBlockCapabilitiesBlockCapabilitiesGetSuspense<
	TData = Awaited<
		ReturnType<typeof readAvailableBlockCapabilitiesBlockCapabilitiesGet>
	>,
	TError = HTTPValidationError,
>(options?: {
	query?: Partial<
		UseSuspenseQueryOptions<
			Awaited<
				ReturnType<typeof readAvailableBlockCapabilitiesBlockCapabilitiesGet>
			>,
			TError,
			TData
		>
	>;
	fetch?: RequestInit;
}): UseSuspenseQueryResult<TData, TError> & {
	queryKey: DataTag<QueryKey, TData, TError>;
};
export function useReadAvailableBlockCapabilitiesBlockCapabilitiesGetSuspense<
	TData = Awaited<
		ReturnType<typeof readAvailableBlockCapabilitiesBlockCapabilitiesGet>
	>,
	TError = HTTPValidationError,
>(options?: {
	query?: Partial<
		UseSuspenseQueryOptions<
			Awaited<
				ReturnType<typeof readAvailableBlockCapabilitiesBlockCapabilitiesGet>
			>,
			TError,
			TData
		>
	>;
	fetch?: RequestInit;
}): UseSuspenseQueryResult<TData, TError> & {
	queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Read Available Block Capabilities
 */

export function useReadAvailableBlockCapabilitiesBlockCapabilitiesGetSuspense<
	TData = Awaited<
		ReturnType<typeof readAvailableBlockCapabilitiesBlockCapabilitiesGet>
	>,
	TError = HTTPValidationError,
>(options?: {
	query?: Partial<
		UseSuspenseQueryOptions<
			Awaited<
				ReturnType<typeof readAvailableBlockCapabilitiesBlockCapabilitiesGet>
			>,
			TError,
			TData
		>
	>;
	fetch?: RequestInit;
}): UseSuspenseQueryResult<TData, TError> & {
	queryKey: DataTag<QueryKey, TData, TError>;
} {
	const queryOptions =
		getReadAvailableBlockCapabilitiesBlockCapabilitiesGetSuspenseQueryOptions(
			options,
		);

	const query = useSuspenseQuery(queryOptions) as UseSuspenseQueryResult<
		TData,
		TError
	> & { queryKey: DataTag<QueryKey, TData, TError> };

	query.queryKey = queryOptions.queryKey;

	return query;
}
