/**
 * Generated by orval v7.5.0 🍺
 * Do not edit manually.
 * Prefect Prefect REST API
 * OpenAPI spec version: 0.1.0
 */
import { useMutation } from "@tanstack/react-query";
import type {
	MutationFunction,
	UseMutationOptions,
	UseMutationResult,
} from "@tanstack/react-query";
import type {
	BodyReadTaskWorkersTaskWorkersFilterPost,
	HTTPValidationError,
	TaskWorkerResponse,
} from "../../models";

/**
 * Read active task workers. Optionally filter by task keys.
 * @summary Read Task Workers
 */
export type readTaskWorkersTaskWorkersFilterPostResponse = {
	data: TaskWorkerResponse[] | HTTPValidationError;
	status: number;
	headers: Headers;
};

export const getReadTaskWorkersTaskWorkersFilterPostUrl = () => {
	return `http://prefect.grose.click/api/task_workers/filter`;
};

export const readTaskWorkersTaskWorkersFilterPost = async (
	bodyReadTaskWorkersTaskWorkersFilterPost: BodyReadTaskWorkersTaskWorkersFilterPost,
	options?: RequestInit,
): Promise<readTaskWorkersTaskWorkersFilterPostResponse> => {
	const res = await fetch(getReadTaskWorkersTaskWorkersFilterPostUrl(), {
		...options,
		method: "POST",
		headers: { "Content-Type": "application/json", ...options?.headers },
		body: JSON.stringify(bodyReadTaskWorkersTaskWorkersFilterPost),
	});

	const body = [204, 205, 304].includes(res.status) ? null : await res.text();
	const data: readTaskWorkersTaskWorkersFilterPostResponse["data"] = body
		? JSON.parse(body)
		: {};

	return {
		data,
		status: res.status,
		headers: res.headers,
	} as readTaskWorkersTaskWorkersFilterPostResponse;
};

export const getReadTaskWorkersTaskWorkersFilterPostMutationOptions = <
	TError = HTTPValidationError,
	TContext = unknown,
>(options?: {
	mutation?: UseMutationOptions<
		Awaited<ReturnType<typeof readTaskWorkersTaskWorkersFilterPost>>,
		TError,
		{ data: BodyReadTaskWorkersTaskWorkersFilterPost },
		TContext
	>;
	fetch?: RequestInit;
}): UseMutationOptions<
	Awaited<ReturnType<typeof readTaskWorkersTaskWorkersFilterPost>>,
	TError,
	{ data: BodyReadTaskWorkersTaskWorkersFilterPost },
	TContext
> => {
	const mutationKey = ["readTaskWorkersTaskWorkersFilterPost"];
	const { mutation: mutationOptions, fetch: fetchOptions } = options
		? options.mutation &&
			"mutationKey" in options.mutation &&
			options.mutation.mutationKey
			? options
			: { ...options, mutation: { ...options.mutation, mutationKey } }
		: { mutation: { mutationKey }, fetch: undefined };

	const mutationFn: MutationFunction<
		Awaited<ReturnType<typeof readTaskWorkersTaskWorkersFilterPost>>,
		{ data: BodyReadTaskWorkersTaskWorkersFilterPost }
	> = (props) => {
		const { data } = props ?? {};

		return readTaskWorkersTaskWorkersFilterPost(data, fetchOptions);
	};

	return { mutationFn, ...mutationOptions };
};

export type ReadTaskWorkersTaskWorkersFilterPostMutationResult = NonNullable<
	Awaited<ReturnType<typeof readTaskWorkersTaskWorkersFilterPost>>
>;
export type ReadTaskWorkersTaskWorkersFilterPostMutationBody =
	BodyReadTaskWorkersTaskWorkersFilterPost;
export type ReadTaskWorkersTaskWorkersFilterPostMutationError =
	HTTPValidationError;

/**
 * @summary Read Task Workers
 */
export const useReadTaskWorkersTaskWorkersFilterPost = <
	TError = HTTPValidationError,
	TContext = unknown,
>(options?: {
	mutation?: UseMutationOptions<
		Awaited<ReturnType<typeof readTaskWorkersTaskWorkersFilterPost>>,
		TError,
		{ data: BodyReadTaskWorkersTaskWorkersFilterPost },
		TContext
	>;
	fetch?: RequestInit;
}): UseMutationResult<
	Awaited<ReturnType<typeof readTaskWorkersTaskWorkersFilterPost>>,
	TError,
	{ data: BodyReadTaskWorkersTaskWorkersFilterPost },
	TContext
> => {
	const mutationOptions =
		getReadTaskWorkersTaskWorkersFilterPostMutationOptions(options);

	return useMutation(mutationOptions);
};
