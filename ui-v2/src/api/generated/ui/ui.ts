/**
 * Generated by orval v7.5.0 🍺
 * Do not edit manually.
 * Prefect Prefect REST API
 * OpenAPI spec version: 0.1.0
 */
import { useMutation } from "@tanstack/react-query";
import type {
	MutationFunction,
	UseMutationOptions,
	UseMutationResult,
} from "@tanstack/react-query";
import type {
	BodyValidateObjUiSchemasValidatePost,
	HTTPValidationError,
	ValidateObjUiSchemasValidatePost200,
} from "../../models";

/**
 * @summary Validate Obj
 */
export type validateObjUiSchemasValidatePostResponse = {
	data: ValidateObjUiSchemasValidatePost200 | HTTPValidationError;
	status: number;
	headers: Headers;
};

export const getValidateObjUiSchemasValidatePostUrl = () => {
	return `http://prefect.grose.click/api/ui/schemas/validate`;
};

export const validateObjUiSchemasValidatePost = async (
	bodyValidateObjUiSchemasValidatePost: BodyValidateObjUiSchemasValidatePost,
	options?: RequestInit,
): Promise<validateObjUiSchemasValidatePostResponse> => {
	const res = await fetch(getValidateObjUiSchemasValidatePostUrl(), {
		...options,
		method: "POST",
		headers: { "Content-Type": "application/json", ...options?.headers },
		body: JSON.stringify(bodyValidateObjUiSchemasValidatePost),
	});

	const body = [204, 205, 304].includes(res.status) ? null : await res.text();
	const data: validateObjUiSchemasValidatePostResponse["data"] = body
		? JSON.parse(body)
		: {};

	return {
		data,
		status: res.status,
		headers: res.headers,
	} as validateObjUiSchemasValidatePostResponse;
};

export const getValidateObjUiSchemasValidatePostMutationOptions = <
	TError = HTTPValidationError,
	TContext = unknown,
>(options?: {
	mutation?: UseMutationOptions<
		Awaited<ReturnType<typeof validateObjUiSchemasValidatePost>>,
		TError,
		{ data: BodyValidateObjUiSchemasValidatePost },
		TContext
	>;
	fetch?: RequestInit;
}): UseMutationOptions<
	Awaited<ReturnType<typeof validateObjUiSchemasValidatePost>>,
	TError,
	{ data: BodyValidateObjUiSchemasValidatePost },
	TContext
> => {
	const mutationKey = ["validateObjUiSchemasValidatePost"];
	const { mutation: mutationOptions, fetch: fetchOptions } = options
		? options.mutation &&
			"mutationKey" in options.mutation &&
			options.mutation.mutationKey
			? options
			: { ...options, mutation: { ...options.mutation, mutationKey } }
		: { mutation: { mutationKey }, fetch: undefined };

	const mutationFn: MutationFunction<
		Awaited<ReturnType<typeof validateObjUiSchemasValidatePost>>,
		{ data: BodyValidateObjUiSchemasValidatePost }
	> = (props) => {
		const { data } = props ?? {};

		return validateObjUiSchemasValidatePost(data, fetchOptions);
	};

	return { mutationFn, ...mutationOptions };
};

export type ValidateObjUiSchemasValidatePostMutationResult = NonNullable<
	Awaited<ReturnType<typeof validateObjUiSchemasValidatePost>>
>;
export type ValidateObjUiSchemasValidatePostMutationBody =
	BodyValidateObjUiSchemasValidatePost;
export type ValidateObjUiSchemasValidatePostMutationError = HTTPValidationError;

/**
 * @summary Validate Obj
 */
export const useValidateObjUiSchemasValidatePost = <
	TError = HTTPValidationError,
	TContext = unknown,
>(options?: {
	mutation?: UseMutationOptions<
		Awaited<ReturnType<typeof validateObjUiSchemasValidatePost>>,
		TError,
		{ data: BodyValidateObjUiSchemasValidatePost },
		TContext
	>;
	fetch?: RequestInit;
}): UseMutationResult<
	Awaited<ReturnType<typeof validateObjUiSchemasValidatePost>>,
	TError,
	{ data: BodyValidateObjUiSchemasValidatePost },
	TContext
> => {
	const mutationOptions =
		getValidateObjUiSchemasValidatePostMutationOptions(options);

	return useMutation(mutationOptions);
};
