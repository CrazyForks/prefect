/**
 * Generated by orval v7.5.0 🍺
 * Do not edit manually.
 * Prefect Prefect REST API
 * OpenAPI spec version: 0.1.0
 */
import { useMutation, useQuery, useSuspenseQuery } from "@tanstack/react-query";
import type {
	DataTag,
	DefinedInitialDataOptions,
	DefinedUseQueryResult,
	MutationFunction,
	QueryFunction,
	QueryKey,
	UndefinedInitialDataOptions,
	UseMutationOptions,
	UseMutationResult,
	UseQueryOptions,
	UseQueryResult,
	UseSuspenseQueryOptions,
	UseSuspenseQueryResult,
} from "@tanstack/react-query";
import type {
	BodyCountAccountEventsEventsCountByCountablePost,
	BodyReadEventsEventsFilterPost,
	Countable,
	Event,
	EventCount,
	EventPage,
	HTTPValidationError,
	ReadAccountEventsPageEventsFilterNextGetParams,
} from "../../models";

/**
 * Record a batch of Events
 * @summary Create Events
 */
export type createEventsEventsPostResponse = {
	data: void | HTTPValidationError;
	status: number;
	headers: Headers;
};

export const getCreateEventsEventsPostUrl = () => {
	return `http://prefect.grose.click/api/events`;
};

export const createEventsEventsPost = async (
	event: Event[],
	options?: RequestInit,
): Promise<createEventsEventsPostResponse> => {
	const res = await fetch(getCreateEventsEventsPostUrl(), {
		...options,
		method: "POST",
		headers: { "Content-Type": "application/json", ...options?.headers },
		body: JSON.stringify(event),
	});

	const body = [204, 205, 304].includes(res.status) ? null : await res.text();
	const data: createEventsEventsPostResponse["data"] = body
		? JSON.parse(body)
		: {};

	return {
		data,
		status: res.status,
		headers: res.headers,
	} as createEventsEventsPostResponse;
};

export const getCreateEventsEventsPostMutationOptions = <
	TError = HTTPValidationError,
	TContext = unknown,
>(options?: {
	mutation?: UseMutationOptions<
		Awaited<ReturnType<typeof createEventsEventsPost>>,
		TError,
		{ data: Event[] },
		TContext
	>;
	fetch?: RequestInit;
}): UseMutationOptions<
	Awaited<ReturnType<typeof createEventsEventsPost>>,
	TError,
	{ data: Event[] },
	TContext
> => {
	const mutationKey = ["createEventsEventsPost"];
	const { mutation: mutationOptions, fetch: fetchOptions } = options
		? options.mutation &&
			"mutationKey" in options.mutation &&
			options.mutation.mutationKey
			? options
			: { ...options, mutation: { ...options.mutation, mutationKey } }
		: { mutation: { mutationKey }, fetch: undefined };

	const mutationFn: MutationFunction<
		Awaited<ReturnType<typeof createEventsEventsPost>>,
		{ data: Event[] }
	> = (props) => {
		const { data } = props ?? {};

		return createEventsEventsPost(data, fetchOptions);
	};

	return { mutationFn, ...mutationOptions };
};

export type CreateEventsEventsPostMutationResult = NonNullable<
	Awaited<ReturnType<typeof createEventsEventsPost>>
>;
export type CreateEventsEventsPostMutationBody = Event[];
export type CreateEventsEventsPostMutationError = HTTPValidationError;

/**
 * @summary Create Events
 */
export const useCreateEventsEventsPost = <
	TError = HTTPValidationError,
	TContext = unknown,
>(options?: {
	mutation?: UseMutationOptions<
		Awaited<ReturnType<typeof createEventsEventsPost>>,
		TError,
		{ data: Event[] },
		TContext
	>;
	fetch?: RequestInit;
}): UseMutationResult<
	Awaited<ReturnType<typeof createEventsEventsPost>>,
	TError,
	{ data: Event[] },
	TContext
> => {
	const mutationOptions = getCreateEventsEventsPostMutationOptions(options);

	return useMutation(mutationOptions);
};
/**
 * Queries for Events matching the given filter criteria in the given Account.  Returns
the first page of results, and the URL to request the next page (if there are more
results).
 * @summary Read Events
 */
export type readEventsEventsFilterPostResponse = {
	data: EventPage | HTTPValidationError;
	status: number;
	headers: Headers;
};

export const getReadEventsEventsFilterPostUrl = () => {
	return `http://prefect.grose.click/api/events/filter`;
};

export const readEventsEventsFilterPost = async (
	bodyReadEventsEventsFilterPost: BodyReadEventsEventsFilterPost,
	options?: RequestInit,
): Promise<readEventsEventsFilterPostResponse> => {
	const res = await fetch(getReadEventsEventsFilterPostUrl(), {
		...options,
		method: "POST",
		headers: { "Content-Type": "application/json", ...options?.headers },
		body: JSON.stringify(bodyReadEventsEventsFilterPost),
	});

	const body = [204, 205, 304].includes(res.status) ? null : await res.text();
	const data: readEventsEventsFilterPostResponse["data"] = body
		? JSON.parse(body)
		: {};

	return {
		data,
		status: res.status,
		headers: res.headers,
	} as readEventsEventsFilterPostResponse;
};

export const getReadEventsEventsFilterPostMutationOptions = <
	TError = HTTPValidationError,
	TContext = unknown,
>(options?: {
	mutation?: UseMutationOptions<
		Awaited<ReturnType<typeof readEventsEventsFilterPost>>,
		TError,
		{ data: BodyReadEventsEventsFilterPost },
		TContext
	>;
	fetch?: RequestInit;
}): UseMutationOptions<
	Awaited<ReturnType<typeof readEventsEventsFilterPost>>,
	TError,
	{ data: BodyReadEventsEventsFilterPost },
	TContext
> => {
	const mutationKey = ["readEventsEventsFilterPost"];
	const { mutation: mutationOptions, fetch: fetchOptions } = options
		? options.mutation &&
			"mutationKey" in options.mutation &&
			options.mutation.mutationKey
			? options
			: { ...options, mutation: { ...options.mutation, mutationKey } }
		: { mutation: { mutationKey }, fetch: undefined };

	const mutationFn: MutationFunction<
		Awaited<ReturnType<typeof readEventsEventsFilterPost>>,
		{ data: BodyReadEventsEventsFilterPost }
	> = (props) => {
		const { data } = props ?? {};

		return readEventsEventsFilterPost(data, fetchOptions);
	};

	return { mutationFn, ...mutationOptions };
};

export type ReadEventsEventsFilterPostMutationResult = NonNullable<
	Awaited<ReturnType<typeof readEventsEventsFilterPost>>
>;
export type ReadEventsEventsFilterPostMutationBody =
	BodyReadEventsEventsFilterPost;
export type ReadEventsEventsFilterPostMutationError = HTTPValidationError;

/**
 * @summary Read Events
 */
export const useReadEventsEventsFilterPost = <
	TError = HTTPValidationError,
	TContext = unknown,
>(options?: {
	mutation?: UseMutationOptions<
		Awaited<ReturnType<typeof readEventsEventsFilterPost>>,
		TError,
		{ data: BodyReadEventsEventsFilterPost },
		TContext
	>;
	fetch?: RequestInit;
}): UseMutationResult<
	Awaited<ReturnType<typeof readEventsEventsFilterPost>>,
	TError,
	{ data: BodyReadEventsEventsFilterPost },
	TContext
> => {
	const mutationOptions = getReadEventsEventsFilterPostMutationOptions(options);

	return useMutation(mutationOptions);
};
/**
 * Returns the next page of Events for a previous query against the given Account, and
the URL to request the next page (if there are more results).
 * @summary Read Account Events Page
 */
export type readAccountEventsPageEventsFilterNextGetResponse = {
	data: EventPage | HTTPValidationError;
	status: number;
	headers: Headers;
};

export const getReadAccountEventsPageEventsFilterNextGetUrl = (
	params: ReadAccountEventsPageEventsFilterNextGetParams,
) => {
	const normalizedParams = new URLSearchParams();

	Object.entries(params || {}).forEach(([key, value]) => {
		if (value !== undefined) {
			normalizedParams.append(key, value === null ? "null" : value.toString());
		}
	});

	return normalizedParams.size
		? `http://prefect.grose.click/api/events/filter/next?${normalizedParams.toString()}`
		: `http://prefect.grose.click/api/events/filter/next`;
};

export const readAccountEventsPageEventsFilterNextGet = async (
	params: ReadAccountEventsPageEventsFilterNextGetParams,
	options?: RequestInit,
): Promise<readAccountEventsPageEventsFilterNextGetResponse> => {
	const res = await fetch(
		getReadAccountEventsPageEventsFilterNextGetUrl(params),
		{
			...options,
			method: "GET",
		},
	);

	const body = [204, 205, 304].includes(res.status) ? null : await res.text();
	const data: readAccountEventsPageEventsFilterNextGetResponse["data"] = body
		? JSON.parse(body)
		: {};

	return {
		data,
		status: res.status,
		headers: res.headers,
	} as readAccountEventsPageEventsFilterNextGetResponse;
};

export const getReadAccountEventsPageEventsFilterNextGetQueryKey = (
	params: ReadAccountEventsPageEventsFilterNextGetParams,
) => {
	return [
		`http://prefect.grose.click/api/events/filter/next`,
		...(params ? [params] : []),
	] as const;
};

export const getReadAccountEventsPageEventsFilterNextGetQueryOptions = <
	TData = Awaited<ReturnType<typeof readAccountEventsPageEventsFilterNextGet>>,
	TError = HTTPValidationError,
>(
	params: ReadAccountEventsPageEventsFilterNextGetParams,
	options?: {
		query?: Partial<
			UseQueryOptions<
				Awaited<ReturnType<typeof readAccountEventsPageEventsFilterNextGet>>,
				TError,
				TData
			>
		>;
		fetch?: RequestInit;
	},
) => {
	const { query: queryOptions, fetch: fetchOptions } = options ?? {};

	const queryKey =
		queryOptions?.queryKey ??
		getReadAccountEventsPageEventsFilterNextGetQueryKey(params);

	const queryFn: QueryFunction<
		Awaited<ReturnType<typeof readAccountEventsPageEventsFilterNextGet>>
	> = ({ signal }) =>
		readAccountEventsPageEventsFilterNextGet(params, {
			signal,
			...fetchOptions,
		});

	return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
		Awaited<ReturnType<typeof readAccountEventsPageEventsFilterNextGet>>,
		TError,
		TData
	> & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type ReadAccountEventsPageEventsFilterNextGetQueryResult = NonNullable<
	Awaited<ReturnType<typeof readAccountEventsPageEventsFilterNextGet>>
>;
export type ReadAccountEventsPageEventsFilterNextGetQueryError =
	HTTPValidationError;

export function useReadAccountEventsPageEventsFilterNextGet<
	TData = Awaited<ReturnType<typeof readAccountEventsPageEventsFilterNextGet>>,
	TError = HTTPValidationError,
>(
	params: ReadAccountEventsPageEventsFilterNextGetParams,
	options: {
		query: Partial<
			UseQueryOptions<
				Awaited<ReturnType<typeof readAccountEventsPageEventsFilterNextGet>>,
				TError,
				TData
			>
		> &
			Pick<
				DefinedInitialDataOptions<
					Awaited<ReturnType<typeof readAccountEventsPageEventsFilterNextGet>>,
					TError,
					Awaited<ReturnType<typeof readAccountEventsPageEventsFilterNextGet>>
				>,
				"initialData"
			>;
		fetch?: RequestInit;
	},
): DefinedUseQueryResult<TData, TError> & {
	queryKey: DataTag<QueryKey, TData, TError>;
};
export function useReadAccountEventsPageEventsFilterNextGet<
	TData = Awaited<ReturnType<typeof readAccountEventsPageEventsFilterNextGet>>,
	TError = HTTPValidationError,
>(
	params: ReadAccountEventsPageEventsFilterNextGetParams,
	options?: {
		query?: Partial<
			UseQueryOptions<
				Awaited<ReturnType<typeof readAccountEventsPageEventsFilterNextGet>>,
				TError,
				TData
			>
		> &
			Pick<
				UndefinedInitialDataOptions<
					Awaited<ReturnType<typeof readAccountEventsPageEventsFilterNextGet>>,
					TError,
					Awaited<ReturnType<typeof readAccountEventsPageEventsFilterNextGet>>
				>,
				"initialData"
			>;
		fetch?: RequestInit;
	},
): UseQueryResult<TData, TError> & {
	queryKey: DataTag<QueryKey, TData, TError>;
};
export function useReadAccountEventsPageEventsFilterNextGet<
	TData = Awaited<ReturnType<typeof readAccountEventsPageEventsFilterNextGet>>,
	TError = HTTPValidationError,
>(
	params: ReadAccountEventsPageEventsFilterNextGetParams,
	options?: {
		query?: Partial<
			UseQueryOptions<
				Awaited<ReturnType<typeof readAccountEventsPageEventsFilterNextGet>>,
				TError,
				TData
			>
		>;
		fetch?: RequestInit;
	},
): UseQueryResult<TData, TError> & {
	queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Read Account Events Page
 */

export function useReadAccountEventsPageEventsFilterNextGet<
	TData = Awaited<ReturnType<typeof readAccountEventsPageEventsFilterNextGet>>,
	TError = HTTPValidationError,
>(
	params: ReadAccountEventsPageEventsFilterNextGetParams,
	options?: {
		query?: Partial<
			UseQueryOptions<
				Awaited<ReturnType<typeof readAccountEventsPageEventsFilterNextGet>>,
				TError,
				TData
			>
		>;
		fetch?: RequestInit;
	},
): UseQueryResult<TData, TError> & {
	queryKey: DataTag<QueryKey, TData, TError>;
} {
	const queryOptions = getReadAccountEventsPageEventsFilterNextGetQueryOptions(
		params,
		options,
	);

	const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
		queryKey: DataTag<QueryKey, TData, TError>;
	};

	query.queryKey = queryOptions.queryKey;

	return query;
}

export const getReadAccountEventsPageEventsFilterNextGetSuspenseQueryOptions = <
	TData = Awaited<ReturnType<typeof readAccountEventsPageEventsFilterNextGet>>,
	TError = HTTPValidationError,
>(
	params: ReadAccountEventsPageEventsFilterNextGetParams,
	options?: {
		query?: Partial<
			UseSuspenseQueryOptions<
				Awaited<ReturnType<typeof readAccountEventsPageEventsFilterNextGet>>,
				TError,
				TData
			>
		>;
		fetch?: RequestInit;
	},
) => {
	const { query: queryOptions, fetch: fetchOptions } = options ?? {};

	const queryKey =
		queryOptions?.queryKey ??
		getReadAccountEventsPageEventsFilterNextGetQueryKey(params);

	const queryFn: QueryFunction<
		Awaited<ReturnType<typeof readAccountEventsPageEventsFilterNextGet>>
	> = ({ signal }) =>
		readAccountEventsPageEventsFilterNextGet(params, {
			signal,
			...fetchOptions,
		});

	return { queryKey, queryFn, ...queryOptions } as UseSuspenseQueryOptions<
		Awaited<ReturnType<typeof readAccountEventsPageEventsFilterNextGet>>,
		TError,
		TData
	> & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type ReadAccountEventsPageEventsFilterNextGetSuspenseQueryResult =
	NonNullable<
		Awaited<ReturnType<typeof readAccountEventsPageEventsFilterNextGet>>
	>;
export type ReadAccountEventsPageEventsFilterNextGetSuspenseQueryError =
	HTTPValidationError;

export function useReadAccountEventsPageEventsFilterNextGetSuspense<
	TData = Awaited<ReturnType<typeof readAccountEventsPageEventsFilterNextGet>>,
	TError = HTTPValidationError,
>(
	params: ReadAccountEventsPageEventsFilterNextGetParams,
	options: {
		query: Partial<
			UseSuspenseQueryOptions<
				Awaited<ReturnType<typeof readAccountEventsPageEventsFilterNextGet>>,
				TError,
				TData
			>
		>;
		fetch?: RequestInit;
	},
): UseSuspenseQueryResult<TData, TError> & {
	queryKey: DataTag<QueryKey, TData, TError>;
};
export function useReadAccountEventsPageEventsFilterNextGetSuspense<
	TData = Awaited<ReturnType<typeof readAccountEventsPageEventsFilterNextGet>>,
	TError = HTTPValidationError,
>(
	params: ReadAccountEventsPageEventsFilterNextGetParams,
	options?: {
		query?: Partial<
			UseSuspenseQueryOptions<
				Awaited<ReturnType<typeof readAccountEventsPageEventsFilterNextGet>>,
				TError,
				TData
			>
		>;
		fetch?: RequestInit;
	},
): UseSuspenseQueryResult<TData, TError> & {
	queryKey: DataTag<QueryKey, TData, TError>;
};
export function useReadAccountEventsPageEventsFilterNextGetSuspense<
	TData = Awaited<ReturnType<typeof readAccountEventsPageEventsFilterNextGet>>,
	TError = HTTPValidationError,
>(
	params: ReadAccountEventsPageEventsFilterNextGetParams,
	options?: {
		query?: Partial<
			UseSuspenseQueryOptions<
				Awaited<ReturnType<typeof readAccountEventsPageEventsFilterNextGet>>,
				TError,
				TData
			>
		>;
		fetch?: RequestInit;
	},
): UseSuspenseQueryResult<TData, TError> & {
	queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Read Account Events Page
 */

export function useReadAccountEventsPageEventsFilterNextGetSuspense<
	TData = Awaited<ReturnType<typeof readAccountEventsPageEventsFilterNextGet>>,
	TError = HTTPValidationError,
>(
	params: ReadAccountEventsPageEventsFilterNextGetParams,
	options?: {
		query?: Partial<
			UseSuspenseQueryOptions<
				Awaited<ReturnType<typeof readAccountEventsPageEventsFilterNextGet>>,
				TError,
				TData
			>
		>;
		fetch?: RequestInit;
	},
): UseSuspenseQueryResult<TData, TError> & {
	queryKey: DataTag<QueryKey, TData, TError>;
} {
	const queryOptions =
		getReadAccountEventsPageEventsFilterNextGetSuspenseQueryOptions(
			params,
			options,
		);

	const query = useSuspenseQuery(queryOptions) as UseSuspenseQueryResult<
		TData,
		TError
	> & { queryKey: DataTag<QueryKey, TData, TError> };

	query.queryKey = queryOptions.queryKey;

	return query;
}

/**
 * Returns distinct objects and the count of events associated with them.  Objects
that can be counted include the day the event occurred, the type of event, or
the IDs of the resources associated with the event.
 * @summary Count Account Events
 */
export type countAccountEventsEventsCountByCountablePostResponse = {
	data: EventCount[] | HTTPValidationError;
	status: number;
	headers: Headers;
};

export const getCountAccountEventsEventsCountByCountablePostUrl = (
	countable: Countable,
) => {
	return `http://prefect.grose.click/api/events/count-by/${countable}`;
};

export const countAccountEventsEventsCountByCountablePost = async (
	countable: Countable,
	bodyCountAccountEventsEventsCountByCountablePost: BodyCountAccountEventsEventsCountByCountablePost,
	options?: RequestInit,
): Promise<countAccountEventsEventsCountByCountablePostResponse> => {
	const res = await fetch(
		getCountAccountEventsEventsCountByCountablePostUrl(countable),
		{
			...options,
			method: "POST",
			headers: { "Content-Type": "application/json", ...options?.headers },
			body: JSON.stringify(bodyCountAccountEventsEventsCountByCountablePost),
		},
	);

	const body = [204, 205, 304].includes(res.status) ? null : await res.text();
	const data: countAccountEventsEventsCountByCountablePostResponse["data"] =
		body ? JSON.parse(body) : {};

	return {
		data,
		status: res.status,
		headers: res.headers,
	} as countAccountEventsEventsCountByCountablePostResponse;
};

export const getCountAccountEventsEventsCountByCountablePostMutationOptions = <
	TError = HTTPValidationError,
	TContext = unknown,
>(options?: {
	mutation?: UseMutationOptions<
		Awaited<ReturnType<typeof countAccountEventsEventsCountByCountablePost>>,
		TError,
		{
			countable: Countable;
			data: BodyCountAccountEventsEventsCountByCountablePost;
		},
		TContext
	>;
	fetch?: RequestInit;
}): UseMutationOptions<
	Awaited<ReturnType<typeof countAccountEventsEventsCountByCountablePost>>,
	TError,
	{
		countable: Countable;
		data: BodyCountAccountEventsEventsCountByCountablePost;
	},
	TContext
> => {
	const mutationKey = ["countAccountEventsEventsCountByCountablePost"];
	const { mutation: mutationOptions, fetch: fetchOptions } = options
		? options.mutation &&
			"mutationKey" in options.mutation &&
			options.mutation.mutationKey
			? options
			: { ...options, mutation: { ...options.mutation, mutationKey } }
		: { mutation: { mutationKey }, fetch: undefined };

	const mutationFn: MutationFunction<
		Awaited<ReturnType<typeof countAccountEventsEventsCountByCountablePost>>,
		{
			countable: Countable;
			data: BodyCountAccountEventsEventsCountByCountablePost;
		}
	> = (props) => {
		const { countable, data } = props ?? {};

		return countAccountEventsEventsCountByCountablePost(
			countable,
			data,
			fetchOptions,
		);
	};

	return { mutationFn, ...mutationOptions };
};

export type CountAccountEventsEventsCountByCountablePostMutationResult =
	NonNullable<
		Awaited<ReturnType<typeof countAccountEventsEventsCountByCountablePost>>
	>;
export type CountAccountEventsEventsCountByCountablePostMutationBody =
	BodyCountAccountEventsEventsCountByCountablePost;
export type CountAccountEventsEventsCountByCountablePostMutationError =
	HTTPValidationError;

/**
 * @summary Count Account Events
 */
export const useCountAccountEventsEventsCountByCountablePost = <
	TError = HTTPValidationError,
	TContext = unknown,
>(options?: {
	mutation?: UseMutationOptions<
		Awaited<ReturnType<typeof countAccountEventsEventsCountByCountablePost>>,
		TError,
		{
			countable: Countable;
			data: BodyCountAccountEventsEventsCountByCountablePost;
		},
		TContext
	>;
	fetch?: RequestInit;
}): UseMutationResult<
	Awaited<ReturnType<typeof countAccountEventsEventsCountByCountablePost>>,
	TError,
	{
		countable: Countable;
		data: BodyCountAccountEventsEventsCountByCountablePost;
	},
	TContext
> => {
	const mutationOptions =
		getCountAccountEventsEventsCountByCountablePostMutationOptions(options);

	return useMutation(mutationOptions);
};
