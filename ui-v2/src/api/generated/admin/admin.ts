/**
 * Generated by orval v7.5.0 🍺
 * Do not edit manually.
 * Prefect Prefect REST API
 * OpenAPI spec version: 0.1.0
 */
import { useMutation, useQuery, useSuspenseQuery } from "@tanstack/react-query";
import type {
	DataTag,
	DefinedInitialDataOptions,
	DefinedUseQueryResult,
	MutationFunction,
	QueryFunction,
	QueryKey,
	UndefinedInitialDataOptions,
	UseMutationOptions,
	UseMutationResult,
	UseQueryOptions,
	UseQueryResult,
	UseSuspenseQueryOptions,
	UseSuspenseQueryResult,
} from "@tanstack/react-query";
import type {
	BodyClearDatabaseAdminDatabaseClearPost,
	BodyCreateDatabaseAdminDatabaseCreatePost,
	BodyDropDatabaseAdminDatabaseDropPost,
	HTTPValidationError,
	Settings,
} from "../../models";

/**
 * Get the current Prefect REST API settings.

Secret setting values will be obfuscated.
 * @summary Read Settings
 */
export type readSettingsAdminSettingsGetResponse = {
	data: Settings | HTTPValidationError;
	status: number;
	headers: Headers;
};

export const getReadSettingsAdminSettingsGetUrl = () => {
	return `http://prefect.grose.click/api/admin/settings`;
};

export const readSettingsAdminSettingsGet = async (
	options?: RequestInit,
): Promise<readSettingsAdminSettingsGetResponse> => {
	const res = await fetch(getReadSettingsAdminSettingsGetUrl(), {
		...options,
		method: "GET",
	});

	const body = [204, 205, 304].includes(res.status) ? null : await res.text();
	const data: readSettingsAdminSettingsGetResponse["data"] = body
		? JSON.parse(body)
		: {};

	return {
		data,
		status: res.status,
		headers: res.headers,
	} as readSettingsAdminSettingsGetResponse;
};

export const getReadSettingsAdminSettingsGetQueryKey = () => {
	return [`http://prefect.grose.click/api/admin/settings`] as const;
};

export const getReadSettingsAdminSettingsGetQueryOptions = <
	TData = Awaited<ReturnType<typeof readSettingsAdminSettingsGet>>,
	TError = HTTPValidationError,
>(options?: {
	query?: Partial<
		UseQueryOptions<
			Awaited<ReturnType<typeof readSettingsAdminSettingsGet>>,
			TError,
			TData
		>
	>;
	fetch?: RequestInit;
}) => {
	const { query: queryOptions, fetch: fetchOptions } = options ?? {};

	const queryKey =
		queryOptions?.queryKey ?? getReadSettingsAdminSettingsGetQueryKey();

	const queryFn: QueryFunction<
		Awaited<ReturnType<typeof readSettingsAdminSettingsGet>>
	> = ({ signal }) => readSettingsAdminSettingsGet({ signal, ...fetchOptions });

	return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
		Awaited<ReturnType<typeof readSettingsAdminSettingsGet>>,
		TError,
		TData
	> & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type ReadSettingsAdminSettingsGetQueryResult = NonNullable<
	Awaited<ReturnType<typeof readSettingsAdminSettingsGet>>
>;
export type ReadSettingsAdminSettingsGetQueryError = HTTPValidationError;

export function useReadSettingsAdminSettingsGet<
	TData = Awaited<ReturnType<typeof readSettingsAdminSettingsGet>>,
	TError = HTTPValidationError,
>(options: {
	query: Partial<
		UseQueryOptions<
			Awaited<ReturnType<typeof readSettingsAdminSettingsGet>>,
			TError,
			TData
		>
	> &
		Pick<
			DefinedInitialDataOptions<
				Awaited<ReturnType<typeof readSettingsAdminSettingsGet>>,
				TError,
				Awaited<ReturnType<typeof readSettingsAdminSettingsGet>>
			>,
			"initialData"
		>;
	fetch?: RequestInit;
}): DefinedUseQueryResult<TData, TError> & {
	queryKey: DataTag<QueryKey, TData, TError>;
};
export function useReadSettingsAdminSettingsGet<
	TData = Awaited<ReturnType<typeof readSettingsAdminSettingsGet>>,
	TError = HTTPValidationError,
>(options?: {
	query?: Partial<
		UseQueryOptions<
			Awaited<ReturnType<typeof readSettingsAdminSettingsGet>>,
			TError,
			TData
		>
	> &
		Pick<
			UndefinedInitialDataOptions<
				Awaited<ReturnType<typeof readSettingsAdminSettingsGet>>,
				TError,
				Awaited<ReturnType<typeof readSettingsAdminSettingsGet>>
			>,
			"initialData"
		>;
	fetch?: RequestInit;
}): UseQueryResult<TData, TError> & {
	queryKey: DataTag<QueryKey, TData, TError>;
};
export function useReadSettingsAdminSettingsGet<
	TData = Awaited<ReturnType<typeof readSettingsAdminSettingsGet>>,
	TError = HTTPValidationError,
>(options?: {
	query?: Partial<
		UseQueryOptions<
			Awaited<ReturnType<typeof readSettingsAdminSettingsGet>>,
			TError,
			TData
		>
	>;
	fetch?: RequestInit;
}): UseQueryResult<TData, TError> & {
	queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Read Settings
 */

export function useReadSettingsAdminSettingsGet<
	TData = Awaited<ReturnType<typeof readSettingsAdminSettingsGet>>,
	TError = HTTPValidationError,
>(options?: {
	query?: Partial<
		UseQueryOptions<
			Awaited<ReturnType<typeof readSettingsAdminSettingsGet>>,
			TError,
			TData
		>
	>;
	fetch?: RequestInit;
}): UseQueryResult<TData, TError> & {
	queryKey: DataTag<QueryKey, TData, TError>;
} {
	const queryOptions = getReadSettingsAdminSettingsGetQueryOptions(options);

	const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
		queryKey: DataTag<QueryKey, TData, TError>;
	};

	query.queryKey = queryOptions.queryKey;

	return query;
}

export const getReadSettingsAdminSettingsGetSuspenseQueryOptions = <
	TData = Awaited<ReturnType<typeof readSettingsAdminSettingsGet>>,
	TError = HTTPValidationError,
>(options?: {
	query?: Partial<
		UseSuspenseQueryOptions<
			Awaited<ReturnType<typeof readSettingsAdminSettingsGet>>,
			TError,
			TData
		>
	>;
	fetch?: RequestInit;
}) => {
	const { query: queryOptions, fetch: fetchOptions } = options ?? {};

	const queryKey =
		queryOptions?.queryKey ?? getReadSettingsAdminSettingsGetQueryKey();

	const queryFn: QueryFunction<
		Awaited<ReturnType<typeof readSettingsAdminSettingsGet>>
	> = ({ signal }) => readSettingsAdminSettingsGet({ signal, ...fetchOptions });

	return { queryKey, queryFn, ...queryOptions } as UseSuspenseQueryOptions<
		Awaited<ReturnType<typeof readSettingsAdminSettingsGet>>,
		TError,
		TData
	> & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type ReadSettingsAdminSettingsGetSuspenseQueryResult = NonNullable<
	Awaited<ReturnType<typeof readSettingsAdminSettingsGet>>
>;
export type ReadSettingsAdminSettingsGetSuspenseQueryError =
	HTTPValidationError;

export function useReadSettingsAdminSettingsGetSuspense<
	TData = Awaited<ReturnType<typeof readSettingsAdminSettingsGet>>,
	TError = HTTPValidationError,
>(options: {
	query: Partial<
		UseSuspenseQueryOptions<
			Awaited<ReturnType<typeof readSettingsAdminSettingsGet>>,
			TError,
			TData
		>
	>;
	fetch?: RequestInit;
}): UseSuspenseQueryResult<TData, TError> & {
	queryKey: DataTag<QueryKey, TData, TError>;
};
export function useReadSettingsAdminSettingsGetSuspense<
	TData = Awaited<ReturnType<typeof readSettingsAdminSettingsGet>>,
	TError = HTTPValidationError,
>(options?: {
	query?: Partial<
		UseSuspenseQueryOptions<
			Awaited<ReturnType<typeof readSettingsAdminSettingsGet>>,
			TError,
			TData
		>
	>;
	fetch?: RequestInit;
}): UseSuspenseQueryResult<TData, TError> & {
	queryKey: DataTag<QueryKey, TData, TError>;
};
export function useReadSettingsAdminSettingsGetSuspense<
	TData = Awaited<ReturnType<typeof readSettingsAdminSettingsGet>>,
	TError = HTTPValidationError,
>(options?: {
	query?: Partial<
		UseSuspenseQueryOptions<
			Awaited<ReturnType<typeof readSettingsAdminSettingsGet>>,
			TError,
			TData
		>
	>;
	fetch?: RequestInit;
}): UseSuspenseQueryResult<TData, TError> & {
	queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Read Settings
 */

export function useReadSettingsAdminSettingsGetSuspense<
	TData = Awaited<ReturnType<typeof readSettingsAdminSettingsGet>>,
	TError = HTTPValidationError,
>(options?: {
	query?: Partial<
		UseSuspenseQueryOptions<
			Awaited<ReturnType<typeof readSettingsAdminSettingsGet>>,
			TError,
			TData
		>
	>;
	fetch?: RequestInit;
}): UseSuspenseQueryResult<TData, TError> & {
	queryKey: DataTag<QueryKey, TData, TError>;
} {
	const queryOptions =
		getReadSettingsAdminSettingsGetSuspenseQueryOptions(options);

	const query = useSuspenseQuery(queryOptions) as UseSuspenseQueryResult<
		TData,
		TError
	> & { queryKey: DataTag<QueryKey, TData, TError> };

	query.queryKey = queryOptions.queryKey;

	return query;
}

/**
 * Returns the Prefect version number
 * @summary Read Version
 */
export type readVersionAdminVersionGetResponse = {
	data: string | HTTPValidationError;
	status: number;
	headers: Headers;
};

export const getReadVersionAdminVersionGetUrl = () => {
	return `http://prefect.grose.click/api/admin/version`;
};

export const readVersionAdminVersionGet = async (
	options?: RequestInit,
): Promise<readVersionAdminVersionGetResponse> => {
	const res = await fetch(getReadVersionAdminVersionGetUrl(), {
		...options,
		method: "GET",
	});

	const body = [204, 205, 304].includes(res.status) ? null : await res.text();
	const data: readVersionAdminVersionGetResponse["data"] = body
		? JSON.parse(body)
		: {};

	return {
		data,
		status: res.status,
		headers: res.headers,
	} as readVersionAdminVersionGetResponse;
};

export const getReadVersionAdminVersionGetQueryKey = () => {
	return [`http://prefect.grose.click/api/admin/version`] as const;
};

export const getReadVersionAdminVersionGetQueryOptions = <
	TData = Awaited<ReturnType<typeof readVersionAdminVersionGet>>,
	TError = HTTPValidationError,
>(options?: {
	query?: Partial<
		UseQueryOptions<
			Awaited<ReturnType<typeof readVersionAdminVersionGet>>,
			TError,
			TData
		>
	>;
	fetch?: RequestInit;
}) => {
	const { query: queryOptions, fetch: fetchOptions } = options ?? {};

	const queryKey =
		queryOptions?.queryKey ?? getReadVersionAdminVersionGetQueryKey();

	const queryFn: QueryFunction<
		Awaited<ReturnType<typeof readVersionAdminVersionGet>>
	> = ({ signal }) => readVersionAdminVersionGet({ signal, ...fetchOptions });

	return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
		Awaited<ReturnType<typeof readVersionAdminVersionGet>>,
		TError,
		TData
	> & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type ReadVersionAdminVersionGetQueryResult = NonNullable<
	Awaited<ReturnType<typeof readVersionAdminVersionGet>>
>;
export type ReadVersionAdminVersionGetQueryError = HTTPValidationError;

export function useReadVersionAdminVersionGet<
	TData = Awaited<ReturnType<typeof readVersionAdminVersionGet>>,
	TError = HTTPValidationError,
>(options: {
	query: Partial<
		UseQueryOptions<
			Awaited<ReturnType<typeof readVersionAdminVersionGet>>,
			TError,
			TData
		>
	> &
		Pick<
			DefinedInitialDataOptions<
				Awaited<ReturnType<typeof readVersionAdminVersionGet>>,
				TError,
				Awaited<ReturnType<typeof readVersionAdminVersionGet>>
			>,
			"initialData"
		>;
	fetch?: RequestInit;
}): DefinedUseQueryResult<TData, TError> & {
	queryKey: DataTag<QueryKey, TData, TError>;
};
export function useReadVersionAdminVersionGet<
	TData = Awaited<ReturnType<typeof readVersionAdminVersionGet>>,
	TError = HTTPValidationError,
>(options?: {
	query?: Partial<
		UseQueryOptions<
			Awaited<ReturnType<typeof readVersionAdminVersionGet>>,
			TError,
			TData
		>
	> &
		Pick<
			UndefinedInitialDataOptions<
				Awaited<ReturnType<typeof readVersionAdminVersionGet>>,
				TError,
				Awaited<ReturnType<typeof readVersionAdminVersionGet>>
			>,
			"initialData"
		>;
	fetch?: RequestInit;
}): UseQueryResult<TData, TError> & {
	queryKey: DataTag<QueryKey, TData, TError>;
};
export function useReadVersionAdminVersionGet<
	TData = Awaited<ReturnType<typeof readVersionAdminVersionGet>>,
	TError = HTTPValidationError,
>(options?: {
	query?: Partial<
		UseQueryOptions<
			Awaited<ReturnType<typeof readVersionAdminVersionGet>>,
			TError,
			TData
		>
	>;
	fetch?: RequestInit;
}): UseQueryResult<TData, TError> & {
	queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Read Version
 */

export function useReadVersionAdminVersionGet<
	TData = Awaited<ReturnType<typeof readVersionAdminVersionGet>>,
	TError = HTTPValidationError,
>(options?: {
	query?: Partial<
		UseQueryOptions<
			Awaited<ReturnType<typeof readVersionAdminVersionGet>>,
			TError,
			TData
		>
	>;
	fetch?: RequestInit;
}): UseQueryResult<TData, TError> & {
	queryKey: DataTag<QueryKey, TData, TError>;
} {
	const queryOptions = getReadVersionAdminVersionGetQueryOptions(options);

	const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
		queryKey: DataTag<QueryKey, TData, TError>;
	};

	query.queryKey = queryOptions.queryKey;

	return query;
}

export const getReadVersionAdminVersionGetSuspenseQueryOptions = <
	TData = Awaited<ReturnType<typeof readVersionAdminVersionGet>>,
	TError = HTTPValidationError,
>(options?: {
	query?: Partial<
		UseSuspenseQueryOptions<
			Awaited<ReturnType<typeof readVersionAdminVersionGet>>,
			TError,
			TData
		>
	>;
	fetch?: RequestInit;
}) => {
	const { query: queryOptions, fetch: fetchOptions } = options ?? {};

	const queryKey =
		queryOptions?.queryKey ?? getReadVersionAdminVersionGetQueryKey();

	const queryFn: QueryFunction<
		Awaited<ReturnType<typeof readVersionAdminVersionGet>>
	> = ({ signal }) => readVersionAdminVersionGet({ signal, ...fetchOptions });

	return { queryKey, queryFn, ...queryOptions } as UseSuspenseQueryOptions<
		Awaited<ReturnType<typeof readVersionAdminVersionGet>>,
		TError,
		TData
	> & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type ReadVersionAdminVersionGetSuspenseQueryResult = NonNullable<
	Awaited<ReturnType<typeof readVersionAdminVersionGet>>
>;
export type ReadVersionAdminVersionGetSuspenseQueryError = HTTPValidationError;

export function useReadVersionAdminVersionGetSuspense<
	TData = Awaited<ReturnType<typeof readVersionAdminVersionGet>>,
	TError = HTTPValidationError,
>(options: {
	query: Partial<
		UseSuspenseQueryOptions<
			Awaited<ReturnType<typeof readVersionAdminVersionGet>>,
			TError,
			TData
		>
	>;
	fetch?: RequestInit;
}): UseSuspenseQueryResult<TData, TError> & {
	queryKey: DataTag<QueryKey, TData, TError>;
};
export function useReadVersionAdminVersionGetSuspense<
	TData = Awaited<ReturnType<typeof readVersionAdminVersionGet>>,
	TError = HTTPValidationError,
>(options?: {
	query?: Partial<
		UseSuspenseQueryOptions<
			Awaited<ReturnType<typeof readVersionAdminVersionGet>>,
			TError,
			TData
		>
	>;
	fetch?: RequestInit;
}): UseSuspenseQueryResult<TData, TError> & {
	queryKey: DataTag<QueryKey, TData, TError>;
};
export function useReadVersionAdminVersionGetSuspense<
	TData = Awaited<ReturnType<typeof readVersionAdminVersionGet>>,
	TError = HTTPValidationError,
>(options?: {
	query?: Partial<
		UseSuspenseQueryOptions<
			Awaited<ReturnType<typeof readVersionAdminVersionGet>>,
			TError,
			TData
		>
	>;
	fetch?: RequestInit;
}): UseSuspenseQueryResult<TData, TError> & {
	queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Read Version
 */

export function useReadVersionAdminVersionGetSuspense<
	TData = Awaited<ReturnType<typeof readVersionAdminVersionGet>>,
	TError = HTTPValidationError,
>(options?: {
	query?: Partial<
		UseSuspenseQueryOptions<
			Awaited<ReturnType<typeof readVersionAdminVersionGet>>,
			TError,
			TData
		>
	>;
	fetch?: RequestInit;
}): UseSuspenseQueryResult<TData, TError> & {
	queryKey: DataTag<QueryKey, TData, TError>;
} {
	const queryOptions =
		getReadVersionAdminVersionGetSuspenseQueryOptions(options);

	const query = useSuspenseQuery(queryOptions) as UseSuspenseQueryResult<
		TData,
		TError
	> & { queryKey: DataTag<QueryKey, TData, TError> };

	query.queryKey = queryOptions.queryKey;

	return query;
}

/**
 * Clear all database tables without dropping them.
 * @summary Clear Database
 */
export type clearDatabaseAdminDatabaseClearPostResponse = {
	data: void | HTTPValidationError;
	status: number;
	headers: Headers;
};

export const getClearDatabaseAdminDatabaseClearPostUrl = () => {
	return `http://prefect.grose.click/api/admin/database/clear`;
};

export const clearDatabaseAdminDatabaseClearPost = async (
	bodyClearDatabaseAdminDatabaseClearPost: BodyClearDatabaseAdminDatabaseClearPost,
	options?: RequestInit,
): Promise<clearDatabaseAdminDatabaseClearPostResponse> => {
	const res = await fetch(getClearDatabaseAdminDatabaseClearPostUrl(), {
		...options,
		method: "POST",
		headers: { "Content-Type": "application/json", ...options?.headers },
		body: JSON.stringify(bodyClearDatabaseAdminDatabaseClearPost),
	});

	const body = [204, 205, 304].includes(res.status) ? null : await res.text();
	const data: clearDatabaseAdminDatabaseClearPostResponse["data"] = body
		? JSON.parse(body)
		: {};

	return {
		data,
		status: res.status,
		headers: res.headers,
	} as clearDatabaseAdminDatabaseClearPostResponse;
};

export const getClearDatabaseAdminDatabaseClearPostMutationOptions = <
	TError = HTTPValidationError,
	TContext = unknown,
>(options?: {
	mutation?: UseMutationOptions<
		Awaited<ReturnType<typeof clearDatabaseAdminDatabaseClearPost>>,
		TError,
		{ data: BodyClearDatabaseAdminDatabaseClearPost },
		TContext
	>;
	fetch?: RequestInit;
}): UseMutationOptions<
	Awaited<ReturnType<typeof clearDatabaseAdminDatabaseClearPost>>,
	TError,
	{ data: BodyClearDatabaseAdminDatabaseClearPost },
	TContext
> => {
	const mutationKey = ["clearDatabaseAdminDatabaseClearPost"];
	const { mutation: mutationOptions, fetch: fetchOptions } = options
		? options.mutation &&
			"mutationKey" in options.mutation &&
			options.mutation.mutationKey
			? options
			: { ...options, mutation: { ...options.mutation, mutationKey } }
		: { mutation: { mutationKey }, fetch: undefined };

	const mutationFn: MutationFunction<
		Awaited<ReturnType<typeof clearDatabaseAdminDatabaseClearPost>>,
		{ data: BodyClearDatabaseAdminDatabaseClearPost }
	> = (props) => {
		const { data } = props ?? {};

		return clearDatabaseAdminDatabaseClearPost(data, fetchOptions);
	};

	return { mutationFn, ...mutationOptions };
};

export type ClearDatabaseAdminDatabaseClearPostMutationResult = NonNullable<
	Awaited<ReturnType<typeof clearDatabaseAdminDatabaseClearPost>>
>;
export type ClearDatabaseAdminDatabaseClearPostMutationBody =
	BodyClearDatabaseAdminDatabaseClearPost;
export type ClearDatabaseAdminDatabaseClearPostMutationError =
	HTTPValidationError;

/**
 * @summary Clear Database
 */
export const useClearDatabaseAdminDatabaseClearPost = <
	TError = HTTPValidationError,
	TContext = unknown,
>(options?: {
	mutation?: UseMutationOptions<
		Awaited<ReturnType<typeof clearDatabaseAdminDatabaseClearPost>>,
		TError,
		{ data: BodyClearDatabaseAdminDatabaseClearPost },
		TContext
	>;
	fetch?: RequestInit;
}): UseMutationResult<
	Awaited<ReturnType<typeof clearDatabaseAdminDatabaseClearPost>>,
	TError,
	{ data: BodyClearDatabaseAdminDatabaseClearPost },
	TContext
> => {
	const mutationOptions =
		getClearDatabaseAdminDatabaseClearPostMutationOptions(options);

	return useMutation(mutationOptions);
};
/**
 * Drop all database objects.
 * @summary Drop Database
 */
export type dropDatabaseAdminDatabaseDropPostResponse = {
	data: void | HTTPValidationError;
	status: number;
	headers: Headers;
};

export const getDropDatabaseAdminDatabaseDropPostUrl = () => {
	return `http://prefect.grose.click/api/admin/database/drop`;
};

export const dropDatabaseAdminDatabaseDropPost = async (
	bodyDropDatabaseAdminDatabaseDropPost: BodyDropDatabaseAdminDatabaseDropPost,
	options?: RequestInit,
): Promise<dropDatabaseAdminDatabaseDropPostResponse> => {
	const res = await fetch(getDropDatabaseAdminDatabaseDropPostUrl(), {
		...options,
		method: "POST",
		headers: { "Content-Type": "application/json", ...options?.headers },
		body: JSON.stringify(bodyDropDatabaseAdminDatabaseDropPost),
	});

	const body = [204, 205, 304].includes(res.status) ? null : await res.text();
	const data: dropDatabaseAdminDatabaseDropPostResponse["data"] = body
		? JSON.parse(body)
		: {};

	return {
		data,
		status: res.status,
		headers: res.headers,
	} as dropDatabaseAdminDatabaseDropPostResponse;
};

export const getDropDatabaseAdminDatabaseDropPostMutationOptions = <
	TError = HTTPValidationError,
	TContext = unknown,
>(options?: {
	mutation?: UseMutationOptions<
		Awaited<ReturnType<typeof dropDatabaseAdminDatabaseDropPost>>,
		TError,
		{ data: BodyDropDatabaseAdminDatabaseDropPost },
		TContext
	>;
	fetch?: RequestInit;
}): UseMutationOptions<
	Awaited<ReturnType<typeof dropDatabaseAdminDatabaseDropPost>>,
	TError,
	{ data: BodyDropDatabaseAdminDatabaseDropPost },
	TContext
> => {
	const mutationKey = ["dropDatabaseAdminDatabaseDropPost"];
	const { mutation: mutationOptions, fetch: fetchOptions } = options
		? options.mutation &&
			"mutationKey" in options.mutation &&
			options.mutation.mutationKey
			? options
			: { ...options, mutation: { ...options.mutation, mutationKey } }
		: { mutation: { mutationKey }, fetch: undefined };

	const mutationFn: MutationFunction<
		Awaited<ReturnType<typeof dropDatabaseAdminDatabaseDropPost>>,
		{ data: BodyDropDatabaseAdminDatabaseDropPost }
	> = (props) => {
		const { data } = props ?? {};

		return dropDatabaseAdminDatabaseDropPost(data, fetchOptions);
	};

	return { mutationFn, ...mutationOptions };
};

export type DropDatabaseAdminDatabaseDropPostMutationResult = NonNullable<
	Awaited<ReturnType<typeof dropDatabaseAdminDatabaseDropPost>>
>;
export type DropDatabaseAdminDatabaseDropPostMutationBody =
	BodyDropDatabaseAdminDatabaseDropPost;
export type DropDatabaseAdminDatabaseDropPostMutationError =
	HTTPValidationError;

/**
 * @summary Drop Database
 */
export const useDropDatabaseAdminDatabaseDropPost = <
	TError = HTTPValidationError,
	TContext = unknown,
>(options?: {
	mutation?: UseMutationOptions<
		Awaited<ReturnType<typeof dropDatabaseAdminDatabaseDropPost>>,
		TError,
		{ data: BodyDropDatabaseAdminDatabaseDropPost },
		TContext
	>;
	fetch?: RequestInit;
}): UseMutationResult<
	Awaited<ReturnType<typeof dropDatabaseAdminDatabaseDropPost>>,
	TError,
	{ data: BodyDropDatabaseAdminDatabaseDropPost },
	TContext
> => {
	const mutationOptions =
		getDropDatabaseAdminDatabaseDropPostMutationOptions(options);

	return useMutation(mutationOptions);
};
/**
 * Create all database objects.
 * @summary Create Database
 */
export type createDatabaseAdminDatabaseCreatePostResponse = {
	data: void | HTTPValidationError;
	status: number;
	headers: Headers;
};

export const getCreateDatabaseAdminDatabaseCreatePostUrl = () => {
	return `http://prefect.grose.click/api/admin/database/create`;
};

export const createDatabaseAdminDatabaseCreatePost = async (
	bodyCreateDatabaseAdminDatabaseCreatePost: BodyCreateDatabaseAdminDatabaseCreatePost,
	options?: RequestInit,
): Promise<createDatabaseAdminDatabaseCreatePostResponse> => {
	const res = await fetch(getCreateDatabaseAdminDatabaseCreatePostUrl(), {
		...options,
		method: "POST",
		headers: { "Content-Type": "application/json", ...options?.headers },
		body: JSON.stringify(bodyCreateDatabaseAdminDatabaseCreatePost),
	});

	const body = [204, 205, 304].includes(res.status) ? null : await res.text();
	const data: createDatabaseAdminDatabaseCreatePostResponse["data"] = body
		? JSON.parse(body)
		: {};

	return {
		data,
		status: res.status,
		headers: res.headers,
	} as createDatabaseAdminDatabaseCreatePostResponse;
};

export const getCreateDatabaseAdminDatabaseCreatePostMutationOptions = <
	TError = HTTPValidationError,
	TContext = unknown,
>(options?: {
	mutation?: UseMutationOptions<
		Awaited<ReturnType<typeof createDatabaseAdminDatabaseCreatePost>>,
		TError,
		{ data: BodyCreateDatabaseAdminDatabaseCreatePost },
		TContext
	>;
	fetch?: RequestInit;
}): UseMutationOptions<
	Awaited<ReturnType<typeof createDatabaseAdminDatabaseCreatePost>>,
	TError,
	{ data: BodyCreateDatabaseAdminDatabaseCreatePost },
	TContext
> => {
	const mutationKey = ["createDatabaseAdminDatabaseCreatePost"];
	const { mutation: mutationOptions, fetch: fetchOptions } = options
		? options.mutation &&
			"mutationKey" in options.mutation &&
			options.mutation.mutationKey
			? options
			: { ...options, mutation: { ...options.mutation, mutationKey } }
		: { mutation: { mutationKey }, fetch: undefined };

	const mutationFn: MutationFunction<
		Awaited<ReturnType<typeof createDatabaseAdminDatabaseCreatePost>>,
		{ data: BodyCreateDatabaseAdminDatabaseCreatePost }
	> = (props) => {
		const { data } = props ?? {};

		return createDatabaseAdminDatabaseCreatePost(data, fetchOptions);
	};

	return { mutationFn, ...mutationOptions };
};

export type CreateDatabaseAdminDatabaseCreatePostMutationResult = NonNullable<
	Awaited<ReturnType<typeof createDatabaseAdminDatabaseCreatePost>>
>;
export type CreateDatabaseAdminDatabaseCreatePostMutationBody =
	BodyCreateDatabaseAdminDatabaseCreatePost;
export type CreateDatabaseAdminDatabaseCreatePostMutationError =
	HTTPValidationError;

/**
 * @summary Create Database
 */
export const useCreateDatabaseAdminDatabaseCreatePost = <
	TError = HTTPValidationError,
	TContext = unknown,
>(options?: {
	mutation?: UseMutationOptions<
		Awaited<ReturnType<typeof createDatabaseAdminDatabaseCreatePost>>,
		TError,
		{ data: BodyCreateDatabaseAdminDatabaseCreatePost },
		TContext
	>;
	fetch?: RequestInit;
}): UseMutationResult<
	Awaited<ReturnType<typeof createDatabaseAdminDatabaseCreatePost>>,
	TError,
	{ data: BodyCreateDatabaseAdminDatabaseCreatePost },
	TContext
> => {
	const mutationOptions =
		getCreateDatabaseAdminDatabaseCreatePostMutationOptions(options);

	return useMutation(mutationOptions);
};
