/**
 * Generated by orval v7.5.0 🍺
 * Do not edit manually.
 * Prefect Prefect REST API
 * OpenAPI spec version: 0.1.0
 */
import { useMutation, useQuery, useSuspenseQuery } from "@tanstack/react-query";
import type {
	DataTag,
	DefinedInitialDataOptions,
	DefinedUseQueryResult,
	MutationFunction,
	QueryFunction,
	QueryKey,
	UndefinedInitialDataOptions,
	UseMutationOptions,
	UseMutationResult,
	UseQueryOptions,
	UseQueryResult,
	UseSuspenseQueryOptions,
	UseSuspenseQueryResult,
} from "@tanstack/react-query";
import type {
	BlockDocument,
	BlockType,
	BlockTypeCreate,
	BlockTypeUpdate,
	BodyReadBlockTypesBlockTypesFilterPost,
	HTTPValidationError,
	ReadBlockDocumentByNameForBlockTypeBlockTypesSlugSlugBlockDocumentsNameBlockDocumentNameGetParams,
	ReadBlockDocumentsForBlockTypeBlockTypesSlugSlugBlockDocumentsGetParams,
} from "../../models";

/**
 * Create a new block type
 * @summary Create Block Type
 */
export type createBlockTypeBlockTypesPostResponse = {
	data: BlockType | HTTPValidationError;
	status: number;
	headers: Headers;
};

export const getCreateBlockTypeBlockTypesPostUrl = () => {
	return `http://prefect.grose.click/api/block_types/`;
};

export const createBlockTypeBlockTypesPost = async (
	blockTypeCreate: BlockTypeCreate,
	options?: RequestInit,
): Promise<createBlockTypeBlockTypesPostResponse> => {
	const res = await fetch(getCreateBlockTypeBlockTypesPostUrl(), {
		...options,
		method: "POST",
		headers: { "Content-Type": "application/json", ...options?.headers },
		body: JSON.stringify(blockTypeCreate),
	});

	const body = [204, 205, 304].includes(res.status) ? null : await res.text();
	const data: createBlockTypeBlockTypesPostResponse["data"] = body
		? JSON.parse(body)
		: {};

	return {
		data,
		status: res.status,
		headers: res.headers,
	} as createBlockTypeBlockTypesPostResponse;
};

export const getCreateBlockTypeBlockTypesPostMutationOptions = <
	TError = HTTPValidationError,
	TContext = unknown,
>(options?: {
	mutation?: UseMutationOptions<
		Awaited<ReturnType<typeof createBlockTypeBlockTypesPost>>,
		TError,
		{ data: BlockTypeCreate },
		TContext
	>;
	fetch?: RequestInit;
}): UseMutationOptions<
	Awaited<ReturnType<typeof createBlockTypeBlockTypesPost>>,
	TError,
	{ data: BlockTypeCreate },
	TContext
> => {
	const mutationKey = ["createBlockTypeBlockTypesPost"];
	const { mutation: mutationOptions, fetch: fetchOptions } = options
		? options.mutation &&
			"mutationKey" in options.mutation &&
			options.mutation.mutationKey
			? options
			: { ...options, mutation: { ...options.mutation, mutationKey } }
		: { mutation: { mutationKey }, fetch: undefined };

	const mutationFn: MutationFunction<
		Awaited<ReturnType<typeof createBlockTypeBlockTypesPost>>,
		{ data: BlockTypeCreate }
	> = (props) => {
		const { data } = props ?? {};

		return createBlockTypeBlockTypesPost(data, fetchOptions);
	};

	return { mutationFn, ...mutationOptions };
};

export type CreateBlockTypeBlockTypesPostMutationResult = NonNullable<
	Awaited<ReturnType<typeof createBlockTypeBlockTypesPost>>
>;
export type CreateBlockTypeBlockTypesPostMutationBody = BlockTypeCreate;
export type CreateBlockTypeBlockTypesPostMutationError = HTTPValidationError;

/**
 * @summary Create Block Type
 */
export const useCreateBlockTypeBlockTypesPost = <
	TError = HTTPValidationError,
	TContext = unknown,
>(options?: {
	mutation?: UseMutationOptions<
		Awaited<ReturnType<typeof createBlockTypeBlockTypesPost>>,
		TError,
		{ data: BlockTypeCreate },
		TContext
	>;
	fetch?: RequestInit;
}): UseMutationResult<
	Awaited<ReturnType<typeof createBlockTypeBlockTypesPost>>,
	TError,
	{ data: BlockTypeCreate },
	TContext
> => {
	const mutationOptions =
		getCreateBlockTypeBlockTypesPostMutationOptions(options);

	return useMutation(mutationOptions);
};
/**
 * Get a block type by ID.
 * @summary Read Block Type By Id
 */
export type readBlockTypeByIdBlockTypesIdGetResponse = {
	data: BlockType | HTTPValidationError;
	status: number;
	headers: Headers;
};

export const getReadBlockTypeByIdBlockTypesIdGetUrl = (id: string) => {
	return `http://prefect.grose.click/api/block_types/${id}`;
};

export const readBlockTypeByIdBlockTypesIdGet = async (
	id: string,
	options?: RequestInit,
): Promise<readBlockTypeByIdBlockTypesIdGetResponse> => {
	const res = await fetch(getReadBlockTypeByIdBlockTypesIdGetUrl(id), {
		...options,
		method: "GET",
	});

	const body = [204, 205, 304].includes(res.status) ? null : await res.text();
	const data: readBlockTypeByIdBlockTypesIdGetResponse["data"] = body
		? JSON.parse(body)
		: {};

	return {
		data,
		status: res.status,
		headers: res.headers,
	} as readBlockTypeByIdBlockTypesIdGetResponse;
};

export const getReadBlockTypeByIdBlockTypesIdGetQueryKey = (id: string) => {
	return [`http://prefect.grose.click/api/block_types/${id}`] as const;
};

export const getReadBlockTypeByIdBlockTypesIdGetQueryOptions = <
	TData = Awaited<ReturnType<typeof readBlockTypeByIdBlockTypesIdGet>>,
	TError = HTTPValidationError,
>(
	id: string,
	options?: {
		query?: Partial<
			UseQueryOptions<
				Awaited<ReturnType<typeof readBlockTypeByIdBlockTypesIdGet>>,
				TError,
				TData
			>
		>;
		fetch?: RequestInit;
	},
) => {
	const { query: queryOptions, fetch: fetchOptions } = options ?? {};

	const queryKey =
		queryOptions?.queryKey ?? getReadBlockTypeByIdBlockTypesIdGetQueryKey(id);

	const queryFn: QueryFunction<
		Awaited<ReturnType<typeof readBlockTypeByIdBlockTypesIdGet>>
	> = ({ signal }) =>
		readBlockTypeByIdBlockTypesIdGet(id, { signal, ...fetchOptions });

	return {
		queryKey,
		queryFn,
		enabled: !!id,
		...queryOptions,
	} as UseQueryOptions<
		Awaited<ReturnType<typeof readBlockTypeByIdBlockTypesIdGet>>,
		TError,
		TData
	> & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type ReadBlockTypeByIdBlockTypesIdGetQueryResult = NonNullable<
	Awaited<ReturnType<typeof readBlockTypeByIdBlockTypesIdGet>>
>;
export type ReadBlockTypeByIdBlockTypesIdGetQueryError = HTTPValidationError;

export function useReadBlockTypeByIdBlockTypesIdGet<
	TData = Awaited<ReturnType<typeof readBlockTypeByIdBlockTypesIdGet>>,
	TError = HTTPValidationError,
>(
	id: string,
	options: {
		query: Partial<
			UseQueryOptions<
				Awaited<ReturnType<typeof readBlockTypeByIdBlockTypesIdGet>>,
				TError,
				TData
			>
		> &
			Pick<
				DefinedInitialDataOptions<
					Awaited<ReturnType<typeof readBlockTypeByIdBlockTypesIdGet>>,
					TError,
					Awaited<ReturnType<typeof readBlockTypeByIdBlockTypesIdGet>>
				>,
				"initialData"
			>;
		fetch?: RequestInit;
	},
): DefinedUseQueryResult<TData, TError> & {
	queryKey: DataTag<QueryKey, TData, TError>;
};
export function useReadBlockTypeByIdBlockTypesIdGet<
	TData = Awaited<ReturnType<typeof readBlockTypeByIdBlockTypesIdGet>>,
	TError = HTTPValidationError,
>(
	id: string,
	options?: {
		query?: Partial<
			UseQueryOptions<
				Awaited<ReturnType<typeof readBlockTypeByIdBlockTypesIdGet>>,
				TError,
				TData
			>
		> &
			Pick<
				UndefinedInitialDataOptions<
					Awaited<ReturnType<typeof readBlockTypeByIdBlockTypesIdGet>>,
					TError,
					Awaited<ReturnType<typeof readBlockTypeByIdBlockTypesIdGet>>
				>,
				"initialData"
			>;
		fetch?: RequestInit;
	},
): UseQueryResult<TData, TError> & {
	queryKey: DataTag<QueryKey, TData, TError>;
};
export function useReadBlockTypeByIdBlockTypesIdGet<
	TData = Awaited<ReturnType<typeof readBlockTypeByIdBlockTypesIdGet>>,
	TError = HTTPValidationError,
>(
	id: string,
	options?: {
		query?: Partial<
			UseQueryOptions<
				Awaited<ReturnType<typeof readBlockTypeByIdBlockTypesIdGet>>,
				TError,
				TData
			>
		>;
		fetch?: RequestInit;
	},
): UseQueryResult<TData, TError> & {
	queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Read Block Type By Id
 */

export function useReadBlockTypeByIdBlockTypesIdGet<
	TData = Awaited<ReturnType<typeof readBlockTypeByIdBlockTypesIdGet>>,
	TError = HTTPValidationError,
>(
	id: string,
	options?: {
		query?: Partial<
			UseQueryOptions<
				Awaited<ReturnType<typeof readBlockTypeByIdBlockTypesIdGet>>,
				TError,
				TData
			>
		>;
		fetch?: RequestInit;
	},
): UseQueryResult<TData, TError> & {
	queryKey: DataTag<QueryKey, TData, TError>;
} {
	const queryOptions = getReadBlockTypeByIdBlockTypesIdGetQueryOptions(
		id,
		options,
	);

	const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
		queryKey: DataTag<QueryKey, TData, TError>;
	};

	query.queryKey = queryOptions.queryKey;

	return query;
}

export const getReadBlockTypeByIdBlockTypesIdGetSuspenseQueryOptions = <
	TData = Awaited<ReturnType<typeof readBlockTypeByIdBlockTypesIdGet>>,
	TError = HTTPValidationError,
>(
	id: string,
	options?: {
		query?: Partial<
			UseSuspenseQueryOptions<
				Awaited<ReturnType<typeof readBlockTypeByIdBlockTypesIdGet>>,
				TError,
				TData
			>
		>;
		fetch?: RequestInit;
	},
) => {
	const { query: queryOptions, fetch: fetchOptions } = options ?? {};

	const queryKey =
		queryOptions?.queryKey ?? getReadBlockTypeByIdBlockTypesIdGetQueryKey(id);

	const queryFn: QueryFunction<
		Awaited<ReturnType<typeof readBlockTypeByIdBlockTypesIdGet>>
	> = ({ signal }) =>
		readBlockTypeByIdBlockTypesIdGet(id, { signal, ...fetchOptions });

	return { queryKey, queryFn, ...queryOptions } as UseSuspenseQueryOptions<
		Awaited<ReturnType<typeof readBlockTypeByIdBlockTypesIdGet>>,
		TError,
		TData
	> & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type ReadBlockTypeByIdBlockTypesIdGetSuspenseQueryResult = NonNullable<
	Awaited<ReturnType<typeof readBlockTypeByIdBlockTypesIdGet>>
>;
export type ReadBlockTypeByIdBlockTypesIdGetSuspenseQueryError =
	HTTPValidationError;

export function useReadBlockTypeByIdBlockTypesIdGetSuspense<
	TData = Awaited<ReturnType<typeof readBlockTypeByIdBlockTypesIdGet>>,
	TError = HTTPValidationError,
>(
	id: string,
	options: {
		query: Partial<
			UseSuspenseQueryOptions<
				Awaited<ReturnType<typeof readBlockTypeByIdBlockTypesIdGet>>,
				TError,
				TData
			>
		>;
		fetch?: RequestInit;
	},
): UseSuspenseQueryResult<TData, TError> & {
	queryKey: DataTag<QueryKey, TData, TError>;
};
export function useReadBlockTypeByIdBlockTypesIdGetSuspense<
	TData = Awaited<ReturnType<typeof readBlockTypeByIdBlockTypesIdGet>>,
	TError = HTTPValidationError,
>(
	id: string,
	options?: {
		query?: Partial<
			UseSuspenseQueryOptions<
				Awaited<ReturnType<typeof readBlockTypeByIdBlockTypesIdGet>>,
				TError,
				TData
			>
		>;
		fetch?: RequestInit;
	},
): UseSuspenseQueryResult<TData, TError> & {
	queryKey: DataTag<QueryKey, TData, TError>;
};
export function useReadBlockTypeByIdBlockTypesIdGetSuspense<
	TData = Awaited<ReturnType<typeof readBlockTypeByIdBlockTypesIdGet>>,
	TError = HTTPValidationError,
>(
	id: string,
	options?: {
		query?: Partial<
			UseSuspenseQueryOptions<
				Awaited<ReturnType<typeof readBlockTypeByIdBlockTypesIdGet>>,
				TError,
				TData
			>
		>;
		fetch?: RequestInit;
	},
): UseSuspenseQueryResult<TData, TError> & {
	queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Read Block Type By Id
 */

export function useReadBlockTypeByIdBlockTypesIdGetSuspense<
	TData = Awaited<ReturnType<typeof readBlockTypeByIdBlockTypesIdGet>>,
	TError = HTTPValidationError,
>(
	id: string,
	options?: {
		query?: Partial<
			UseSuspenseQueryOptions<
				Awaited<ReturnType<typeof readBlockTypeByIdBlockTypesIdGet>>,
				TError,
				TData
			>
		>;
		fetch?: RequestInit;
	},
): UseSuspenseQueryResult<TData, TError> & {
	queryKey: DataTag<QueryKey, TData, TError>;
} {
	const queryOptions = getReadBlockTypeByIdBlockTypesIdGetSuspenseQueryOptions(
		id,
		options,
	);

	const query = useSuspenseQuery(queryOptions) as UseSuspenseQueryResult<
		TData,
		TError
	> & { queryKey: DataTag<QueryKey, TData, TError> };

	query.queryKey = queryOptions.queryKey;

	return query;
}

/**
 * Update a block type.
 * @summary Update Block Type
 */
export type updateBlockTypeBlockTypesIdPatchResponse = {
	data: void | HTTPValidationError;
	status: number;
	headers: Headers;
};

export const getUpdateBlockTypeBlockTypesIdPatchUrl = (id: string) => {
	return `http://prefect.grose.click/api/block_types/${id}`;
};

export const updateBlockTypeBlockTypesIdPatch = async (
	id: string,
	blockTypeUpdate: BlockTypeUpdate,
	options?: RequestInit,
): Promise<updateBlockTypeBlockTypesIdPatchResponse> => {
	const res = await fetch(getUpdateBlockTypeBlockTypesIdPatchUrl(id), {
		...options,
		method: "PATCH",
		headers: { "Content-Type": "application/json", ...options?.headers },
		body: JSON.stringify(blockTypeUpdate),
	});

	const body = [204, 205, 304].includes(res.status) ? null : await res.text();
	const data: updateBlockTypeBlockTypesIdPatchResponse["data"] = body
		? JSON.parse(body)
		: {};

	return {
		data,
		status: res.status,
		headers: res.headers,
	} as updateBlockTypeBlockTypesIdPatchResponse;
};

export const getUpdateBlockTypeBlockTypesIdPatchMutationOptions = <
	TError = HTTPValidationError,
	TContext = unknown,
>(options?: {
	mutation?: UseMutationOptions<
		Awaited<ReturnType<typeof updateBlockTypeBlockTypesIdPatch>>,
		TError,
		{ id: string; data: BlockTypeUpdate },
		TContext
	>;
	fetch?: RequestInit;
}): UseMutationOptions<
	Awaited<ReturnType<typeof updateBlockTypeBlockTypesIdPatch>>,
	TError,
	{ id: string; data: BlockTypeUpdate },
	TContext
> => {
	const mutationKey = ["updateBlockTypeBlockTypesIdPatch"];
	const { mutation: mutationOptions, fetch: fetchOptions } = options
		? options.mutation &&
			"mutationKey" in options.mutation &&
			options.mutation.mutationKey
			? options
			: { ...options, mutation: { ...options.mutation, mutationKey } }
		: { mutation: { mutationKey }, fetch: undefined };

	const mutationFn: MutationFunction<
		Awaited<ReturnType<typeof updateBlockTypeBlockTypesIdPatch>>,
		{ id: string; data: BlockTypeUpdate }
	> = (props) => {
		const { id, data } = props ?? {};

		return updateBlockTypeBlockTypesIdPatch(id, data, fetchOptions);
	};

	return { mutationFn, ...mutationOptions };
};

export type UpdateBlockTypeBlockTypesIdPatchMutationResult = NonNullable<
	Awaited<ReturnType<typeof updateBlockTypeBlockTypesIdPatch>>
>;
export type UpdateBlockTypeBlockTypesIdPatchMutationBody = BlockTypeUpdate;
export type UpdateBlockTypeBlockTypesIdPatchMutationError = HTTPValidationError;

/**
 * @summary Update Block Type
 */
export const useUpdateBlockTypeBlockTypesIdPatch = <
	TError = HTTPValidationError,
	TContext = unknown,
>(options?: {
	mutation?: UseMutationOptions<
		Awaited<ReturnType<typeof updateBlockTypeBlockTypesIdPatch>>,
		TError,
		{ id: string; data: BlockTypeUpdate },
		TContext
	>;
	fetch?: RequestInit;
}): UseMutationResult<
	Awaited<ReturnType<typeof updateBlockTypeBlockTypesIdPatch>>,
	TError,
	{ id: string; data: BlockTypeUpdate },
	TContext
> => {
	const mutationOptions =
		getUpdateBlockTypeBlockTypesIdPatchMutationOptions(options);

	return useMutation(mutationOptions);
};
/**
 * @summary Delete Block Type
 */
export type deleteBlockTypeBlockTypesIdDeleteResponse = {
	data: void | HTTPValidationError;
	status: number;
	headers: Headers;
};

export const getDeleteBlockTypeBlockTypesIdDeleteUrl = (id: string) => {
	return `http://prefect.grose.click/api/block_types/${id}`;
};

export const deleteBlockTypeBlockTypesIdDelete = async (
	id: string,
	options?: RequestInit,
): Promise<deleteBlockTypeBlockTypesIdDeleteResponse> => {
	const res = await fetch(getDeleteBlockTypeBlockTypesIdDeleteUrl(id), {
		...options,
		method: "DELETE",
	});

	const body = [204, 205, 304].includes(res.status) ? null : await res.text();
	const data: deleteBlockTypeBlockTypesIdDeleteResponse["data"] = body
		? JSON.parse(body)
		: {};

	return {
		data,
		status: res.status,
		headers: res.headers,
	} as deleteBlockTypeBlockTypesIdDeleteResponse;
};

export const getDeleteBlockTypeBlockTypesIdDeleteMutationOptions = <
	TError = HTTPValidationError,
	TContext = unknown,
>(options?: {
	mutation?: UseMutationOptions<
		Awaited<ReturnType<typeof deleteBlockTypeBlockTypesIdDelete>>,
		TError,
		{ id: string },
		TContext
	>;
	fetch?: RequestInit;
}): UseMutationOptions<
	Awaited<ReturnType<typeof deleteBlockTypeBlockTypesIdDelete>>,
	TError,
	{ id: string },
	TContext
> => {
	const mutationKey = ["deleteBlockTypeBlockTypesIdDelete"];
	const { mutation: mutationOptions, fetch: fetchOptions } = options
		? options.mutation &&
			"mutationKey" in options.mutation &&
			options.mutation.mutationKey
			? options
			: { ...options, mutation: { ...options.mutation, mutationKey } }
		: { mutation: { mutationKey }, fetch: undefined };

	const mutationFn: MutationFunction<
		Awaited<ReturnType<typeof deleteBlockTypeBlockTypesIdDelete>>,
		{ id: string }
	> = (props) => {
		const { id } = props ?? {};

		return deleteBlockTypeBlockTypesIdDelete(id, fetchOptions);
	};

	return { mutationFn, ...mutationOptions };
};

export type DeleteBlockTypeBlockTypesIdDeleteMutationResult = NonNullable<
	Awaited<ReturnType<typeof deleteBlockTypeBlockTypesIdDelete>>
>;

export type DeleteBlockTypeBlockTypesIdDeleteMutationError =
	HTTPValidationError;

/**
 * @summary Delete Block Type
 */
export const useDeleteBlockTypeBlockTypesIdDelete = <
	TError = HTTPValidationError,
	TContext = unknown,
>(options?: {
	mutation?: UseMutationOptions<
		Awaited<ReturnType<typeof deleteBlockTypeBlockTypesIdDelete>>,
		TError,
		{ id: string },
		TContext
	>;
	fetch?: RequestInit;
}): UseMutationResult<
	Awaited<ReturnType<typeof deleteBlockTypeBlockTypesIdDelete>>,
	TError,
	{ id: string },
	TContext
> => {
	const mutationOptions =
		getDeleteBlockTypeBlockTypesIdDeleteMutationOptions(options);

	return useMutation(mutationOptions);
};
/**
 * Get a block type by name.
 * @summary Read Block Type By Slug
 */
export type readBlockTypeBySlugBlockTypesSlugSlugGetResponse = {
	data: BlockType | HTTPValidationError;
	status: number;
	headers: Headers;
};

export const getReadBlockTypeBySlugBlockTypesSlugSlugGetUrl = (
	slug: string,
) => {
	return `http://prefect.grose.click/api/block_types/slug/${slug}`;
};

export const readBlockTypeBySlugBlockTypesSlugSlugGet = async (
	slug: string,
	options?: RequestInit,
): Promise<readBlockTypeBySlugBlockTypesSlugSlugGetResponse> => {
	const res = await fetch(
		getReadBlockTypeBySlugBlockTypesSlugSlugGetUrl(slug),
		{
			...options,
			method: "GET",
		},
	);

	const body = [204, 205, 304].includes(res.status) ? null : await res.text();
	const data: readBlockTypeBySlugBlockTypesSlugSlugGetResponse["data"] = body
		? JSON.parse(body)
		: {};

	return {
		data,
		status: res.status,
		headers: res.headers,
	} as readBlockTypeBySlugBlockTypesSlugSlugGetResponse;
};

export const getReadBlockTypeBySlugBlockTypesSlugSlugGetQueryKey = (
	slug: string,
) => {
	return [`http://prefect.grose.click/api/block_types/slug/${slug}`] as const;
};

export const getReadBlockTypeBySlugBlockTypesSlugSlugGetQueryOptions = <
	TData = Awaited<ReturnType<typeof readBlockTypeBySlugBlockTypesSlugSlugGet>>,
	TError = HTTPValidationError,
>(
	slug: string,
	options?: {
		query?: Partial<
			UseQueryOptions<
				Awaited<ReturnType<typeof readBlockTypeBySlugBlockTypesSlugSlugGet>>,
				TError,
				TData
			>
		>;
		fetch?: RequestInit;
	},
) => {
	const { query: queryOptions, fetch: fetchOptions } = options ?? {};

	const queryKey =
		queryOptions?.queryKey ??
		getReadBlockTypeBySlugBlockTypesSlugSlugGetQueryKey(slug);

	const queryFn: QueryFunction<
		Awaited<ReturnType<typeof readBlockTypeBySlugBlockTypesSlugSlugGet>>
	> = ({ signal }) =>
		readBlockTypeBySlugBlockTypesSlugSlugGet(slug, { signal, ...fetchOptions });

	return {
		queryKey,
		queryFn,
		enabled: !!slug,
		...queryOptions,
	} as UseQueryOptions<
		Awaited<ReturnType<typeof readBlockTypeBySlugBlockTypesSlugSlugGet>>,
		TError,
		TData
	> & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type ReadBlockTypeBySlugBlockTypesSlugSlugGetQueryResult = NonNullable<
	Awaited<ReturnType<typeof readBlockTypeBySlugBlockTypesSlugSlugGet>>
>;
export type ReadBlockTypeBySlugBlockTypesSlugSlugGetQueryError =
	HTTPValidationError;

export function useReadBlockTypeBySlugBlockTypesSlugSlugGet<
	TData = Awaited<ReturnType<typeof readBlockTypeBySlugBlockTypesSlugSlugGet>>,
	TError = HTTPValidationError,
>(
	slug: string,
	options: {
		query: Partial<
			UseQueryOptions<
				Awaited<ReturnType<typeof readBlockTypeBySlugBlockTypesSlugSlugGet>>,
				TError,
				TData
			>
		> &
			Pick<
				DefinedInitialDataOptions<
					Awaited<ReturnType<typeof readBlockTypeBySlugBlockTypesSlugSlugGet>>,
					TError,
					Awaited<ReturnType<typeof readBlockTypeBySlugBlockTypesSlugSlugGet>>
				>,
				"initialData"
			>;
		fetch?: RequestInit;
	},
): DefinedUseQueryResult<TData, TError> & {
	queryKey: DataTag<QueryKey, TData, TError>;
};
export function useReadBlockTypeBySlugBlockTypesSlugSlugGet<
	TData = Awaited<ReturnType<typeof readBlockTypeBySlugBlockTypesSlugSlugGet>>,
	TError = HTTPValidationError,
>(
	slug: string,
	options?: {
		query?: Partial<
			UseQueryOptions<
				Awaited<ReturnType<typeof readBlockTypeBySlugBlockTypesSlugSlugGet>>,
				TError,
				TData
			>
		> &
			Pick<
				UndefinedInitialDataOptions<
					Awaited<ReturnType<typeof readBlockTypeBySlugBlockTypesSlugSlugGet>>,
					TError,
					Awaited<ReturnType<typeof readBlockTypeBySlugBlockTypesSlugSlugGet>>
				>,
				"initialData"
			>;
		fetch?: RequestInit;
	},
): UseQueryResult<TData, TError> & {
	queryKey: DataTag<QueryKey, TData, TError>;
};
export function useReadBlockTypeBySlugBlockTypesSlugSlugGet<
	TData = Awaited<ReturnType<typeof readBlockTypeBySlugBlockTypesSlugSlugGet>>,
	TError = HTTPValidationError,
>(
	slug: string,
	options?: {
		query?: Partial<
			UseQueryOptions<
				Awaited<ReturnType<typeof readBlockTypeBySlugBlockTypesSlugSlugGet>>,
				TError,
				TData
			>
		>;
		fetch?: RequestInit;
	},
): UseQueryResult<TData, TError> & {
	queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Read Block Type By Slug
 */

export function useReadBlockTypeBySlugBlockTypesSlugSlugGet<
	TData = Awaited<ReturnType<typeof readBlockTypeBySlugBlockTypesSlugSlugGet>>,
	TError = HTTPValidationError,
>(
	slug: string,
	options?: {
		query?: Partial<
			UseQueryOptions<
				Awaited<ReturnType<typeof readBlockTypeBySlugBlockTypesSlugSlugGet>>,
				TError,
				TData
			>
		>;
		fetch?: RequestInit;
	},
): UseQueryResult<TData, TError> & {
	queryKey: DataTag<QueryKey, TData, TError>;
} {
	const queryOptions = getReadBlockTypeBySlugBlockTypesSlugSlugGetQueryOptions(
		slug,
		options,
	);

	const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
		queryKey: DataTag<QueryKey, TData, TError>;
	};

	query.queryKey = queryOptions.queryKey;

	return query;
}

export const getReadBlockTypeBySlugBlockTypesSlugSlugGetSuspenseQueryOptions = <
	TData = Awaited<ReturnType<typeof readBlockTypeBySlugBlockTypesSlugSlugGet>>,
	TError = HTTPValidationError,
>(
	slug: string,
	options?: {
		query?: Partial<
			UseSuspenseQueryOptions<
				Awaited<ReturnType<typeof readBlockTypeBySlugBlockTypesSlugSlugGet>>,
				TError,
				TData
			>
		>;
		fetch?: RequestInit;
	},
) => {
	const { query: queryOptions, fetch: fetchOptions } = options ?? {};

	const queryKey =
		queryOptions?.queryKey ??
		getReadBlockTypeBySlugBlockTypesSlugSlugGetQueryKey(slug);

	const queryFn: QueryFunction<
		Awaited<ReturnType<typeof readBlockTypeBySlugBlockTypesSlugSlugGet>>
	> = ({ signal }) =>
		readBlockTypeBySlugBlockTypesSlugSlugGet(slug, { signal, ...fetchOptions });

	return { queryKey, queryFn, ...queryOptions } as UseSuspenseQueryOptions<
		Awaited<ReturnType<typeof readBlockTypeBySlugBlockTypesSlugSlugGet>>,
		TError,
		TData
	> & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type ReadBlockTypeBySlugBlockTypesSlugSlugGetSuspenseQueryResult =
	NonNullable<
		Awaited<ReturnType<typeof readBlockTypeBySlugBlockTypesSlugSlugGet>>
	>;
export type ReadBlockTypeBySlugBlockTypesSlugSlugGetSuspenseQueryError =
	HTTPValidationError;

export function useReadBlockTypeBySlugBlockTypesSlugSlugGetSuspense<
	TData = Awaited<ReturnType<typeof readBlockTypeBySlugBlockTypesSlugSlugGet>>,
	TError = HTTPValidationError,
>(
	slug: string,
	options: {
		query: Partial<
			UseSuspenseQueryOptions<
				Awaited<ReturnType<typeof readBlockTypeBySlugBlockTypesSlugSlugGet>>,
				TError,
				TData
			>
		>;
		fetch?: RequestInit;
	},
): UseSuspenseQueryResult<TData, TError> & {
	queryKey: DataTag<QueryKey, TData, TError>;
};
export function useReadBlockTypeBySlugBlockTypesSlugSlugGetSuspense<
	TData = Awaited<ReturnType<typeof readBlockTypeBySlugBlockTypesSlugSlugGet>>,
	TError = HTTPValidationError,
>(
	slug: string,
	options?: {
		query?: Partial<
			UseSuspenseQueryOptions<
				Awaited<ReturnType<typeof readBlockTypeBySlugBlockTypesSlugSlugGet>>,
				TError,
				TData
			>
		>;
		fetch?: RequestInit;
	},
): UseSuspenseQueryResult<TData, TError> & {
	queryKey: DataTag<QueryKey, TData, TError>;
};
export function useReadBlockTypeBySlugBlockTypesSlugSlugGetSuspense<
	TData = Awaited<ReturnType<typeof readBlockTypeBySlugBlockTypesSlugSlugGet>>,
	TError = HTTPValidationError,
>(
	slug: string,
	options?: {
		query?: Partial<
			UseSuspenseQueryOptions<
				Awaited<ReturnType<typeof readBlockTypeBySlugBlockTypesSlugSlugGet>>,
				TError,
				TData
			>
		>;
		fetch?: RequestInit;
	},
): UseSuspenseQueryResult<TData, TError> & {
	queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Read Block Type By Slug
 */

export function useReadBlockTypeBySlugBlockTypesSlugSlugGetSuspense<
	TData = Awaited<ReturnType<typeof readBlockTypeBySlugBlockTypesSlugSlugGet>>,
	TError = HTTPValidationError,
>(
	slug: string,
	options?: {
		query?: Partial<
			UseSuspenseQueryOptions<
				Awaited<ReturnType<typeof readBlockTypeBySlugBlockTypesSlugSlugGet>>,
				TError,
				TData
			>
		>;
		fetch?: RequestInit;
	},
): UseSuspenseQueryResult<TData, TError> & {
	queryKey: DataTag<QueryKey, TData, TError>;
} {
	const queryOptions =
		getReadBlockTypeBySlugBlockTypesSlugSlugGetSuspenseQueryOptions(
			slug,
			options,
		);

	const query = useSuspenseQuery(queryOptions) as UseSuspenseQueryResult<
		TData,
		TError
	> & { queryKey: DataTag<QueryKey, TData, TError> };

	query.queryKey = queryOptions.queryKey;

	return query;
}

/**
 * Gets all block types. Optionally limit return with limit and offset.
 * @summary Read Block Types
 */
export type readBlockTypesBlockTypesFilterPostResponse = {
	data: BlockType[] | HTTPValidationError;
	status: number;
	headers: Headers;
};

export const getReadBlockTypesBlockTypesFilterPostUrl = () => {
	return `http://prefect.grose.click/api/block_types/filter`;
};

export const readBlockTypesBlockTypesFilterPost = async (
	bodyReadBlockTypesBlockTypesFilterPost: BodyReadBlockTypesBlockTypesFilterPost,
	options?: RequestInit,
): Promise<readBlockTypesBlockTypesFilterPostResponse> => {
	const res = await fetch(getReadBlockTypesBlockTypesFilterPostUrl(), {
		...options,
		method: "POST",
		headers: { "Content-Type": "application/json", ...options?.headers },
		body: JSON.stringify(bodyReadBlockTypesBlockTypesFilterPost),
	});

	const body = [204, 205, 304].includes(res.status) ? null : await res.text();
	const data: readBlockTypesBlockTypesFilterPostResponse["data"] = body
		? JSON.parse(body)
		: {};

	return {
		data,
		status: res.status,
		headers: res.headers,
	} as readBlockTypesBlockTypesFilterPostResponse;
};

export const getReadBlockTypesBlockTypesFilterPostMutationOptions = <
	TError = HTTPValidationError,
	TContext = unknown,
>(options?: {
	mutation?: UseMutationOptions<
		Awaited<ReturnType<typeof readBlockTypesBlockTypesFilterPost>>,
		TError,
		{ data: BodyReadBlockTypesBlockTypesFilterPost },
		TContext
	>;
	fetch?: RequestInit;
}): UseMutationOptions<
	Awaited<ReturnType<typeof readBlockTypesBlockTypesFilterPost>>,
	TError,
	{ data: BodyReadBlockTypesBlockTypesFilterPost },
	TContext
> => {
	const mutationKey = ["readBlockTypesBlockTypesFilterPost"];
	const { mutation: mutationOptions, fetch: fetchOptions } = options
		? options.mutation &&
			"mutationKey" in options.mutation &&
			options.mutation.mutationKey
			? options
			: { ...options, mutation: { ...options.mutation, mutationKey } }
		: { mutation: { mutationKey }, fetch: undefined };

	const mutationFn: MutationFunction<
		Awaited<ReturnType<typeof readBlockTypesBlockTypesFilterPost>>,
		{ data: BodyReadBlockTypesBlockTypesFilterPost }
	> = (props) => {
		const { data } = props ?? {};

		return readBlockTypesBlockTypesFilterPost(data, fetchOptions);
	};

	return { mutationFn, ...mutationOptions };
};

export type ReadBlockTypesBlockTypesFilterPostMutationResult = NonNullable<
	Awaited<ReturnType<typeof readBlockTypesBlockTypesFilterPost>>
>;
export type ReadBlockTypesBlockTypesFilterPostMutationBody =
	BodyReadBlockTypesBlockTypesFilterPost;
export type ReadBlockTypesBlockTypesFilterPostMutationError =
	HTTPValidationError;

/**
 * @summary Read Block Types
 */
export const useReadBlockTypesBlockTypesFilterPost = <
	TError = HTTPValidationError,
	TContext = unknown,
>(options?: {
	mutation?: UseMutationOptions<
		Awaited<ReturnType<typeof readBlockTypesBlockTypesFilterPost>>,
		TError,
		{ data: BodyReadBlockTypesBlockTypesFilterPost },
		TContext
	>;
	fetch?: RequestInit;
}): UseMutationResult<
	Awaited<ReturnType<typeof readBlockTypesBlockTypesFilterPost>>,
	TError,
	{ data: BodyReadBlockTypesBlockTypesFilterPost },
	TContext
> => {
	const mutationOptions =
		getReadBlockTypesBlockTypesFilterPostMutationOptions(options);

	return useMutation(mutationOptions);
};
/**
 * @summary Read Block Documents For Block Type
 */
export type readBlockDocumentsForBlockTypeBlockTypesSlugSlugBlockDocumentsGetResponse =
	{
		data: BlockDocument[] | HTTPValidationError;
		status: number;
		headers: Headers;
	};

export const getReadBlockDocumentsForBlockTypeBlockTypesSlugSlugBlockDocumentsGetUrl =
	(
		slug: string,
		params?: ReadBlockDocumentsForBlockTypeBlockTypesSlugSlugBlockDocumentsGetParams,
	) => {
		const normalizedParams = new URLSearchParams();

		Object.entries(params || {}).forEach(([key, value]) => {
			if (value !== undefined) {
				normalizedParams.append(
					key,
					value === null ? "null" : value.toString(),
				);
			}
		});

		return normalizedParams.size
			? `http://prefect.grose.click/api/block_types/slug/${slug}/block_documents?${normalizedParams.toString()}`
			: `http://prefect.grose.click/api/block_types/slug/${slug}/block_documents`;
	};

export const readBlockDocumentsForBlockTypeBlockTypesSlugSlugBlockDocumentsGet =
	async (
		slug: string,
		params?: ReadBlockDocumentsForBlockTypeBlockTypesSlugSlugBlockDocumentsGetParams,
		options?: RequestInit,
	): Promise<readBlockDocumentsForBlockTypeBlockTypesSlugSlugBlockDocumentsGetResponse> => {
		const res = await fetch(
			getReadBlockDocumentsForBlockTypeBlockTypesSlugSlugBlockDocumentsGetUrl(
				slug,
				params,
			),
			{
				...options,
				method: "GET",
			},
		);

		const body = [204, 205, 304].includes(res.status) ? null : await res.text();
		const data: readBlockDocumentsForBlockTypeBlockTypesSlugSlugBlockDocumentsGetResponse["data"] =
			body ? JSON.parse(body) : {};

		return {
			data,
			status: res.status,
			headers: res.headers,
		} as readBlockDocumentsForBlockTypeBlockTypesSlugSlugBlockDocumentsGetResponse;
	};

export const getReadBlockDocumentsForBlockTypeBlockTypesSlugSlugBlockDocumentsGetQueryKey =
	(
		slug: string,
		params?: ReadBlockDocumentsForBlockTypeBlockTypesSlugSlugBlockDocumentsGetParams,
	) => {
		return [
			`http://prefect.grose.click/api/block_types/slug/${slug}/block_documents`,
			...(params ? [params] : []),
		] as const;
	};

export const getReadBlockDocumentsForBlockTypeBlockTypesSlugSlugBlockDocumentsGetQueryOptions =
	<
		TData = Awaited<
			ReturnType<
				typeof readBlockDocumentsForBlockTypeBlockTypesSlugSlugBlockDocumentsGet
			>
		>,
		TError = HTTPValidationError,
	>(
		slug: string,
		params?: ReadBlockDocumentsForBlockTypeBlockTypesSlugSlugBlockDocumentsGetParams,
		options?: {
			query?: Partial<
				UseQueryOptions<
					Awaited<
						ReturnType<
							typeof readBlockDocumentsForBlockTypeBlockTypesSlugSlugBlockDocumentsGet
						>
					>,
					TError,
					TData
				>
			>;
			fetch?: RequestInit;
		},
	) => {
		const { query: queryOptions, fetch: fetchOptions } = options ?? {};

		const queryKey =
			queryOptions?.queryKey ??
			getReadBlockDocumentsForBlockTypeBlockTypesSlugSlugBlockDocumentsGetQueryKey(
				slug,
				params,
			);

		const queryFn: QueryFunction<
			Awaited<
				ReturnType<
					typeof readBlockDocumentsForBlockTypeBlockTypesSlugSlugBlockDocumentsGet
				>
			>
		> = ({ signal }) =>
			readBlockDocumentsForBlockTypeBlockTypesSlugSlugBlockDocumentsGet(
				slug,
				params,
				{ signal, ...fetchOptions },
			);

		return {
			queryKey,
			queryFn,
			enabled: !!slug,
			...queryOptions,
		} as UseQueryOptions<
			Awaited<
				ReturnType<
					typeof readBlockDocumentsForBlockTypeBlockTypesSlugSlugBlockDocumentsGet
				>
			>,
			TError,
			TData
		> & { queryKey: DataTag<QueryKey, TData, TError> };
	};

export type ReadBlockDocumentsForBlockTypeBlockTypesSlugSlugBlockDocumentsGetQueryResult =
	NonNullable<
		Awaited<
			ReturnType<
				typeof readBlockDocumentsForBlockTypeBlockTypesSlugSlugBlockDocumentsGet
			>
		>
	>;
export type ReadBlockDocumentsForBlockTypeBlockTypesSlugSlugBlockDocumentsGetQueryError =
	HTTPValidationError;

export function useReadBlockDocumentsForBlockTypeBlockTypesSlugSlugBlockDocumentsGet<
	TData = Awaited<
		ReturnType<
			typeof readBlockDocumentsForBlockTypeBlockTypesSlugSlugBlockDocumentsGet
		>
	>,
	TError = HTTPValidationError,
>(
	slug: string,
	params:
		| undefined
		| ReadBlockDocumentsForBlockTypeBlockTypesSlugSlugBlockDocumentsGetParams,
	options: {
		query: Partial<
			UseQueryOptions<
				Awaited<
					ReturnType<
						typeof readBlockDocumentsForBlockTypeBlockTypesSlugSlugBlockDocumentsGet
					>
				>,
				TError,
				TData
			>
		> &
			Pick<
				DefinedInitialDataOptions<
					Awaited<
						ReturnType<
							typeof readBlockDocumentsForBlockTypeBlockTypesSlugSlugBlockDocumentsGet
						>
					>,
					TError,
					Awaited<
						ReturnType<
							typeof readBlockDocumentsForBlockTypeBlockTypesSlugSlugBlockDocumentsGet
						>
					>
				>,
				"initialData"
			>;
		fetch?: RequestInit;
	},
): DefinedUseQueryResult<TData, TError> & {
	queryKey: DataTag<QueryKey, TData, TError>;
};
export function useReadBlockDocumentsForBlockTypeBlockTypesSlugSlugBlockDocumentsGet<
	TData = Awaited<
		ReturnType<
			typeof readBlockDocumentsForBlockTypeBlockTypesSlugSlugBlockDocumentsGet
		>
	>,
	TError = HTTPValidationError,
>(
	slug: string,
	params?: ReadBlockDocumentsForBlockTypeBlockTypesSlugSlugBlockDocumentsGetParams,
	options?: {
		query?: Partial<
			UseQueryOptions<
				Awaited<
					ReturnType<
						typeof readBlockDocumentsForBlockTypeBlockTypesSlugSlugBlockDocumentsGet
					>
				>,
				TError,
				TData
			>
		> &
			Pick<
				UndefinedInitialDataOptions<
					Awaited<
						ReturnType<
							typeof readBlockDocumentsForBlockTypeBlockTypesSlugSlugBlockDocumentsGet
						>
					>,
					TError,
					Awaited<
						ReturnType<
							typeof readBlockDocumentsForBlockTypeBlockTypesSlugSlugBlockDocumentsGet
						>
					>
				>,
				"initialData"
			>;
		fetch?: RequestInit;
	},
): UseQueryResult<TData, TError> & {
	queryKey: DataTag<QueryKey, TData, TError>;
};
export function useReadBlockDocumentsForBlockTypeBlockTypesSlugSlugBlockDocumentsGet<
	TData = Awaited<
		ReturnType<
			typeof readBlockDocumentsForBlockTypeBlockTypesSlugSlugBlockDocumentsGet
		>
	>,
	TError = HTTPValidationError,
>(
	slug: string,
	params?: ReadBlockDocumentsForBlockTypeBlockTypesSlugSlugBlockDocumentsGetParams,
	options?: {
		query?: Partial<
			UseQueryOptions<
				Awaited<
					ReturnType<
						typeof readBlockDocumentsForBlockTypeBlockTypesSlugSlugBlockDocumentsGet
					>
				>,
				TError,
				TData
			>
		>;
		fetch?: RequestInit;
	},
): UseQueryResult<TData, TError> & {
	queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Read Block Documents For Block Type
 */

export function useReadBlockDocumentsForBlockTypeBlockTypesSlugSlugBlockDocumentsGet<
	TData = Awaited<
		ReturnType<
			typeof readBlockDocumentsForBlockTypeBlockTypesSlugSlugBlockDocumentsGet
		>
	>,
	TError = HTTPValidationError,
>(
	slug: string,
	params?: ReadBlockDocumentsForBlockTypeBlockTypesSlugSlugBlockDocumentsGetParams,
	options?: {
		query?: Partial<
			UseQueryOptions<
				Awaited<
					ReturnType<
						typeof readBlockDocumentsForBlockTypeBlockTypesSlugSlugBlockDocumentsGet
					>
				>,
				TError,
				TData
			>
		>;
		fetch?: RequestInit;
	},
): UseQueryResult<TData, TError> & {
	queryKey: DataTag<QueryKey, TData, TError>;
} {
	const queryOptions =
		getReadBlockDocumentsForBlockTypeBlockTypesSlugSlugBlockDocumentsGetQueryOptions(
			slug,
			params,
			options,
		);

	const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
		queryKey: DataTag<QueryKey, TData, TError>;
	};

	query.queryKey = queryOptions.queryKey;

	return query;
}

export const getReadBlockDocumentsForBlockTypeBlockTypesSlugSlugBlockDocumentsGetSuspenseQueryOptions =
	<
		TData = Awaited<
			ReturnType<
				typeof readBlockDocumentsForBlockTypeBlockTypesSlugSlugBlockDocumentsGet
			>
		>,
		TError = HTTPValidationError,
	>(
		slug: string,
		params?: ReadBlockDocumentsForBlockTypeBlockTypesSlugSlugBlockDocumentsGetParams,
		options?: {
			query?: Partial<
				UseSuspenseQueryOptions<
					Awaited<
						ReturnType<
							typeof readBlockDocumentsForBlockTypeBlockTypesSlugSlugBlockDocumentsGet
						>
					>,
					TError,
					TData
				>
			>;
			fetch?: RequestInit;
		},
	) => {
		const { query: queryOptions, fetch: fetchOptions } = options ?? {};

		const queryKey =
			queryOptions?.queryKey ??
			getReadBlockDocumentsForBlockTypeBlockTypesSlugSlugBlockDocumentsGetQueryKey(
				slug,
				params,
			);

		const queryFn: QueryFunction<
			Awaited<
				ReturnType<
					typeof readBlockDocumentsForBlockTypeBlockTypesSlugSlugBlockDocumentsGet
				>
			>
		> = ({ signal }) =>
			readBlockDocumentsForBlockTypeBlockTypesSlugSlugBlockDocumentsGet(
				slug,
				params,
				{ signal, ...fetchOptions },
			);

		return { queryKey, queryFn, ...queryOptions } as UseSuspenseQueryOptions<
			Awaited<
				ReturnType<
					typeof readBlockDocumentsForBlockTypeBlockTypesSlugSlugBlockDocumentsGet
				>
			>,
			TError,
			TData
		> & { queryKey: DataTag<QueryKey, TData, TError> };
	};

export type ReadBlockDocumentsForBlockTypeBlockTypesSlugSlugBlockDocumentsGetSuspenseQueryResult =
	NonNullable<
		Awaited<
			ReturnType<
				typeof readBlockDocumentsForBlockTypeBlockTypesSlugSlugBlockDocumentsGet
			>
		>
	>;
export type ReadBlockDocumentsForBlockTypeBlockTypesSlugSlugBlockDocumentsGetSuspenseQueryError =
	HTTPValidationError;

export function useReadBlockDocumentsForBlockTypeBlockTypesSlugSlugBlockDocumentsGetSuspense<
	TData = Awaited<
		ReturnType<
			typeof readBlockDocumentsForBlockTypeBlockTypesSlugSlugBlockDocumentsGet
		>
	>,
	TError = HTTPValidationError,
>(
	slug: string,
	params:
		| undefined
		| ReadBlockDocumentsForBlockTypeBlockTypesSlugSlugBlockDocumentsGetParams,
	options: {
		query: Partial<
			UseSuspenseQueryOptions<
				Awaited<
					ReturnType<
						typeof readBlockDocumentsForBlockTypeBlockTypesSlugSlugBlockDocumentsGet
					>
				>,
				TError,
				TData
			>
		>;
		fetch?: RequestInit;
	},
): UseSuspenseQueryResult<TData, TError> & {
	queryKey: DataTag<QueryKey, TData, TError>;
};
export function useReadBlockDocumentsForBlockTypeBlockTypesSlugSlugBlockDocumentsGetSuspense<
	TData = Awaited<
		ReturnType<
			typeof readBlockDocumentsForBlockTypeBlockTypesSlugSlugBlockDocumentsGet
		>
	>,
	TError = HTTPValidationError,
>(
	slug: string,
	params?: ReadBlockDocumentsForBlockTypeBlockTypesSlugSlugBlockDocumentsGetParams,
	options?: {
		query?: Partial<
			UseSuspenseQueryOptions<
				Awaited<
					ReturnType<
						typeof readBlockDocumentsForBlockTypeBlockTypesSlugSlugBlockDocumentsGet
					>
				>,
				TError,
				TData
			>
		>;
		fetch?: RequestInit;
	},
): UseSuspenseQueryResult<TData, TError> & {
	queryKey: DataTag<QueryKey, TData, TError>;
};
export function useReadBlockDocumentsForBlockTypeBlockTypesSlugSlugBlockDocumentsGetSuspense<
	TData = Awaited<
		ReturnType<
			typeof readBlockDocumentsForBlockTypeBlockTypesSlugSlugBlockDocumentsGet
		>
	>,
	TError = HTTPValidationError,
>(
	slug: string,
	params?: ReadBlockDocumentsForBlockTypeBlockTypesSlugSlugBlockDocumentsGetParams,
	options?: {
		query?: Partial<
			UseSuspenseQueryOptions<
				Awaited<
					ReturnType<
						typeof readBlockDocumentsForBlockTypeBlockTypesSlugSlugBlockDocumentsGet
					>
				>,
				TError,
				TData
			>
		>;
		fetch?: RequestInit;
	},
): UseSuspenseQueryResult<TData, TError> & {
	queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Read Block Documents For Block Type
 */

export function useReadBlockDocumentsForBlockTypeBlockTypesSlugSlugBlockDocumentsGetSuspense<
	TData = Awaited<
		ReturnType<
			typeof readBlockDocumentsForBlockTypeBlockTypesSlugSlugBlockDocumentsGet
		>
	>,
	TError = HTTPValidationError,
>(
	slug: string,
	params?: ReadBlockDocumentsForBlockTypeBlockTypesSlugSlugBlockDocumentsGetParams,
	options?: {
		query?: Partial<
			UseSuspenseQueryOptions<
				Awaited<
					ReturnType<
						typeof readBlockDocumentsForBlockTypeBlockTypesSlugSlugBlockDocumentsGet
					>
				>,
				TError,
				TData
			>
		>;
		fetch?: RequestInit;
	},
): UseSuspenseQueryResult<TData, TError> & {
	queryKey: DataTag<QueryKey, TData, TError>;
} {
	const queryOptions =
		getReadBlockDocumentsForBlockTypeBlockTypesSlugSlugBlockDocumentsGetSuspenseQueryOptions(
			slug,
			params,
			options,
		);

	const query = useSuspenseQuery(queryOptions) as UseSuspenseQueryResult<
		TData,
		TError
	> & { queryKey: DataTag<QueryKey, TData, TError> };

	query.queryKey = queryOptions.queryKey;

	return query;
}

/**
 * @summary Read Block Document By Name For Block Type
 */
export type readBlockDocumentByNameForBlockTypeBlockTypesSlugSlugBlockDocumentsNameBlockDocumentNameGetResponse =
	{
		data: BlockDocument | HTTPValidationError;
		status: number;
		headers: Headers;
	};

export const getReadBlockDocumentByNameForBlockTypeBlockTypesSlugSlugBlockDocumentsNameBlockDocumentNameGetUrl =
	(
		slug: string,
		blockDocumentName: string,
		params?: ReadBlockDocumentByNameForBlockTypeBlockTypesSlugSlugBlockDocumentsNameBlockDocumentNameGetParams,
	) => {
		const normalizedParams = new URLSearchParams();

		Object.entries(params || {}).forEach(([key, value]) => {
			if (value !== undefined) {
				normalizedParams.append(
					key,
					value === null ? "null" : value.toString(),
				);
			}
		});

		return normalizedParams.size
			? `http://prefect.grose.click/api/block_types/slug/${slug}/block_documents/name/${blockDocumentName}?${normalizedParams.toString()}`
			: `http://prefect.grose.click/api/block_types/slug/${slug}/block_documents/name/${blockDocumentName}`;
	};

export const readBlockDocumentByNameForBlockTypeBlockTypesSlugSlugBlockDocumentsNameBlockDocumentNameGet =
	async (
		slug: string,
		blockDocumentName: string,
		params?: ReadBlockDocumentByNameForBlockTypeBlockTypesSlugSlugBlockDocumentsNameBlockDocumentNameGetParams,
		options?: RequestInit,
	): Promise<readBlockDocumentByNameForBlockTypeBlockTypesSlugSlugBlockDocumentsNameBlockDocumentNameGetResponse> => {
		const res = await fetch(
			getReadBlockDocumentByNameForBlockTypeBlockTypesSlugSlugBlockDocumentsNameBlockDocumentNameGetUrl(
				slug,
				blockDocumentName,
				params,
			),
			{
				...options,
				method: "GET",
			},
		);

		const body = [204, 205, 304].includes(res.status) ? null : await res.text();
		const data: readBlockDocumentByNameForBlockTypeBlockTypesSlugSlugBlockDocumentsNameBlockDocumentNameGetResponse["data"] =
			body ? JSON.parse(body) : {};

		return {
			data,
			status: res.status,
			headers: res.headers,
		} as readBlockDocumentByNameForBlockTypeBlockTypesSlugSlugBlockDocumentsNameBlockDocumentNameGetResponse;
	};

export const getReadBlockDocumentByNameForBlockTypeBlockTypesSlugSlugBlockDocumentsNameBlockDocumentNameGetQueryKey =
	(
		slug: string,
		blockDocumentName: string,
		params?: ReadBlockDocumentByNameForBlockTypeBlockTypesSlugSlugBlockDocumentsNameBlockDocumentNameGetParams,
	) => {
		return [
			`http://prefect.grose.click/api/block_types/slug/${slug}/block_documents/name/${blockDocumentName}`,
			...(params ? [params] : []),
		] as const;
	};

export const getReadBlockDocumentByNameForBlockTypeBlockTypesSlugSlugBlockDocumentsNameBlockDocumentNameGetQueryOptions =
	<
		TData = Awaited<
			ReturnType<
				typeof readBlockDocumentByNameForBlockTypeBlockTypesSlugSlugBlockDocumentsNameBlockDocumentNameGet
			>
		>,
		TError = HTTPValidationError,
	>(
		slug: string,
		blockDocumentName: string,
		params?: ReadBlockDocumentByNameForBlockTypeBlockTypesSlugSlugBlockDocumentsNameBlockDocumentNameGetParams,
		options?: {
			query?: Partial<
				UseQueryOptions<
					Awaited<
						ReturnType<
							typeof readBlockDocumentByNameForBlockTypeBlockTypesSlugSlugBlockDocumentsNameBlockDocumentNameGet
						>
					>,
					TError,
					TData
				>
			>;
			fetch?: RequestInit;
		},
	) => {
		const { query: queryOptions, fetch: fetchOptions } = options ?? {};

		const queryKey =
			queryOptions?.queryKey ??
			getReadBlockDocumentByNameForBlockTypeBlockTypesSlugSlugBlockDocumentsNameBlockDocumentNameGetQueryKey(
				slug,
				blockDocumentName,
				params,
			);

		const queryFn: QueryFunction<
			Awaited<
				ReturnType<
					typeof readBlockDocumentByNameForBlockTypeBlockTypesSlugSlugBlockDocumentsNameBlockDocumentNameGet
				>
			>
		> = ({ signal }) =>
			readBlockDocumentByNameForBlockTypeBlockTypesSlugSlugBlockDocumentsNameBlockDocumentNameGet(
				slug,
				blockDocumentName,
				params,
				{ signal, ...fetchOptions },
			);

		return {
			queryKey,
			queryFn,
			enabled: !!(slug && blockDocumentName),
			...queryOptions,
		} as UseQueryOptions<
			Awaited<
				ReturnType<
					typeof readBlockDocumentByNameForBlockTypeBlockTypesSlugSlugBlockDocumentsNameBlockDocumentNameGet
				>
			>,
			TError,
			TData
		> & { queryKey: DataTag<QueryKey, TData, TError> };
	};

export type ReadBlockDocumentByNameForBlockTypeBlockTypesSlugSlugBlockDocumentsNameBlockDocumentNameGetQueryResult =
	NonNullable<
		Awaited<
			ReturnType<
				typeof readBlockDocumentByNameForBlockTypeBlockTypesSlugSlugBlockDocumentsNameBlockDocumentNameGet
			>
		>
	>;
export type ReadBlockDocumentByNameForBlockTypeBlockTypesSlugSlugBlockDocumentsNameBlockDocumentNameGetQueryError =
	HTTPValidationError;

export function useReadBlockDocumentByNameForBlockTypeBlockTypesSlugSlugBlockDocumentsNameBlockDocumentNameGet<
	TData = Awaited<
		ReturnType<
			typeof readBlockDocumentByNameForBlockTypeBlockTypesSlugSlugBlockDocumentsNameBlockDocumentNameGet
		>
	>,
	TError = HTTPValidationError,
>(
	slug: string,
	blockDocumentName: string,
	params:
		| undefined
		| ReadBlockDocumentByNameForBlockTypeBlockTypesSlugSlugBlockDocumentsNameBlockDocumentNameGetParams,
	options: {
		query: Partial<
			UseQueryOptions<
				Awaited<
					ReturnType<
						typeof readBlockDocumentByNameForBlockTypeBlockTypesSlugSlugBlockDocumentsNameBlockDocumentNameGet
					>
				>,
				TError,
				TData
			>
		> &
			Pick<
				DefinedInitialDataOptions<
					Awaited<
						ReturnType<
							typeof readBlockDocumentByNameForBlockTypeBlockTypesSlugSlugBlockDocumentsNameBlockDocumentNameGet
						>
					>,
					TError,
					Awaited<
						ReturnType<
							typeof readBlockDocumentByNameForBlockTypeBlockTypesSlugSlugBlockDocumentsNameBlockDocumentNameGet
						>
					>
				>,
				"initialData"
			>;
		fetch?: RequestInit;
	},
): DefinedUseQueryResult<TData, TError> & {
	queryKey: DataTag<QueryKey, TData, TError>;
};
export function useReadBlockDocumentByNameForBlockTypeBlockTypesSlugSlugBlockDocumentsNameBlockDocumentNameGet<
	TData = Awaited<
		ReturnType<
			typeof readBlockDocumentByNameForBlockTypeBlockTypesSlugSlugBlockDocumentsNameBlockDocumentNameGet
		>
	>,
	TError = HTTPValidationError,
>(
	slug: string,
	blockDocumentName: string,
	params?: ReadBlockDocumentByNameForBlockTypeBlockTypesSlugSlugBlockDocumentsNameBlockDocumentNameGetParams,
	options?: {
		query?: Partial<
			UseQueryOptions<
				Awaited<
					ReturnType<
						typeof readBlockDocumentByNameForBlockTypeBlockTypesSlugSlugBlockDocumentsNameBlockDocumentNameGet
					>
				>,
				TError,
				TData
			>
		> &
			Pick<
				UndefinedInitialDataOptions<
					Awaited<
						ReturnType<
							typeof readBlockDocumentByNameForBlockTypeBlockTypesSlugSlugBlockDocumentsNameBlockDocumentNameGet
						>
					>,
					TError,
					Awaited<
						ReturnType<
							typeof readBlockDocumentByNameForBlockTypeBlockTypesSlugSlugBlockDocumentsNameBlockDocumentNameGet
						>
					>
				>,
				"initialData"
			>;
		fetch?: RequestInit;
	},
): UseQueryResult<TData, TError> & {
	queryKey: DataTag<QueryKey, TData, TError>;
};
export function useReadBlockDocumentByNameForBlockTypeBlockTypesSlugSlugBlockDocumentsNameBlockDocumentNameGet<
	TData = Awaited<
		ReturnType<
			typeof readBlockDocumentByNameForBlockTypeBlockTypesSlugSlugBlockDocumentsNameBlockDocumentNameGet
		>
	>,
	TError = HTTPValidationError,
>(
	slug: string,
	blockDocumentName: string,
	params?: ReadBlockDocumentByNameForBlockTypeBlockTypesSlugSlugBlockDocumentsNameBlockDocumentNameGetParams,
	options?: {
		query?: Partial<
			UseQueryOptions<
				Awaited<
					ReturnType<
						typeof readBlockDocumentByNameForBlockTypeBlockTypesSlugSlugBlockDocumentsNameBlockDocumentNameGet
					>
				>,
				TError,
				TData
			>
		>;
		fetch?: RequestInit;
	},
): UseQueryResult<TData, TError> & {
	queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Read Block Document By Name For Block Type
 */

export function useReadBlockDocumentByNameForBlockTypeBlockTypesSlugSlugBlockDocumentsNameBlockDocumentNameGet<
	TData = Awaited<
		ReturnType<
			typeof readBlockDocumentByNameForBlockTypeBlockTypesSlugSlugBlockDocumentsNameBlockDocumentNameGet
		>
	>,
	TError = HTTPValidationError,
>(
	slug: string,
	blockDocumentName: string,
	params?: ReadBlockDocumentByNameForBlockTypeBlockTypesSlugSlugBlockDocumentsNameBlockDocumentNameGetParams,
	options?: {
		query?: Partial<
			UseQueryOptions<
				Awaited<
					ReturnType<
						typeof readBlockDocumentByNameForBlockTypeBlockTypesSlugSlugBlockDocumentsNameBlockDocumentNameGet
					>
				>,
				TError,
				TData
			>
		>;
		fetch?: RequestInit;
	},
): UseQueryResult<TData, TError> & {
	queryKey: DataTag<QueryKey, TData, TError>;
} {
	const queryOptions =
		getReadBlockDocumentByNameForBlockTypeBlockTypesSlugSlugBlockDocumentsNameBlockDocumentNameGetQueryOptions(
			slug,
			blockDocumentName,
			params,
			options,
		);

	const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
		queryKey: DataTag<QueryKey, TData, TError>;
	};

	query.queryKey = queryOptions.queryKey;

	return query;
}

export const getReadBlockDocumentByNameForBlockTypeBlockTypesSlugSlugBlockDocumentsNameBlockDocumentNameGetSuspenseQueryOptions =
	<
		TData = Awaited<
			ReturnType<
				typeof readBlockDocumentByNameForBlockTypeBlockTypesSlugSlugBlockDocumentsNameBlockDocumentNameGet
			>
		>,
		TError = HTTPValidationError,
	>(
		slug: string,
		blockDocumentName: string,
		params?: ReadBlockDocumentByNameForBlockTypeBlockTypesSlugSlugBlockDocumentsNameBlockDocumentNameGetParams,
		options?: {
			query?: Partial<
				UseSuspenseQueryOptions<
					Awaited<
						ReturnType<
							typeof readBlockDocumentByNameForBlockTypeBlockTypesSlugSlugBlockDocumentsNameBlockDocumentNameGet
						>
					>,
					TError,
					TData
				>
			>;
			fetch?: RequestInit;
		},
	) => {
		const { query: queryOptions, fetch: fetchOptions } = options ?? {};

		const queryKey =
			queryOptions?.queryKey ??
			getReadBlockDocumentByNameForBlockTypeBlockTypesSlugSlugBlockDocumentsNameBlockDocumentNameGetQueryKey(
				slug,
				blockDocumentName,
				params,
			);

		const queryFn: QueryFunction<
			Awaited<
				ReturnType<
					typeof readBlockDocumentByNameForBlockTypeBlockTypesSlugSlugBlockDocumentsNameBlockDocumentNameGet
				>
			>
		> = ({ signal }) =>
			readBlockDocumentByNameForBlockTypeBlockTypesSlugSlugBlockDocumentsNameBlockDocumentNameGet(
				slug,
				blockDocumentName,
				params,
				{ signal, ...fetchOptions },
			);

		return { queryKey, queryFn, ...queryOptions } as UseSuspenseQueryOptions<
			Awaited<
				ReturnType<
					typeof readBlockDocumentByNameForBlockTypeBlockTypesSlugSlugBlockDocumentsNameBlockDocumentNameGet
				>
			>,
			TError,
			TData
		> & { queryKey: DataTag<QueryKey, TData, TError> };
	};

export type ReadBlockDocumentByNameForBlockTypeBlockTypesSlugSlugBlockDocumentsNameBlockDocumentNameGetSuspenseQueryResult =
	NonNullable<
		Awaited<
			ReturnType<
				typeof readBlockDocumentByNameForBlockTypeBlockTypesSlugSlugBlockDocumentsNameBlockDocumentNameGet
			>
		>
	>;
export type ReadBlockDocumentByNameForBlockTypeBlockTypesSlugSlugBlockDocumentsNameBlockDocumentNameGetSuspenseQueryError =
	HTTPValidationError;

export function useReadBlockDocumentByNameForBlockTypeBlockTypesSlugSlugBlockDocumentsNameBlockDocumentNameGetSuspense<
	TData = Awaited<
		ReturnType<
			typeof readBlockDocumentByNameForBlockTypeBlockTypesSlugSlugBlockDocumentsNameBlockDocumentNameGet
		>
	>,
	TError = HTTPValidationError,
>(
	slug: string,
	blockDocumentName: string,
	params:
		| undefined
		| ReadBlockDocumentByNameForBlockTypeBlockTypesSlugSlugBlockDocumentsNameBlockDocumentNameGetParams,
	options: {
		query: Partial<
			UseSuspenseQueryOptions<
				Awaited<
					ReturnType<
						typeof readBlockDocumentByNameForBlockTypeBlockTypesSlugSlugBlockDocumentsNameBlockDocumentNameGet
					>
				>,
				TError,
				TData
			>
		>;
		fetch?: RequestInit;
	},
): UseSuspenseQueryResult<TData, TError> & {
	queryKey: DataTag<QueryKey, TData, TError>;
};
export function useReadBlockDocumentByNameForBlockTypeBlockTypesSlugSlugBlockDocumentsNameBlockDocumentNameGetSuspense<
	TData = Awaited<
		ReturnType<
			typeof readBlockDocumentByNameForBlockTypeBlockTypesSlugSlugBlockDocumentsNameBlockDocumentNameGet
		>
	>,
	TError = HTTPValidationError,
>(
	slug: string,
	blockDocumentName: string,
	params?: ReadBlockDocumentByNameForBlockTypeBlockTypesSlugSlugBlockDocumentsNameBlockDocumentNameGetParams,
	options?: {
		query?: Partial<
			UseSuspenseQueryOptions<
				Awaited<
					ReturnType<
						typeof readBlockDocumentByNameForBlockTypeBlockTypesSlugSlugBlockDocumentsNameBlockDocumentNameGet
					>
				>,
				TError,
				TData
			>
		>;
		fetch?: RequestInit;
	},
): UseSuspenseQueryResult<TData, TError> & {
	queryKey: DataTag<QueryKey, TData, TError>;
};
export function useReadBlockDocumentByNameForBlockTypeBlockTypesSlugSlugBlockDocumentsNameBlockDocumentNameGetSuspense<
	TData = Awaited<
		ReturnType<
			typeof readBlockDocumentByNameForBlockTypeBlockTypesSlugSlugBlockDocumentsNameBlockDocumentNameGet
		>
	>,
	TError = HTTPValidationError,
>(
	slug: string,
	blockDocumentName: string,
	params?: ReadBlockDocumentByNameForBlockTypeBlockTypesSlugSlugBlockDocumentsNameBlockDocumentNameGetParams,
	options?: {
		query?: Partial<
			UseSuspenseQueryOptions<
				Awaited<
					ReturnType<
						typeof readBlockDocumentByNameForBlockTypeBlockTypesSlugSlugBlockDocumentsNameBlockDocumentNameGet
					>
				>,
				TError,
				TData
			>
		>;
		fetch?: RequestInit;
	},
): UseSuspenseQueryResult<TData, TError> & {
	queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Read Block Document By Name For Block Type
 */

export function useReadBlockDocumentByNameForBlockTypeBlockTypesSlugSlugBlockDocumentsNameBlockDocumentNameGetSuspense<
	TData = Awaited<
		ReturnType<
			typeof readBlockDocumentByNameForBlockTypeBlockTypesSlugSlugBlockDocumentsNameBlockDocumentNameGet
		>
	>,
	TError = HTTPValidationError,
>(
	slug: string,
	blockDocumentName: string,
	params?: ReadBlockDocumentByNameForBlockTypeBlockTypesSlugSlugBlockDocumentsNameBlockDocumentNameGetParams,
	options?: {
		query?: Partial<
			UseSuspenseQueryOptions<
				Awaited<
					ReturnType<
						typeof readBlockDocumentByNameForBlockTypeBlockTypesSlugSlugBlockDocumentsNameBlockDocumentNameGet
					>
				>,
				TError,
				TData
			>
		>;
		fetch?: RequestInit;
	},
): UseSuspenseQueryResult<TData, TError> & {
	queryKey: DataTag<QueryKey, TData, TError>;
} {
	const queryOptions =
		getReadBlockDocumentByNameForBlockTypeBlockTypesSlugSlugBlockDocumentsNameBlockDocumentNameGetSuspenseQueryOptions(
			slug,
			blockDocumentName,
			params,
			options,
		);

	const query = useSuspenseQuery(queryOptions) as UseSuspenseQueryResult<
		TData,
		TError
	> & { queryKey: DataTag<QueryKey, TData, TError> };

	query.queryKey = queryOptions.queryKey;

	return query;
}

/**
 * @summary Install System Block Types
 */
export type installSystemBlockTypesBlockTypesInstallSystemBlockTypesPostResponse =
	{
		data: HTTPValidationError;
		status: number;
		headers: Headers;
	};

export const getInstallSystemBlockTypesBlockTypesInstallSystemBlockTypesPostUrl =
	() => {
		return `http://prefect.grose.click/api/block_types/install_system_block_types`;
	};

export const installSystemBlockTypesBlockTypesInstallSystemBlockTypesPost =
	async (
		options?: RequestInit,
	): Promise<installSystemBlockTypesBlockTypesInstallSystemBlockTypesPostResponse> => {
		const res = await fetch(
			getInstallSystemBlockTypesBlockTypesInstallSystemBlockTypesPostUrl(),
			{
				...options,
				method: "POST",
			},
		);

		const body = [204, 205, 304].includes(res.status) ? null : await res.text();
		const data: installSystemBlockTypesBlockTypesInstallSystemBlockTypesPostResponse["data"] =
			body ? JSON.parse(body) : {};

		return {
			data,
			status: res.status,
			headers: res.headers,
		} as installSystemBlockTypesBlockTypesInstallSystemBlockTypesPostResponse;
	};

export const getInstallSystemBlockTypesBlockTypesInstallSystemBlockTypesPostMutationOptions =
	<TError = HTTPValidationError, TContext = unknown>(options?: {
		mutation?: UseMutationOptions<
			Awaited<
				ReturnType<
					typeof installSystemBlockTypesBlockTypesInstallSystemBlockTypesPost
				>
			>,
			TError,
			void,
			TContext
		>;
		fetch?: RequestInit;
	}): UseMutationOptions<
		Awaited<
			ReturnType<
				typeof installSystemBlockTypesBlockTypesInstallSystemBlockTypesPost
			>
		>,
		TError,
		void,
		TContext
	> => {
		const mutationKey = [
			"installSystemBlockTypesBlockTypesInstallSystemBlockTypesPost",
		];
		const { mutation: mutationOptions, fetch: fetchOptions } = options
			? options.mutation &&
				"mutationKey" in options.mutation &&
				options.mutation.mutationKey
				? options
				: { ...options, mutation: { ...options.mutation, mutationKey } }
			: { mutation: { mutationKey }, fetch: undefined };

		const mutationFn: MutationFunction<
			Awaited<
				ReturnType<
					typeof installSystemBlockTypesBlockTypesInstallSystemBlockTypesPost
				>
			>,
			void
		> = () => {
			return installSystemBlockTypesBlockTypesInstallSystemBlockTypesPost(
				fetchOptions,
			);
		};

		return { mutationFn, ...mutationOptions };
	};

export type InstallSystemBlockTypesBlockTypesInstallSystemBlockTypesPostMutationResult =
	NonNullable<
		Awaited<
			ReturnType<
				typeof installSystemBlockTypesBlockTypesInstallSystemBlockTypesPost
			>
		>
	>;

export type InstallSystemBlockTypesBlockTypesInstallSystemBlockTypesPostMutationError =
	HTTPValidationError;

/**
 * @summary Install System Block Types
 */
export const useInstallSystemBlockTypesBlockTypesInstallSystemBlockTypesPost = <
	TError = HTTPValidationError,
	TContext = unknown,
>(options?: {
	mutation?: UseMutationOptions<
		Awaited<
			ReturnType<
				typeof installSystemBlockTypesBlockTypesInstallSystemBlockTypesPost
			>
		>,
		TError,
		void,
		TContext
	>;
	fetch?: RequestInit;
}): UseMutationResult<
	Awaited<
		ReturnType<
			typeof installSystemBlockTypesBlockTypesInstallSystemBlockTypesPost
		>
	>,
	TError,
	void,
	TContext
> => {
	const mutationOptions =
		getInstallSystemBlockTypesBlockTypesInstallSystemBlockTypesPostMutationOptions(
			options,
		);

	return useMutation(mutationOptions);
};
