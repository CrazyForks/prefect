/**
 * Generated by orval v7.5.0 🍺
 * Do not edit manually.
 * Prefect Prefect REST API
 * OpenAPI spec version: 0.1.0
 */
import { useMutation, useQuery, useSuspenseQuery } from "@tanstack/react-query";
import type {
	DataTag,
	DefinedInitialDataOptions,
	DefinedUseQueryResult,
	MutationFunction,
	QueryFunction,
	QueryKey,
	UndefinedInitialDataOptions,
	UseMutationOptions,
	UseMutationResult,
	UseQueryOptions,
	UseQueryResult,
	UseSuspenseQueryOptions,
	UseSuspenseQueryResult,
} from "@tanstack/react-query";
import type {
	BodyReadWorkQueueRunsWorkQueuesIdGetRunsPost,
	BodyReadWorkQueuesWorkQueuesFilterPost,
	FlowRunResponse,
	HTTPValidationError,
	WorkQueueCreate,
	WorkQueueResponse,
	WorkQueueStatusDetail,
	WorkQueueUpdate,
} from "../../models";

/**
 * Creates a new work queue.

If a work queue with the same name already exists, an error
will be raised.
 * @summary Create Work Queue
 */
export type createWorkQueueWorkQueuesPostResponse = {
	data: WorkQueueResponse | HTTPValidationError;
	status: number;
	headers: Headers;
};

export const getCreateWorkQueueWorkQueuesPostUrl = () => {
	return `http://prefect.grose.click/api/work_queues/`;
};

export const createWorkQueueWorkQueuesPost = async (
	workQueueCreate: WorkQueueCreate,
	options?: RequestInit,
): Promise<createWorkQueueWorkQueuesPostResponse> => {
	const res = await fetch(getCreateWorkQueueWorkQueuesPostUrl(), {
		...options,
		method: "POST",
		headers: { "Content-Type": "application/json", ...options?.headers },
		body: JSON.stringify(workQueueCreate),
	});

	const body = [204, 205, 304].includes(res.status) ? null : await res.text();
	const data: createWorkQueueWorkQueuesPostResponse["data"] = body
		? JSON.parse(body)
		: {};

	return {
		data,
		status: res.status,
		headers: res.headers,
	} as createWorkQueueWorkQueuesPostResponse;
};

export const getCreateWorkQueueWorkQueuesPostMutationOptions = <
	TError = HTTPValidationError,
	TContext = unknown,
>(options?: {
	mutation?: UseMutationOptions<
		Awaited<ReturnType<typeof createWorkQueueWorkQueuesPost>>,
		TError,
		{ data: WorkQueueCreate },
		TContext
	>;
	fetch?: RequestInit;
}): UseMutationOptions<
	Awaited<ReturnType<typeof createWorkQueueWorkQueuesPost>>,
	TError,
	{ data: WorkQueueCreate },
	TContext
> => {
	const mutationKey = ["createWorkQueueWorkQueuesPost"];
	const { mutation: mutationOptions, fetch: fetchOptions } = options
		? options.mutation &&
			"mutationKey" in options.mutation &&
			options.mutation.mutationKey
			? options
			: { ...options, mutation: { ...options.mutation, mutationKey } }
		: { mutation: { mutationKey }, fetch: undefined };

	const mutationFn: MutationFunction<
		Awaited<ReturnType<typeof createWorkQueueWorkQueuesPost>>,
		{ data: WorkQueueCreate }
	> = (props) => {
		const { data } = props ?? {};

		return createWorkQueueWorkQueuesPost(data, fetchOptions);
	};

	return { mutationFn, ...mutationOptions };
};

export type CreateWorkQueueWorkQueuesPostMutationResult = NonNullable<
	Awaited<ReturnType<typeof createWorkQueueWorkQueuesPost>>
>;
export type CreateWorkQueueWorkQueuesPostMutationBody = WorkQueueCreate;
export type CreateWorkQueueWorkQueuesPostMutationError = HTTPValidationError;

/**
 * @summary Create Work Queue
 */
export const useCreateWorkQueueWorkQueuesPost = <
	TError = HTTPValidationError,
	TContext = unknown,
>(options?: {
	mutation?: UseMutationOptions<
		Awaited<ReturnType<typeof createWorkQueueWorkQueuesPost>>,
		TError,
		{ data: WorkQueueCreate },
		TContext
	>;
	fetch?: RequestInit;
}): UseMutationResult<
	Awaited<ReturnType<typeof createWorkQueueWorkQueuesPost>>,
	TError,
	{ data: WorkQueueCreate },
	TContext
> => {
	const mutationOptions =
		getCreateWorkQueueWorkQueuesPostMutationOptions(options);

	return useMutation(mutationOptions);
};
/**
 * Updates an existing work queue.
 * @summary Update Work Queue
 */
export type updateWorkQueueWorkQueuesIdPatchResponse = {
	data: void | HTTPValidationError;
	status: number;
	headers: Headers;
};

export const getUpdateWorkQueueWorkQueuesIdPatchUrl = (id: string) => {
	return `http://prefect.grose.click/api/work_queues/${id}`;
};

export const updateWorkQueueWorkQueuesIdPatch = async (
	id: string,
	workQueueUpdate: WorkQueueUpdate,
	options?: RequestInit,
): Promise<updateWorkQueueWorkQueuesIdPatchResponse> => {
	const res = await fetch(getUpdateWorkQueueWorkQueuesIdPatchUrl(id), {
		...options,
		method: "PATCH",
		headers: { "Content-Type": "application/json", ...options?.headers },
		body: JSON.stringify(workQueueUpdate),
	});

	const body = [204, 205, 304].includes(res.status) ? null : await res.text();
	const data: updateWorkQueueWorkQueuesIdPatchResponse["data"] = body
		? JSON.parse(body)
		: {};

	return {
		data,
		status: res.status,
		headers: res.headers,
	} as updateWorkQueueWorkQueuesIdPatchResponse;
};

export const getUpdateWorkQueueWorkQueuesIdPatchMutationOptions = <
	TError = HTTPValidationError,
	TContext = unknown,
>(options?: {
	mutation?: UseMutationOptions<
		Awaited<ReturnType<typeof updateWorkQueueWorkQueuesIdPatch>>,
		TError,
		{ id: string; data: WorkQueueUpdate },
		TContext
	>;
	fetch?: RequestInit;
}): UseMutationOptions<
	Awaited<ReturnType<typeof updateWorkQueueWorkQueuesIdPatch>>,
	TError,
	{ id: string; data: WorkQueueUpdate },
	TContext
> => {
	const mutationKey = ["updateWorkQueueWorkQueuesIdPatch"];
	const { mutation: mutationOptions, fetch: fetchOptions } = options
		? options.mutation &&
			"mutationKey" in options.mutation &&
			options.mutation.mutationKey
			? options
			: { ...options, mutation: { ...options.mutation, mutationKey } }
		: { mutation: { mutationKey }, fetch: undefined };

	const mutationFn: MutationFunction<
		Awaited<ReturnType<typeof updateWorkQueueWorkQueuesIdPatch>>,
		{ id: string; data: WorkQueueUpdate }
	> = (props) => {
		const { id, data } = props ?? {};

		return updateWorkQueueWorkQueuesIdPatch(id, data, fetchOptions);
	};

	return { mutationFn, ...mutationOptions };
};

export type UpdateWorkQueueWorkQueuesIdPatchMutationResult = NonNullable<
	Awaited<ReturnType<typeof updateWorkQueueWorkQueuesIdPatch>>
>;
export type UpdateWorkQueueWorkQueuesIdPatchMutationBody = WorkQueueUpdate;
export type UpdateWorkQueueWorkQueuesIdPatchMutationError = HTTPValidationError;

/**
 * @summary Update Work Queue
 */
export const useUpdateWorkQueueWorkQueuesIdPatch = <
	TError = HTTPValidationError,
	TContext = unknown,
>(options?: {
	mutation?: UseMutationOptions<
		Awaited<ReturnType<typeof updateWorkQueueWorkQueuesIdPatch>>,
		TError,
		{ id: string; data: WorkQueueUpdate },
		TContext
	>;
	fetch?: RequestInit;
}): UseMutationResult<
	Awaited<ReturnType<typeof updateWorkQueueWorkQueuesIdPatch>>,
	TError,
	{ id: string; data: WorkQueueUpdate },
	TContext
> => {
	const mutationOptions =
		getUpdateWorkQueueWorkQueuesIdPatchMutationOptions(options);

	return useMutation(mutationOptions);
};
/**
 * Get a work queue by id.
 * @summary Read Work Queue
 */
export type readWorkQueueWorkQueuesIdGetResponse = {
	data: WorkQueueResponse | HTTPValidationError;
	status: number;
	headers: Headers;
};

export const getReadWorkQueueWorkQueuesIdGetUrl = (id: string) => {
	return `http://prefect.grose.click/api/work_queues/${id}`;
};

export const readWorkQueueWorkQueuesIdGet = async (
	id: string,
	options?: RequestInit,
): Promise<readWorkQueueWorkQueuesIdGetResponse> => {
	const res = await fetch(getReadWorkQueueWorkQueuesIdGetUrl(id), {
		...options,
		method: "GET",
	});

	const body = [204, 205, 304].includes(res.status) ? null : await res.text();
	const data: readWorkQueueWorkQueuesIdGetResponse["data"] = body
		? JSON.parse(body)
		: {};

	return {
		data,
		status: res.status,
		headers: res.headers,
	} as readWorkQueueWorkQueuesIdGetResponse;
};

export const getReadWorkQueueWorkQueuesIdGetQueryKey = (id: string) => {
	return [`http://prefect.grose.click/api/work_queues/${id}`] as const;
};

export const getReadWorkQueueWorkQueuesIdGetQueryOptions = <
	TData = Awaited<ReturnType<typeof readWorkQueueWorkQueuesIdGet>>,
	TError = HTTPValidationError,
>(
	id: string,
	options?: {
		query?: Partial<
			UseQueryOptions<
				Awaited<ReturnType<typeof readWorkQueueWorkQueuesIdGet>>,
				TError,
				TData
			>
		>;
		fetch?: RequestInit;
	},
) => {
	const { query: queryOptions, fetch: fetchOptions } = options ?? {};

	const queryKey =
		queryOptions?.queryKey ?? getReadWorkQueueWorkQueuesIdGetQueryKey(id);

	const queryFn: QueryFunction<
		Awaited<ReturnType<typeof readWorkQueueWorkQueuesIdGet>>
	> = ({ signal }) =>
		readWorkQueueWorkQueuesIdGet(id, { signal, ...fetchOptions });

	return {
		queryKey,
		queryFn,
		enabled: !!id,
		...queryOptions,
	} as UseQueryOptions<
		Awaited<ReturnType<typeof readWorkQueueWorkQueuesIdGet>>,
		TError,
		TData
	> & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type ReadWorkQueueWorkQueuesIdGetQueryResult = NonNullable<
	Awaited<ReturnType<typeof readWorkQueueWorkQueuesIdGet>>
>;
export type ReadWorkQueueWorkQueuesIdGetQueryError = HTTPValidationError;

export function useReadWorkQueueWorkQueuesIdGet<
	TData = Awaited<ReturnType<typeof readWorkQueueWorkQueuesIdGet>>,
	TError = HTTPValidationError,
>(
	id: string,
	options: {
		query: Partial<
			UseQueryOptions<
				Awaited<ReturnType<typeof readWorkQueueWorkQueuesIdGet>>,
				TError,
				TData
			>
		> &
			Pick<
				DefinedInitialDataOptions<
					Awaited<ReturnType<typeof readWorkQueueWorkQueuesIdGet>>,
					TError,
					Awaited<ReturnType<typeof readWorkQueueWorkQueuesIdGet>>
				>,
				"initialData"
			>;
		fetch?: RequestInit;
	},
): DefinedUseQueryResult<TData, TError> & {
	queryKey: DataTag<QueryKey, TData, TError>;
};
export function useReadWorkQueueWorkQueuesIdGet<
	TData = Awaited<ReturnType<typeof readWorkQueueWorkQueuesIdGet>>,
	TError = HTTPValidationError,
>(
	id: string,
	options?: {
		query?: Partial<
			UseQueryOptions<
				Awaited<ReturnType<typeof readWorkQueueWorkQueuesIdGet>>,
				TError,
				TData
			>
		> &
			Pick<
				UndefinedInitialDataOptions<
					Awaited<ReturnType<typeof readWorkQueueWorkQueuesIdGet>>,
					TError,
					Awaited<ReturnType<typeof readWorkQueueWorkQueuesIdGet>>
				>,
				"initialData"
			>;
		fetch?: RequestInit;
	},
): UseQueryResult<TData, TError> & {
	queryKey: DataTag<QueryKey, TData, TError>;
};
export function useReadWorkQueueWorkQueuesIdGet<
	TData = Awaited<ReturnType<typeof readWorkQueueWorkQueuesIdGet>>,
	TError = HTTPValidationError,
>(
	id: string,
	options?: {
		query?: Partial<
			UseQueryOptions<
				Awaited<ReturnType<typeof readWorkQueueWorkQueuesIdGet>>,
				TError,
				TData
			>
		>;
		fetch?: RequestInit;
	},
): UseQueryResult<TData, TError> & {
	queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Read Work Queue
 */

export function useReadWorkQueueWorkQueuesIdGet<
	TData = Awaited<ReturnType<typeof readWorkQueueWorkQueuesIdGet>>,
	TError = HTTPValidationError,
>(
	id: string,
	options?: {
		query?: Partial<
			UseQueryOptions<
				Awaited<ReturnType<typeof readWorkQueueWorkQueuesIdGet>>,
				TError,
				TData
			>
		>;
		fetch?: RequestInit;
	},
): UseQueryResult<TData, TError> & {
	queryKey: DataTag<QueryKey, TData, TError>;
} {
	const queryOptions = getReadWorkQueueWorkQueuesIdGetQueryOptions(id, options);

	const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
		queryKey: DataTag<QueryKey, TData, TError>;
	};

	query.queryKey = queryOptions.queryKey;

	return query;
}

export const getReadWorkQueueWorkQueuesIdGetSuspenseQueryOptions = <
	TData = Awaited<ReturnType<typeof readWorkQueueWorkQueuesIdGet>>,
	TError = HTTPValidationError,
>(
	id: string,
	options?: {
		query?: Partial<
			UseSuspenseQueryOptions<
				Awaited<ReturnType<typeof readWorkQueueWorkQueuesIdGet>>,
				TError,
				TData
			>
		>;
		fetch?: RequestInit;
	},
) => {
	const { query: queryOptions, fetch: fetchOptions } = options ?? {};

	const queryKey =
		queryOptions?.queryKey ?? getReadWorkQueueWorkQueuesIdGetQueryKey(id);

	const queryFn: QueryFunction<
		Awaited<ReturnType<typeof readWorkQueueWorkQueuesIdGet>>
	> = ({ signal }) =>
		readWorkQueueWorkQueuesIdGet(id, { signal, ...fetchOptions });

	return { queryKey, queryFn, ...queryOptions } as UseSuspenseQueryOptions<
		Awaited<ReturnType<typeof readWorkQueueWorkQueuesIdGet>>,
		TError,
		TData
	> & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type ReadWorkQueueWorkQueuesIdGetSuspenseQueryResult = NonNullable<
	Awaited<ReturnType<typeof readWorkQueueWorkQueuesIdGet>>
>;
export type ReadWorkQueueWorkQueuesIdGetSuspenseQueryError =
	HTTPValidationError;

export function useReadWorkQueueWorkQueuesIdGetSuspense<
	TData = Awaited<ReturnType<typeof readWorkQueueWorkQueuesIdGet>>,
	TError = HTTPValidationError,
>(
	id: string,
	options: {
		query: Partial<
			UseSuspenseQueryOptions<
				Awaited<ReturnType<typeof readWorkQueueWorkQueuesIdGet>>,
				TError,
				TData
			>
		>;
		fetch?: RequestInit;
	},
): UseSuspenseQueryResult<TData, TError> & {
	queryKey: DataTag<QueryKey, TData, TError>;
};
export function useReadWorkQueueWorkQueuesIdGetSuspense<
	TData = Awaited<ReturnType<typeof readWorkQueueWorkQueuesIdGet>>,
	TError = HTTPValidationError,
>(
	id: string,
	options?: {
		query?: Partial<
			UseSuspenseQueryOptions<
				Awaited<ReturnType<typeof readWorkQueueWorkQueuesIdGet>>,
				TError,
				TData
			>
		>;
		fetch?: RequestInit;
	},
): UseSuspenseQueryResult<TData, TError> & {
	queryKey: DataTag<QueryKey, TData, TError>;
};
export function useReadWorkQueueWorkQueuesIdGetSuspense<
	TData = Awaited<ReturnType<typeof readWorkQueueWorkQueuesIdGet>>,
	TError = HTTPValidationError,
>(
	id: string,
	options?: {
		query?: Partial<
			UseSuspenseQueryOptions<
				Awaited<ReturnType<typeof readWorkQueueWorkQueuesIdGet>>,
				TError,
				TData
			>
		>;
		fetch?: RequestInit;
	},
): UseSuspenseQueryResult<TData, TError> & {
	queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Read Work Queue
 */

export function useReadWorkQueueWorkQueuesIdGetSuspense<
	TData = Awaited<ReturnType<typeof readWorkQueueWorkQueuesIdGet>>,
	TError = HTTPValidationError,
>(
	id: string,
	options?: {
		query?: Partial<
			UseSuspenseQueryOptions<
				Awaited<ReturnType<typeof readWorkQueueWorkQueuesIdGet>>,
				TError,
				TData
			>
		>;
		fetch?: RequestInit;
	},
): UseSuspenseQueryResult<TData, TError> & {
	queryKey: DataTag<QueryKey, TData, TError>;
} {
	const queryOptions = getReadWorkQueueWorkQueuesIdGetSuspenseQueryOptions(
		id,
		options,
	);

	const query = useSuspenseQuery(queryOptions) as UseSuspenseQueryResult<
		TData,
		TError
	> & { queryKey: DataTag<QueryKey, TData, TError> };

	query.queryKey = queryOptions.queryKey;

	return query;
}

/**
 * Delete a work queue by id.
 * @summary Delete Work Queue
 */
export type deleteWorkQueueWorkQueuesIdDeleteResponse = {
	data: void | HTTPValidationError;
	status: number;
	headers: Headers;
};

export const getDeleteWorkQueueWorkQueuesIdDeleteUrl = (id: string) => {
	return `http://prefect.grose.click/api/work_queues/${id}`;
};

export const deleteWorkQueueWorkQueuesIdDelete = async (
	id: string,
	options?: RequestInit,
): Promise<deleteWorkQueueWorkQueuesIdDeleteResponse> => {
	const res = await fetch(getDeleteWorkQueueWorkQueuesIdDeleteUrl(id), {
		...options,
		method: "DELETE",
	});

	const body = [204, 205, 304].includes(res.status) ? null : await res.text();
	const data: deleteWorkQueueWorkQueuesIdDeleteResponse["data"] = body
		? JSON.parse(body)
		: {};

	return {
		data,
		status: res.status,
		headers: res.headers,
	} as deleteWorkQueueWorkQueuesIdDeleteResponse;
};

export const getDeleteWorkQueueWorkQueuesIdDeleteMutationOptions = <
	TError = HTTPValidationError,
	TContext = unknown,
>(options?: {
	mutation?: UseMutationOptions<
		Awaited<ReturnType<typeof deleteWorkQueueWorkQueuesIdDelete>>,
		TError,
		{ id: string },
		TContext
	>;
	fetch?: RequestInit;
}): UseMutationOptions<
	Awaited<ReturnType<typeof deleteWorkQueueWorkQueuesIdDelete>>,
	TError,
	{ id: string },
	TContext
> => {
	const mutationKey = ["deleteWorkQueueWorkQueuesIdDelete"];
	const { mutation: mutationOptions, fetch: fetchOptions } = options
		? options.mutation &&
			"mutationKey" in options.mutation &&
			options.mutation.mutationKey
			? options
			: { ...options, mutation: { ...options.mutation, mutationKey } }
		: { mutation: { mutationKey }, fetch: undefined };

	const mutationFn: MutationFunction<
		Awaited<ReturnType<typeof deleteWorkQueueWorkQueuesIdDelete>>,
		{ id: string }
	> = (props) => {
		const { id } = props ?? {};

		return deleteWorkQueueWorkQueuesIdDelete(id, fetchOptions);
	};

	return { mutationFn, ...mutationOptions };
};

export type DeleteWorkQueueWorkQueuesIdDeleteMutationResult = NonNullable<
	Awaited<ReturnType<typeof deleteWorkQueueWorkQueuesIdDelete>>
>;

export type DeleteWorkQueueWorkQueuesIdDeleteMutationError =
	HTTPValidationError;

/**
 * @summary Delete Work Queue
 */
export const useDeleteWorkQueueWorkQueuesIdDelete = <
	TError = HTTPValidationError,
	TContext = unknown,
>(options?: {
	mutation?: UseMutationOptions<
		Awaited<ReturnType<typeof deleteWorkQueueWorkQueuesIdDelete>>,
		TError,
		{ id: string },
		TContext
	>;
	fetch?: RequestInit;
}): UseMutationResult<
	Awaited<ReturnType<typeof deleteWorkQueueWorkQueuesIdDelete>>,
	TError,
	{ id: string },
	TContext
> => {
	const mutationOptions =
		getDeleteWorkQueueWorkQueuesIdDeleteMutationOptions(options);

	return useMutation(mutationOptions);
};
/**
 * Get a work queue by id.
 * @summary Read Work Queue By Name
 */
export type readWorkQueueByNameWorkQueuesNameNameGetResponse = {
	data: WorkQueueResponse | HTTPValidationError;
	status: number;
	headers: Headers;
};

export const getReadWorkQueueByNameWorkQueuesNameNameGetUrl = (
	name: string,
) => {
	return `http://prefect.grose.click/api/work_queues/name/${name}`;
};

export const readWorkQueueByNameWorkQueuesNameNameGet = async (
	name: string,
	options?: RequestInit,
): Promise<readWorkQueueByNameWorkQueuesNameNameGetResponse> => {
	const res = await fetch(
		getReadWorkQueueByNameWorkQueuesNameNameGetUrl(name),
		{
			...options,
			method: "GET",
		},
	);

	const body = [204, 205, 304].includes(res.status) ? null : await res.text();
	const data: readWorkQueueByNameWorkQueuesNameNameGetResponse["data"] = body
		? JSON.parse(body)
		: {};

	return {
		data,
		status: res.status,
		headers: res.headers,
	} as readWorkQueueByNameWorkQueuesNameNameGetResponse;
};

export const getReadWorkQueueByNameWorkQueuesNameNameGetQueryKey = (
	name: string,
) => {
	return [`http://prefect.grose.click/api/work_queues/name/${name}`] as const;
};

export const getReadWorkQueueByNameWorkQueuesNameNameGetQueryOptions = <
	TData = Awaited<ReturnType<typeof readWorkQueueByNameWorkQueuesNameNameGet>>,
	TError = HTTPValidationError,
>(
	name: string,
	options?: {
		query?: Partial<
			UseQueryOptions<
				Awaited<ReturnType<typeof readWorkQueueByNameWorkQueuesNameNameGet>>,
				TError,
				TData
			>
		>;
		fetch?: RequestInit;
	},
) => {
	const { query: queryOptions, fetch: fetchOptions } = options ?? {};

	const queryKey =
		queryOptions?.queryKey ??
		getReadWorkQueueByNameWorkQueuesNameNameGetQueryKey(name);

	const queryFn: QueryFunction<
		Awaited<ReturnType<typeof readWorkQueueByNameWorkQueuesNameNameGet>>
	> = ({ signal }) =>
		readWorkQueueByNameWorkQueuesNameNameGet(name, { signal, ...fetchOptions });

	return {
		queryKey,
		queryFn,
		enabled: !!name,
		...queryOptions,
	} as UseQueryOptions<
		Awaited<ReturnType<typeof readWorkQueueByNameWorkQueuesNameNameGet>>,
		TError,
		TData
	> & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type ReadWorkQueueByNameWorkQueuesNameNameGetQueryResult = NonNullable<
	Awaited<ReturnType<typeof readWorkQueueByNameWorkQueuesNameNameGet>>
>;
export type ReadWorkQueueByNameWorkQueuesNameNameGetQueryError =
	HTTPValidationError;

export function useReadWorkQueueByNameWorkQueuesNameNameGet<
	TData = Awaited<ReturnType<typeof readWorkQueueByNameWorkQueuesNameNameGet>>,
	TError = HTTPValidationError,
>(
	name: string,
	options: {
		query: Partial<
			UseQueryOptions<
				Awaited<ReturnType<typeof readWorkQueueByNameWorkQueuesNameNameGet>>,
				TError,
				TData
			>
		> &
			Pick<
				DefinedInitialDataOptions<
					Awaited<ReturnType<typeof readWorkQueueByNameWorkQueuesNameNameGet>>,
					TError,
					Awaited<ReturnType<typeof readWorkQueueByNameWorkQueuesNameNameGet>>
				>,
				"initialData"
			>;
		fetch?: RequestInit;
	},
): DefinedUseQueryResult<TData, TError> & {
	queryKey: DataTag<QueryKey, TData, TError>;
};
export function useReadWorkQueueByNameWorkQueuesNameNameGet<
	TData = Awaited<ReturnType<typeof readWorkQueueByNameWorkQueuesNameNameGet>>,
	TError = HTTPValidationError,
>(
	name: string,
	options?: {
		query?: Partial<
			UseQueryOptions<
				Awaited<ReturnType<typeof readWorkQueueByNameWorkQueuesNameNameGet>>,
				TError,
				TData
			>
		> &
			Pick<
				UndefinedInitialDataOptions<
					Awaited<ReturnType<typeof readWorkQueueByNameWorkQueuesNameNameGet>>,
					TError,
					Awaited<ReturnType<typeof readWorkQueueByNameWorkQueuesNameNameGet>>
				>,
				"initialData"
			>;
		fetch?: RequestInit;
	},
): UseQueryResult<TData, TError> & {
	queryKey: DataTag<QueryKey, TData, TError>;
};
export function useReadWorkQueueByNameWorkQueuesNameNameGet<
	TData = Awaited<ReturnType<typeof readWorkQueueByNameWorkQueuesNameNameGet>>,
	TError = HTTPValidationError,
>(
	name: string,
	options?: {
		query?: Partial<
			UseQueryOptions<
				Awaited<ReturnType<typeof readWorkQueueByNameWorkQueuesNameNameGet>>,
				TError,
				TData
			>
		>;
		fetch?: RequestInit;
	},
): UseQueryResult<TData, TError> & {
	queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Read Work Queue By Name
 */

export function useReadWorkQueueByNameWorkQueuesNameNameGet<
	TData = Awaited<ReturnType<typeof readWorkQueueByNameWorkQueuesNameNameGet>>,
	TError = HTTPValidationError,
>(
	name: string,
	options?: {
		query?: Partial<
			UseQueryOptions<
				Awaited<ReturnType<typeof readWorkQueueByNameWorkQueuesNameNameGet>>,
				TError,
				TData
			>
		>;
		fetch?: RequestInit;
	},
): UseQueryResult<TData, TError> & {
	queryKey: DataTag<QueryKey, TData, TError>;
} {
	const queryOptions = getReadWorkQueueByNameWorkQueuesNameNameGetQueryOptions(
		name,
		options,
	);

	const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
		queryKey: DataTag<QueryKey, TData, TError>;
	};

	query.queryKey = queryOptions.queryKey;

	return query;
}

export const getReadWorkQueueByNameWorkQueuesNameNameGetSuspenseQueryOptions = <
	TData = Awaited<ReturnType<typeof readWorkQueueByNameWorkQueuesNameNameGet>>,
	TError = HTTPValidationError,
>(
	name: string,
	options?: {
		query?: Partial<
			UseSuspenseQueryOptions<
				Awaited<ReturnType<typeof readWorkQueueByNameWorkQueuesNameNameGet>>,
				TError,
				TData
			>
		>;
		fetch?: RequestInit;
	},
) => {
	const { query: queryOptions, fetch: fetchOptions } = options ?? {};

	const queryKey =
		queryOptions?.queryKey ??
		getReadWorkQueueByNameWorkQueuesNameNameGetQueryKey(name);

	const queryFn: QueryFunction<
		Awaited<ReturnType<typeof readWorkQueueByNameWorkQueuesNameNameGet>>
	> = ({ signal }) =>
		readWorkQueueByNameWorkQueuesNameNameGet(name, { signal, ...fetchOptions });

	return { queryKey, queryFn, ...queryOptions } as UseSuspenseQueryOptions<
		Awaited<ReturnType<typeof readWorkQueueByNameWorkQueuesNameNameGet>>,
		TError,
		TData
	> & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type ReadWorkQueueByNameWorkQueuesNameNameGetSuspenseQueryResult =
	NonNullable<
		Awaited<ReturnType<typeof readWorkQueueByNameWorkQueuesNameNameGet>>
	>;
export type ReadWorkQueueByNameWorkQueuesNameNameGetSuspenseQueryError =
	HTTPValidationError;

export function useReadWorkQueueByNameWorkQueuesNameNameGetSuspense<
	TData = Awaited<ReturnType<typeof readWorkQueueByNameWorkQueuesNameNameGet>>,
	TError = HTTPValidationError,
>(
	name: string,
	options: {
		query: Partial<
			UseSuspenseQueryOptions<
				Awaited<ReturnType<typeof readWorkQueueByNameWorkQueuesNameNameGet>>,
				TError,
				TData
			>
		>;
		fetch?: RequestInit;
	},
): UseSuspenseQueryResult<TData, TError> & {
	queryKey: DataTag<QueryKey, TData, TError>;
};
export function useReadWorkQueueByNameWorkQueuesNameNameGetSuspense<
	TData = Awaited<ReturnType<typeof readWorkQueueByNameWorkQueuesNameNameGet>>,
	TError = HTTPValidationError,
>(
	name: string,
	options?: {
		query?: Partial<
			UseSuspenseQueryOptions<
				Awaited<ReturnType<typeof readWorkQueueByNameWorkQueuesNameNameGet>>,
				TError,
				TData
			>
		>;
		fetch?: RequestInit;
	},
): UseSuspenseQueryResult<TData, TError> & {
	queryKey: DataTag<QueryKey, TData, TError>;
};
export function useReadWorkQueueByNameWorkQueuesNameNameGetSuspense<
	TData = Awaited<ReturnType<typeof readWorkQueueByNameWorkQueuesNameNameGet>>,
	TError = HTTPValidationError,
>(
	name: string,
	options?: {
		query?: Partial<
			UseSuspenseQueryOptions<
				Awaited<ReturnType<typeof readWorkQueueByNameWorkQueuesNameNameGet>>,
				TError,
				TData
			>
		>;
		fetch?: RequestInit;
	},
): UseSuspenseQueryResult<TData, TError> & {
	queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Read Work Queue By Name
 */

export function useReadWorkQueueByNameWorkQueuesNameNameGetSuspense<
	TData = Awaited<ReturnType<typeof readWorkQueueByNameWorkQueuesNameNameGet>>,
	TError = HTTPValidationError,
>(
	name: string,
	options?: {
		query?: Partial<
			UseSuspenseQueryOptions<
				Awaited<ReturnType<typeof readWorkQueueByNameWorkQueuesNameNameGet>>,
				TError,
				TData
			>
		>;
		fetch?: RequestInit;
	},
): UseSuspenseQueryResult<TData, TError> & {
	queryKey: DataTag<QueryKey, TData, TError>;
} {
	const queryOptions =
		getReadWorkQueueByNameWorkQueuesNameNameGetSuspenseQueryOptions(
			name,
			options,
		);

	const query = useSuspenseQuery(queryOptions) as UseSuspenseQueryResult<
		TData,
		TError
	> & { queryKey: DataTag<QueryKey, TData, TError> };

	query.queryKey = queryOptions.queryKey;

	return query;
}

/**
 * Get flow runs from the work queue.
 * @summary Read Work Queue Runs
 */
export type readWorkQueueRunsWorkQueuesIdGetRunsPostResponse = {
	data: FlowRunResponse[] | HTTPValidationError;
	status: number;
	headers: Headers;
};

export const getReadWorkQueueRunsWorkQueuesIdGetRunsPostUrl = (id: string) => {
	return `http://prefect.grose.click/api/work_queues/${id}/get_runs`;
};

export const readWorkQueueRunsWorkQueuesIdGetRunsPost = async (
	id: string,
	bodyReadWorkQueueRunsWorkQueuesIdGetRunsPost: BodyReadWorkQueueRunsWorkQueuesIdGetRunsPost,
	options?: RequestInit,
): Promise<readWorkQueueRunsWorkQueuesIdGetRunsPostResponse> => {
	const res = await fetch(getReadWorkQueueRunsWorkQueuesIdGetRunsPostUrl(id), {
		...options,
		method: "POST",
		headers: { "Content-Type": "application/json", ...options?.headers },
		body: JSON.stringify(bodyReadWorkQueueRunsWorkQueuesIdGetRunsPost),
	});

	const body = [204, 205, 304].includes(res.status) ? null : await res.text();
	const data: readWorkQueueRunsWorkQueuesIdGetRunsPostResponse["data"] = body
		? JSON.parse(body)
		: {};

	return {
		data,
		status: res.status,
		headers: res.headers,
	} as readWorkQueueRunsWorkQueuesIdGetRunsPostResponse;
};

export const getReadWorkQueueRunsWorkQueuesIdGetRunsPostMutationOptions = <
	TError = HTTPValidationError,
	TContext = unknown,
>(options?: {
	mutation?: UseMutationOptions<
		Awaited<ReturnType<typeof readWorkQueueRunsWorkQueuesIdGetRunsPost>>,
		TError,
		{ id: string; data: BodyReadWorkQueueRunsWorkQueuesIdGetRunsPost },
		TContext
	>;
	fetch?: RequestInit;
}): UseMutationOptions<
	Awaited<ReturnType<typeof readWorkQueueRunsWorkQueuesIdGetRunsPost>>,
	TError,
	{ id: string; data: BodyReadWorkQueueRunsWorkQueuesIdGetRunsPost },
	TContext
> => {
	const mutationKey = ["readWorkQueueRunsWorkQueuesIdGetRunsPost"];
	const { mutation: mutationOptions, fetch: fetchOptions } = options
		? options.mutation &&
			"mutationKey" in options.mutation &&
			options.mutation.mutationKey
			? options
			: { ...options, mutation: { ...options.mutation, mutationKey } }
		: { mutation: { mutationKey }, fetch: undefined };

	const mutationFn: MutationFunction<
		Awaited<ReturnType<typeof readWorkQueueRunsWorkQueuesIdGetRunsPost>>,
		{ id: string; data: BodyReadWorkQueueRunsWorkQueuesIdGetRunsPost }
	> = (props) => {
		const { id, data } = props ?? {};

		return readWorkQueueRunsWorkQueuesIdGetRunsPost(id, data, fetchOptions);
	};

	return { mutationFn, ...mutationOptions };
};

export type ReadWorkQueueRunsWorkQueuesIdGetRunsPostMutationResult =
	NonNullable<
		Awaited<ReturnType<typeof readWorkQueueRunsWorkQueuesIdGetRunsPost>>
	>;
export type ReadWorkQueueRunsWorkQueuesIdGetRunsPostMutationBody =
	BodyReadWorkQueueRunsWorkQueuesIdGetRunsPost;
export type ReadWorkQueueRunsWorkQueuesIdGetRunsPostMutationError =
	HTTPValidationError;

/**
 * @summary Read Work Queue Runs
 */
export const useReadWorkQueueRunsWorkQueuesIdGetRunsPost = <
	TError = HTTPValidationError,
	TContext = unknown,
>(options?: {
	mutation?: UseMutationOptions<
		Awaited<ReturnType<typeof readWorkQueueRunsWorkQueuesIdGetRunsPost>>,
		TError,
		{ id: string; data: BodyReadWorkQueueRunsWorkQueuesIdGetRunsPost },
		TContext
	>;
	fetch?: RequestInit;
}): UseMutationResult<
	Awaited<ReturnType<typeof readWorkQueueRunsWorkQueuesIdGetRunsPost>>,
	TError,
	{ id: string; data: BodyReadWorkQueueRunsWorkQueuesIdGetRunsPost },
	TContext
> => {
	const mutationOptions =
		getReadWorkQueueRunsWorkQueuesIdGetRunsPostMutationOptions(options);

	return useMutation(mutationOptions);
};
/**
 * Query for work queues.
 * @summary Read Work Queues
 */
export type readWorkQueuesWorkQueuesFilterPostResponse = {
	data: WorkQueueResponse[] | HTTPValidationError;
	status: number;
	headers: Headers;
};

export const getReadWorkQueuesWorkQueuesFilterPostUrl = () => {
	return `http://prefect.grose.click/api/work_queues/filter`;
};

export const readWorkQueuesWorkQueuesFilterPost = async (
	bodyReadWorkQueuesWorkQueuesFilterPost: BodyReadWorkQueuesWorkQueuesFilterPost,
	options?: RequestInit,
): Promise<readWorkQueuesWorkQueuesFilterPostResponse> => {
	const res = await fetch(getReadWorkQueuesWorkQueuesFilterPostUrl(), {
		...options,
		method: "POST",
		headers: { "Content-Type": "application/json", ...options?.headers },
		body: JSON.stringify(bodyReadWorkQueuesWorkQueuesFilterPost),
	});

	const body = [204, 205, 304].includes(res.status) ? null : await res.text();
	const data: readWorkQueuesWorkQueuesFilterPostResponse["data"] = body
		? JSON.parse(body)
		: {};

	return {
		data,
		status: res.status,
		headers: res.headers,
	} as readWorkQueuesWorkQueuesFilterPostResponse;
};

export const getReadWorkQueuesWorkQueuesFilterPostMutationOptions = <
	TError = HTTPValidationError,
	TContext = unknown,
>(options?: {
	mutation?: UseMutationOptions<
		Awaited<ReturnType<typeof readWorkQueuesWorkQueuesFilterPost>>,
		TError,
		{ data: BodyReadWorkQueuesWorkQueuesFilterPost },
		TContext
	>;
	fetch?: RequestInit;
}): UseMutationOptions<
	Awaited<ReturnType<typeof readWorkQueuesWorkQueuesFilterPost>>,
	TError,
	{ data: BodyReadWorkQueuesWorkQueuesFilterPost },
	TContext
> => {
	const mutationKey = ["readWorkQueuesWorkQueuesFilterPost"];
	const { mutation: mutationOptions, fetch: fetchOptions } = options
		? options.mutation &&
			"mutationKey" in options.mutation &&
			options.mutation.mutationKey
			? options
			: { ...options, mutation: { ...options.mutation, mutationKey } }
		: { mutation: { mutationKey }, fetch: undefined };

	const mutationFn: MutationFunction<
		Awaited<ReturnType<typeof readWorkQueuesWorkQueuesFilterPost>>,
		{ data: BodyReadWorkQueuesWorkQueuesFilterPost }
	> = (props) => {
		const { data } = props ?? {};

		return readWorkQueuesWorkQueuesFilterPost(data, fetchOptions);
	};

	return { mutationFn, ...mutationOptions };
};

export type ReadWorkQueuesWorkQueuesFilterPostMutationResult = NonNullable<
	Awaited<ReturnType<typeof readWorkQueuesWorkQueuesFilterPost>>
>;
export type ReadWorkQueuesWorkQueuesFilterPostMutationBody =
	BodyReadWorkQueuesWorkQueuesFilterPost;
export type ReadWorkQueuesWorkQueuesFilterPostMutationError =
	HTTPValidationError;

/**
 * @summary Read Work Queues
 */
export const useReadWorkQueuesWorkQueuesFilterPost = <
	TError = HTTPValidationError,
	TContext = unknown,
>(options?: {
	mutation?: UseMutationOptions<
		Awaited<ReturnType<typeof readWorkQueuesWorkQueuesFilterPost>>,
		TError,
		{ data: BodyReadWorkQueuesWorkQueuesFilterPost },
		TContext
	>;
	fetch?: RequestInit;
}): UseMutationResult<
	Awaited<ReturnType<typeof readWorkQueuesWorkQueuesFilterPost>>,
	TError,
	{ data: BodyReadWorkQueuesWorkQueuesFilterPost },
	TContext
> => {
	const mutationOptions =
		getReadWorkQueuesWorkQueuesFilterPostMutationOptions(options);

	return useMutation(mutationOptions);
};
/**
 * Get the status of a work queue.
 * @summary Read Work Queue Status
 */
export type readWorkQueueStatusWorkQueuesIdStatusGetResponse = {
	data: WorkQueueStatusDetail | HTTPValidationError;
	status: number;
	headers: Headers;
};

export const getReadWorkQueueStatusWorkQueuesIdStatusGetUrl = (id: string) => {
	return `http://prefect.grose.click/api/work_queues/${id}/status`;
};

export const readWorkQueueStatusWorkQueuesIdStatusGet = async (
	id: string,
	options?: RequestInit,
): Promise<readWorkQueueStatusWorkQueuesIdStatusGetResponse> => {
	const res = await fetch(getReadWorkQueueStatusWorkQueuesIdStatusGetUrl(id), {
		...options,
		method: "GET",
	});

	const body = [204, 205, 304].includes(res.status) ? null : await res.text();
	const data: readWorkQueueStatusWorkQueuesIdStatusGetResponse["data"] = body
		? JSON.parse(body)
		: {};

	return {
		data,
		status: res.status,
		headers: res.headers,
	} as readWorkQueueStatusWorkQueuesIdStatusGetResponse;
};

export const getReadWorkQueueStatusWorkQueuesIdStatusGetQueryKey = (
	id: string,
) => {
	return [`http://prefect.grose.click/api/work_queues/${id}/status`] as const;
};

export const getReadWorkQueueStatusWorkQueuesIdStatusGetQueryOptions = <
	TData = Awaited<ReturnType<typeof readWorkQueueStatusWorkQueuesIdStatusGet>>,
	TError = HTTPValidationError,
>(
	id: string,
	options?: {
		query?: Partial<
			UseQueryOptions<
				Awaited<ReturnType<typeof readWorkQueueStatusWorkQueuesIdStatusGet>>,
				TError,
				TData
			>
		>;
		fetch?: RequestInit;
	},
) => {
	const { query: queryOptions, fetch: fetchOptions } = options ?? {};

	const queryKey =
		queryOptions?.queryKey ??
		getReadWorkQueueStatusWorkQueuesIdStatusGetQueryKey(id);

	const queryFn: QueryFunction<
		Awaited<ReturnType<typeof readWorkQueueStatusWorkQueuesIdStatusGet>>
	> = ({ signal }) =>
		readWorkQueueStatusWorkQueuesIdStatusGet(id, { signal, ...fetchOptions });

	return {
		queryKey,
		queryFn,
		enabled: !!id,
		...queryOptions,
	} as UseQueryOptions<
		Awaited<ReturnType<typeof readWorkQueueStatusWorkQueuesIdStatusGet>>,
		TError,
		TData
	> & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type ReadWorkQueueStatusWorkQueuesIdStatusGetQueryResult = NonNullable<
	Awaited<ReturnType<typeof readWorkQueueStatusWorkQueuesIdStatusGet>>
>;
export type ReadWorkQueueStatusWorkQueuesIdStatusGetQueryError =
	HTTPValidationError;

export function useReadWorkQueueStatusWorkQueuesIdStatusGet<
	TData = Awaited<ReturnType<typeof readWorkQueueStatusWorkQueuesIdStatusGet>>,
	TError = HTTPValidationError,
>(
	id: string,
	options: {
		query: Partial<
			UseQueryOptions<
				Awaited<ReturnType<typeof readWorkQueueStatusWorkQueuesIdStatusGet>>,
				TError,
				TData
			>
		> &
			Pick<
				DefinedInitialDataOptions<
					Awaited<ReturnType<typeof readWorkQueueStatusWorkQueuesIdStatusGet>>,
					TError,
					Awaited<ReturnType<typeof readWorkQueueStatusWorkQueuesIdStatusGet>>
				>,
				"initialData"
			>;
		fetch?: RequestInit;
	},
): DefinedUseQueryResult<TData, TError> & {
	queryKey: DataTag<QueryKey, TData, TError>;
};
export function useReadWorkQueueStatusWorkQueuesIdStatusGet<
	TData = Awaited<ReturnType<typeof readWorkQueueStatusWorkQueuesIdStatusGet>>,
	TError = HTTPValidationError,
>(
	id: string,
	options?: {
		query?: Partial<
			UseQueryOptions<
				Awaited<ReturnType<typeof readWorkQueueStatusWorkQueuesIdStatusGet>>,
				TError,
				TData
			>
		> &
			Pick<
				UndefinedInitialDataOptions<
					Awaited<ReturnType<typeof readWorkQueueStatusWorkQueuesIdStatusGet>>,
					TError,
					Awaited<ReturnType<typeof readWorkQueueStatusWorkQueuesIdStatusGet>>
				>,
				"initialData"
			>;
		fetch?: RequestInit;
	},
): UseQueryResult<TData, TError> & {
	queryKey: DataTag<QueryKey, TData, TError>;
};
export function useReadWorkQueueStatusWorkQueuesIdStatusGet<
	TData = Awaited<ReturnType<typeof readWorkQueueStatusWorkQueuesIdStatusGet>>,
	TError = HTTPValidationError,
>(
	id: string,
	options?: {
		query?: Partial<
			UseQueryOptions<
				Awaited<ReturnType<typeof readWorkQueueStatusWorkQueuesIdStatusGet>>,
				TError,
				TData
			>
		>;
		fetch?: RequestInit;
	},
): UseQueryResult<TData, TError> & {
	queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Read Work Queue Status
 */

export function useReadWorkQueueStatusWorkQueuesIdStatusGet<
	TData = Awaited<ReturnType<typeof readWorkQueueStatusWorkQueuesIdStatusGet>>,
	TError = HTTPValidationError,
>(
	id: string,
	options?: {
		query?: Partial<
			UseQueryOptions<
				Awaited<ReturnType<typeof readWorkQueueStatusWorkQueuesIdStatusGet>>,
				TError,
				TData
			>
		>;
		fetch?: RequestInit;
	},
): UseQueryResult<TData, TError> & {
	queryKey: DataTag<QueryKey, TData, TError>;
} {
	const queryOptions = getReadWorkQueueStatusWorkQueuesIdStatusGetQueryOptions(
		id,
		options,
	);

	const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
		queryKey: DataTag<QueryKey, TData, TError>;
	};

	query.queryKey = queryOptions.queryKey;

	return query;
}

export const getReadWorkQueueStatusWorkQueuesIdStatusGetSuspenseQueryOptions = <
	TData = Awaited<ReturnType<typeof readWorkQueueStatusWorkQueuesIdStatusGet>>,
	TError = HTTPValidationError,
>(
	id: string,
	options?: {
		query?: Partial<
			UseSuspenseQueryOptions<
				Awaited<ReturnType<typeof readWorkQueueStatusWorkQueuesIdStatusGet>>,
				TError,
				TData
			>
		>;
		fetch?: RequestInit;
	},
) => {
	const { query: queryOptions, fetch: fetchOptions } = options ?? {};

	const queryKey =
		queryOptions?.queryKey ??
		getReadWorkQueueStatusWorkQueuesIdStatusGetQueryKey(id);

	const queryFn: QueryFunction<
		Awaited<ReturnType<typeof readWorkQueueStatusWorkQueuesIdStatusGet>>
	> = ({ signal }) =>
		readWorkQueueStatusWorkQueuesIdStatusGet(id, { signal, ...fetchOptions });

	return { queryKey, queryFn, ...queryOptions } as UseSuspenseQueryOptions<
		Awaited<ReturnType<typeof readWorkQueueStatusWorkQueuesIdStatusGet>>,
		TError,
		TData
	> & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type ReadWorkQueueStatusWorkQueuesIdStatusGetSuspenseQueryResult =
	NonNullable<
		Awaited<ReturnType<typeof readWorkQueueStatusWorkQueuesIdStatusGet>>
	>;
export type ReadWorkQueueStatusWorkQueuesIdStatusGetSuspenseQueryError =
	HTTPValidationError;

export function useReadWorkQueueStatusWorkQueuesIdStatusGetSuspense<
	TData = Awaited<ReturnType<typeof readWorkQueueStatusWorkQueuesIdStatusGet>>,
	TError = HTTPValidationError,
>(
	id: string,
	options: {
		query: Partial<
			UseSuspenseQueryOptions<
				Awaited<ReturnType<typeof readWorkQueueStatusWorkQueuesIdStatusGet>>,
				TError,
				TData
			>
		>;
		fetch?: RequestInit;
	},
): UseSuspenseQueryResult<TData, TError> & {
	queryKey: DataTag<QueryKey, TData, TError>;
};
export function useReadWorkQueueStatusWorkQueuesIdStatusGetSuspense<
	TData = Awaited<ReturnType<typeof readWorkQueueStatusWorkQueuesIdStatusGet>>,
	TError = HTTPValidationError,
>(
	id: string,
	options?: {
		query?: Partial<
			UseSuspenseQueryOptions<
				Awaited<ReturnType<typeof readWorkQueueStatusWorkQueuesIdStatusGet>>,
				TError,
				TData
			>
		>;
		fetch?: RequestInit;
	},
): UseSuspenseQueryResult<TData, TError> & {
	queryKey: DataTag<QueryKey, TData, TError>;
};
export function useReadWorkQueueStatusWorkQueuesIdStatusGetSuspense<
	TData = Awaited<ReturnType<typeof readWorkQueueStatusWorkQueuesIdStatusGet>>,
	TError = HTTPValidationError,
>(
	id: string,
	options?: {
		query?: Partial<
			UseSuspenseQueryOptions<
				Awaited<ReturnType<typeof readWorkQueueStatusWorkQueuesIdStatusGet>>,
				TError,
				TData
			>
		>;
		fetch?: RequestInit;
	},
): UseSuspenseQueryResult<TData, TError> & {
	queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Read Work Queue Status
 */

export function useReadWorkQueueStatusWorkQueuesIdStatusGetSuspense<
	TData = Awaited<ReturnType<typeof readWorkQueueStatusWorkQueuesIdStatusGet>>,
	TError = HTTPValidationError,
>(
	id: string,
	options?: {
		query?: Partial<
			UseSuspenseQueryOptions<
				Awaited<ReturnType<typeof readWorkQueueStatusWorkQueuesIdStatusGet>>,
				TError,
				TData
			>
		>;
		fetch?: RequestInit;
	},
): UseSuspenseQueryResult<TData, TError> & {
	queryKey: DataTag<QueryKey, TData, TError>;
} {
	const queryOptions =
		getReadWorkQueueStatusWorkQueuesIdStatusGetSuspenseQueryOptions(
			id,
			options,
		);

	const query = useSuspenseQuery(queryOptions) as UseSuspenseQueryResult<
		TData,
		TError
	> & { queryKey: DataTag<QueryKey, TData, TError> };

	query.queryKey = queryOptions.queryKey;

	return query;
}
