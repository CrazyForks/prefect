/**
 * Generated by orval v7.5.0 🍺
 * Do not edit manually.
 * Prefect Prefect REST API
 * OpenAPI spec version: 0.1.0
 */
import { useMutation, useQuery, useSuspenseQuery } from "@tanstack/react-query";
import type {
	DataTag,
	DefinedInitialDataOptions,
	DefinedUseQueryResult,
	MutationFunction,
	QueryFunction,
	QueryKey,
	UndefinedInitialDataOptions,
	UseMutationOptions,
	UseMutationResult,
	UseQueryOptions,
	UseQueryResult,
	UseSuspenseQueryOptions,
	UseSuspenseQueryResult,
} from "@tanstack/react-query";
import type {
	BodyBulkDecrementActiveSlotsV2ConcurrencyLimitsDecrementPost,
	BodyBulkIncrementActiveSlotsV2ConcurrencyLimitsIncrementPost,
	BodyReadAllConcurrencyLimitsV2V2ConcurrencyLimitsFilterPost,
	ConcurrencyLimitV2,
	ConcurrencyLimitV2Create,
	ConcurrencyLimitV2Update,
	GlobalConcurrencyLimitResponse,
	HTTPValidationError,
	MinimalConcurrencyLimitResponse,
} from "../../models";

/**
 * @summary Create Concurrency Limit V2
 */
export type createConcurrencyLimitV2V2ConcurrencyLimitsPostResponse = {
	data: ConcurrencyLimitV2 | HTTPValidationError;
	status: number;
	headers: Headers;
};

export const getCreateConcurrencyLimitV2V2ConcurrencyLimitsPostUrl = () => {
	return `http://prefect.grose.click/api/v2/concurrency_limits/`;
};

export const createConcurrencyLimitV2V2ConcurrencyLimitsPost = async (
	concurrencyLimitV2Create: ConcurrencyLimitV2Create,
	options?: RequestInit,
): Promise<createConcurrencyLimitV2V2ConcurrencyLimitsPostResponse> => {
	const res = await fetch(
		getCreateConcurrencyLimitV2V2ConcurrencyLimitsPostUrl(),
		{
			...options,
			method: "POST",
			headers: { "Content-Type": "application/json", ...options?.headers },
			body: JSON.stringify(concurrencyLimitV2Create),
		},
	);

	const body = [204, 205, 304].includes(res.status) ? null : await res.text();
	const data: createConcurrencyLimitV2V2ConcurrencyLimitsPostResponse["data"] =
		body ? JSON.parse(body) : {};

	return {
		data,
		status: res.status,
		headers: res.headers,
	} as createConcurrencyLimitV2V2ConcurrencyLimitsPostResponse;
};

export const getCreateConcurrencyLimitV2V2ConcurrencyLimitsPostMutationOptions =
	<TError = HTTPValidationError, TContext = unknown>(options?: {
		mutation?: UseMutationOptions<
			Awaited<
				ReturnType<typeof createConcurrencyLimitV2V2ConcurrencyLimitsPost>
			>,
			TError,
			{ data: ConcurrencyLimitV2Create },
			TContext
		>;
		fetch?: RequestInit;
	}): UseMutationOptions<
		Awaited<ReturnType<typeof createConcurrencyLimitV2V2ConcurrencyLimitsPost>>,
		TError,
		{ data: ConcurrencyLimitV2Create },
		TContext
	> => {
		const mutationKey = ["createConcurrencyLimitV2V2ConcurrencyLimitsPost"];
		const { mutation: mutationOptions, fetch: fetchOptions } = options
			? options.mutation &&
				"mutationKey" in options.mutation &&
				options.mutation.mutationKey
				? options
				: { ...options, mutation: { ...options.mutation, mutationKey } }
			: { mutation: { mutationKey }, fetch: undefined };

		const mutationFn: MutationFunction<
			Awaited<
				ReturnType<typeof createConcurrencyLimitV2V2ConcurrencyLimitsPost>
			>,
			{ data: ConcurrencyLimitV2Create }
		> = (props) => {
			const { data } = props ?? {};

			return createConcurrencyLimitV2V2ConcurrencyLimitsPost(
				data,
				fetchOptions,
			);
		};

		return { mutationFn, ...mutationOptions };
	};

export type CreateConcurrencyLimitV2V2ConcurrencyLimitsPostMutationResult =
	NonNullable<
		Awaited<ReturnType<typeof createConcurrencyLimitV2V2ConcurrencyLimitsPost>>
	>;
export type CreateConcurrencyLimitV2V2ConcurrencyLimitsPostMutationBody =
	ConcurrencyLimitV2Create;
export type CreateConcurrencyLimitV2V2ConcurrencyLimitsPostMutationError =
	HTTPValidationError;

/**
 * @summary Create Concurrency Limit V2
 */
export const useCreateConcurrencyLimitV2V2ConcurrencyLimitsPost = <
	TError = HTTPValidationError,
	TContext = unknown,
>(options?: {
	mutation?: UseMutationOptions<
		Awaited<ReturnType<typeof createConcurrencyLimitV2V2ConcurrencyLimitsPost>>,
		TError,
		{ data: ConcurrencyLimitV2Create },
		TContext
	>;
	fetch?: RequestInit;
}): UseMutationResult<
	Awaited<ReturnType<typeof createConcurrencyLimitV2V2ConcurrencyLimitsPost>>,
	TError,
	{ data: ConcurrencyLimitV2Create },
	TContext
> => {
	const mutationOptions =
		getCreateConcurrencyLimitV2V2ConcurrencyLimitsPostMutationOptions(options);

	return useMutation(mutationOptions);
};
/**
 * @summary Read Concurrency Limit V2
 */
export type readConcurrencyLimitV2V2ConcurrencyLimitsIdOrNameGetResponse = {
	data: GlobalConcurrencyLimitResponse | HTTPValidationError;
	status: number;
	headers: Headers;
};

export const getReadConcurrencyLimitV2V2ConcurrencyLimitsIdOrNameGetUrl = (
	idOrName: string | string,
) => {
	return `http://prefect.grose.click/api/v2/concurrency_limits/${idOrName}`;
};

export const readConcurrencyLimitV2V2ConcurrencyLimitsIdOrNameGet = async (
	idOrName: string | string,
	options?: RequestInit,
): Promise<readConcurrencyLimitV2V2ConcurrencyLimitsIdOrNameGetResponse> => {
	const res = await fetch(
		getReadConcurrencyLimitV2V2ConcurrencyLimitsIdOrNameGetUrl(idOrName),
		{
			...options,
			method: "GET",
		},
	);

	const body = [204, 205, 304].includes(res.status) ? null : await res.text();
	const data: readConcurrencyLimitV2V2ConcurrencyLimitsIdOrNameGetResponse["data"] =
		body ? JSON.parse(body) : {};

	return {
		data,
		status: res.status,
		headers: res.headers,
	} as readConcurrencyLimitV2V2ConcurrencyLimitsIdOrNameGetResponse;
};

export const getReadConcurrencyLimitV2V2ConcurrencyLimitsIdOrNameGetQueryKey = (
	idOrName: string | string,
) => {
	return [
		`http://prefect.grose.click/api/v2/concurrency_limits/${idOrName}`,
	] as const;
};

export const getReadConcurrencyLimitV2V2ConcurrencyLimitsIdOrNameGetQueryOptions =
	<
		TData = Awaited<
			ReturnType<typeof readConcurrencyLimitV2V2ConcurrencyLimitsIdOrNameGet>
		>,
		TError = HTTPValidationError,
	>(
		idOrName: string | string,
		options?: {
			query?: Partial<
				UseQueryOptions<
					Awaited<
						ReturnType<
							typeof readConcurrencyLimitV2V2ConcurrencyLimitsIdOrNameGet
						>
					>,
					TError,
					TData
				>
			>;
			fetch?: RequestInit;
		},
	) => {
		const { query: queryOptions, fetch: fetchOptions } = options ?? {};

		const queryKey =
			queryOptions?.queryKey ??
			getReadConcurrencyLimitV2V2ConcurrencyLimitsIdOrNameGetQueryKey(idOrName);

		const queryFn: QueryFunction<
			Awaited<
				ReturnType<typeof readConcurrencyLimitV2V2ConcurrencyLimitsIdOrNameGet>
			>
		> = ({ signal }) =>
			readConcurrencyLimitV2V2ConcurrencyLimitsIdOrNameGet(idOrName, {
				signal,
				...fetchOptions,
			});

		return {
			queryKey,
			queryFn,
			enabled: !!idOrName,
			...queryOptions,
		} as UseQueryOptions<
			Awaited<
				ReturnType<typeof readConcurrencyLimitV2V2ConcurrencyLimitsIdOrNameGet>
			>,
			TError,
			TData
		> & { queryKey: DataTag<QueryKey, TData, TError> };
	};

export type ReadConcurrencyLimitV2V2ConcurrencyLimitsIdOrNameGetQueryResult =
	NonNullable<
		Awaited<
			ReturnType<typeof readConcurrencyLimitV2V2ConcurrencyLimitsIdOrNameGet>
		>
	>;
export type ReadConcurrencyLimitV2V2ConcurrencyLimitsIdOrNameGetQueryError =
	HTTPValidationError;

export function useReadConcurrencyLimitV2V2ConcurrencyLimitsIdOrNameGet<
	TData = Awaited<
		ReturnType<typeof readConcurrencyLimitV2V2ConcurrencyLimitsIdOrNameGet>
	>,
	TError = HTTPValidationError,
>(
	idOrName: string | string,
	options: {
		query: Partial<
			UseQueryOptions<
				Awaited<
					ReturnType<
						typeof readConcurrencyLimitV2V2ConcurrencyLimitsIdOrNameGet
					>
				>,
				TError,
				TData
			>
		> &
			Pick<
				DefinedInitialDataOptions<
					Awaited<
						ReturnType<
							typeof readConcurrencyLimitV2V2ConcurrencyLimitsIdOrNameGet
						>
					>,
					TError,
					Awaited<
						ReturnType<
							typeof readConcurrencyLimitV2V2ConcurrencyLimitsIdOrNameGet
						>
					>
				>,
				"initialData"
			>;
		fetch?: RequestInit;
	},
): DefinedUseQueryResult<TData, TError> & {
	queryKey: DataTag<QueryKey, TData, TError>;
};
export function useReadConcurrencyLimitV2V2ConcurrencyLimitsIdOrNameGet<
	TData = Awaited<
		ReturnType<typeof readConcurrencyLimitV2V2ConcurrencyLimitsIdOrNameGet>
	>,
	TError = HTTPValidationError,
>(
	idOrName: string | string,
	options?: {
		query?: Partial<
			UseQueryOptions<
				Awaited<
					ReturnType<
						typeof readConcurrencyLimitV2V2ConcurrencyLimitsIdOrNameGet
					>
				>,
				TError,
				TData
			>
		> &
			Pick<
				UndefinedInitialDataOptions<
					Awaited<
						ReturnType<
							typeof readConcurrencyLimitV2V2ConcurrencyLimitsIdOrNameGet
						>
					>,
					TError,
					Awaited<
						ReturnType<
							typeof readConcurrencyLimitV2V2ConcurrencyLimitsIdOrNameGet
						>
					>
				>,
				"initialData"
			>;
		fetch?: RequestInit;
	},
): UseQueryResult<TData, TError> & {
	queryKey: DataTag<QueryKey, TData, TError>;
};
export function useReadConcurrencyLimitV2V2ConcurrencyLimitsIdOrNameGet<
	TData = Awaited<
		ReturnType<typeof readConcurrencyLimitV2V2ConcurrencyLimitsIdOrNameGet>
	>,
	TError = HTTPValidationError,
>(
	idOrName: string | string,
	options?: {
		query?: Partial<
			UseQueryOptions<
				Awaited<
					ReturnType<
						typeof readConcurrencyLimitV2V2ConcurrencyLimitsIdOrNameGet
					>
				>,
				TError,
				TData
			>
		>;
		fetch?: RequestInit;
	},
): UseQueryResult<TData, TError> & {
	queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Read Concurrency Limit V2
 */

export function useReadConcurrencyLimitV2V2ConcurrencyLimitsIdOrNameGet<
	TData = Awaited<
		ReturnType<typeof readConcurrencyLimitV2V2ConcurrencyLimitsIdOrNameGet>
	>,
	TError = HTTPValidationError,
>(
	idOrName: string | string,
	options?: {
		query?: Partial<
			UseQueryOptions<
				Awaited<
					ReturnType<
						typeof readConcurrencyLimitV2V2ConcurrencyLimitsIdOrNameGet
					>
				>,
				TError,
				TData
			>
		>;
		fetch?: RequestInit;
	},
): UseQueryResult<TData, TError> & {
	queryKey: DataTag<QueryKey, TData, TError>;
} {
	const queryOptions =
		getReadConcurrencyLimitV2V2ConcurrencyLimitsIdOrNameGetQueryOptions(
			idOrName,
			options,
		);

	const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
		queryKey: DataTag<QueryKey, TData, TError>;
	};

	query.queryKey = queryOptions.queryKey;

	return query;
}

export const getReadConcurrencyLimitV2V2ConcurrencyLimitsIdOrNameGetSuspenseQueryOptions =
	<
		TData = Awaited<
			ReturnType<typeof readConcurrencyLimitV2V2ConcurrencyLimitsIdOrNameGet>
		>,
		TError = HTTPValidationError,
	>(
		idOrName: string | string,
		options?: {
			query?: Partial<
				UseSuspenseQueryOptions<
					Awaited<
						ReturnType<
							typeof readConcurrencyLimitV2V2ConcurrencyLimitsIdOrNameGet
						>
					>,
					TError,
					TData
				>
			>;
			fetch?: RequestInit;
		},
	) => {
		const { query: queryOptions, fetch: fetchOptions } = options ?? {};

		const queryKey =
			queryOptions?.queryKey ??
			getReadConcurrencyLimitV2V2ConcurrencyLimitsIdOrNameGetQueryKey(idOrName);

		const queryFn: QueryFunction<
			Awaited<
				ReturnType<typeof readConcurrencyLimitV2V2ConcurrencyLimitsIdOrNameGet>
			>
		> = ({ signal }) =>
			readConcurrencyLimitV2V2ConcurrencyLimitsIdOrNameGet(idOrName, {
				signal,
				...fetchOptions,
			});

		return { queryKey, queryFn, ...queryOptions } as UseSuspenseQueryOptions<
			Awaited<
				ReturnType<typeof readConcurrencyLimitV2V2ConcurrencyLimitsIdOrNameGet>
			>,
			TError,
			TData
		> & { queryKey: DataTag<QueryKey, TData, TError> };
	};

export type ReadConcurrencyLimitV2V2ConcurrencyLimitsIdOrNameGetSuspenseQueryResult =
	NonNullable<
		Awaited<
			ReturnType<typeof readConcurrencyLimitV2V2ConcurrencyLimitsIdOrNameGet>
		>
	>;
export type ReadConcurrencyLimitV2V2ConcurrencyLimitsIdOrNameGetSuspenseQueryError =
	HTTPValidationError;

export function useReadConcurrencyLimitV2V2ConcurrencyLimitsIdOrNameGetSuspense<
	TData = Awaited<
		ReturnType<typeof readConcurrencyLimitV2V2ConcurrencyLimitsIdOrNameGet>
	>,
	TError = HTTPValidationError,
>(
	idOrName: string | string,
	options: {
		query: Partial<
			UseSuspenseQueryOptions<
				Awaited<
					ReturnType<
						typeof readConcurrencyLimitV2V2ConcurrencyLimitsIdOrNameGet
					>
				>,
				TError,
				TData
			>
		>;
		fetch?: RequestInit;
	},
): UseSuspenseQueryResult<TData, TError> & {
	queryKey: DataTag<QueryKey, TData, TError>;
};
export function useReadConcurrencyLimitV2V2ConcurrencyLimitsIdOrNameGetSuspense<
	TData = Awaited<
		ReturnType<typeof readConcurrencyLimitV2V2ConcurrencyLimitsIdOrNameGet>
	>,
	TError = HTTPValidationError,
>(
	idOrName: string | string,
	options?: {
		query?: Partial<
			UseSuspenseQueryOptions<
				Awaited<
					ReturnType<
						typeof readConcurrencyLimitV2V2ConcurrencyLimitsIdOrNameGet
					>
				>,
				TError,
				TData
			>
		>;
		fetch?: RequestInit;
	},
): UseSuspenseQueryResult<TData, TError> & {
	queryKey: DataTag<QueryKey, TData, TError>;
};
export function useReadConcurrencyLimitV2V2ConcurrencyLimitsIdOrNameGetSuspense<
	TData = Awaited<
		ReturnType<typeof readConcurrencyLimitV2V2ConcurrencyLimitsIdOrNameGet>
	>,
	TError = HTTPValidationError,
>(
	idOrName: string | string,
	options?: {
		query?: Partial<
			UseSuspenseQueryOptions<
				Awaited<
					ReturnType<
						typeof readConcurrencyLimitV2V2ConcurrencyLimitsIdOrNameGet
					>
				>,
				TError,
				TData
			>
		>;
		fetch?: RequestInit;
	},
): UseSuspenseQueryResult<TData, TError> & {
	queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Read Concurrency Limit V2
 */

export function useReadConcurrencyLimitV2V2ConcurrencyLimitsIdOrNameGetSuspense<
	TData = Awaited<
		ReturnType<typeof readConcurrencyLimitV2V2ConcurrencyLimitsIdOrNameGet>
	>,
	TError = HTTPValidationError,
>(
	idOrName: string | string,
	options?: {
		query?: Partial<
			UseSuspenseQueryOptions<
				Awaited<
					ReturnType<
						typeof readConcurrencyLimitV2V2ConcurrencyLimitsIdOrNameGet
					>
				>,
				TError,
				TData
			>
		>;
		fetch?: RequestInit;
	},
): UseSuspenseQueryResult<TData, TError> & {
	queryKey: DataTag<QueryKey, TData, TError>;
} {
	const queryOptions =
		getReadConcurrencyLimitV2V2ConcurrencyLimitsIdOrNameGetSuspenseQueryOptions(
			idOrName,
			options,
		);

	const query = useSuspenseQuery(queryOptions) as UseSuspenseQueryResult<
		TData,
		TError
	> & { queryKey: DataTag<QueryKey, TData, TError> };

	query.queryKey = queryOptions.queryKey;

	return query;
}

/**
 * @summary Update Concurrency Limit V2
 */
export type updateConcurrencyLimitV2V2ConcurrencyLimitsIdOrNamePatchResponse = {
	data: void | HTTPValidationError;
	status: number;
	headers: Headers;
};

export const getUpdateConcurrencyLimitV2V2ConcurrencyLimitsIdOrNamePatchUrl = (
	idOrName: string | string,
) => {
	return `http://prefect.grose.click/api/v2/concurrency_limits/${idOrName}`;
};

export const updateConcurrencyLimitV2V2ConcurrencyLimitsIdOrNamePatch = async (
	idOrName: string | string,
	concurrencyLimitV2Update: ConcurrencyLimitV2Update,
	options?: RequestInit,
): Promise<updateConcurrencyLimitV2V2ConcurrencyLimitsIdOrNamePatchResponse> => {
	const res = await fetch(
		getUpdateConcurrencyLimitV2V2ConcurrencyLimitsIdOrNamePatchUrl(idOrName),
		{
			...options,
			method: "PATCH",
			headers: { "Content-Type": "application/json", ...options?.headers },
			body: JSON.stringify(concurrencyLimitV2Update),
		},
	);

	const body = [204, 205, 304].includes(res.status) ? null : await res.text();
	const data: updateConcurrencyLimitV2V2ConcurrencyLimitsIdOrNamePatchResponse["data"] =
		body ? JSON.parse(body) : {};

	return {
		data,
		status: res.status,
		headers: res.headers,
	} as updateConcurrencyLimitV2V2ConcurrencyLimitsIdOrNamePatchResponse;
};

export const getUpdateConcurrencyLimitV2V2ConcurrencyLimitsIdOrNamePatchMutationOptions =
	<TError = HTTPValidationError, TContext = unknown>(options?: {
		mutation?: UseMutationOptions<
			Awaited<
				ReturnType<
					typeof updateConcurrencyLimitV2V2ConcurrencyLimitsIdOrNamePatch
				>
			>,
			TError,
			{ idOrName: string | string; data: ConcurrencyLimitV2Update },
			TContext
		>;
		fetch?: RequestInit;
	}): UseMutationOptions<
		Awaited<
			ReturnType<
				typeof updateConcurrencyLimitV2V2ConcurrencyLimitsIdOrNamePatch
			>
		>,
		TError,
		{ idOrName: string | string; data: ConcurrencyLimitV2Update },
		TContext
	> => {
		const mutationKey = [
			"updateConcurrencyLimitV2V2ConcurrencyLimitsIdOrNamePatch",
		];
		const { mutation: mutationOptions, fetch: fetchOptions } = options
			? options.mutation &&
				"mutationKey" in options.mutation &&
				options.mutation.mutationKey
				? options
				: { ...options, mutation: { ...options.mutation, mutationKey } }
			: { mutation: { mutationKey }, fetch: undefined };

		const mutationFn: MutationFunction<
			Awaited<
				ReturnType<
					typeof updateConcurrencyLimitV2V2ConcurrencyLimitsIdOrNamePatch
				>
			>,
			{ idOrName: string | string; data: ConcurrencyLimitV2Update }
		> = (props) => {
			const { idOrName, data } = props ?? {};

			return updateConcurrencyLimitV2V2ConcurrencyLimitsIdOrNamePatch(
				idOrName,
				data,
				fetchOptions,
			);
		};

		return { mutationFn, ...mutationOptions };
	};

export type UpdateConcurrencyLimitV2V2ConcurrencyLimitsIdOrNamePatchMutationResult =
	NonNullable<
		Awaited<
			ReturnType<
				typeof updateConcurrencyLimitV2V2ConcurrencyLimitsIdOrNamePatch
			>
		>
	>;
export type UpdateConcurrencyLimitV2V2ConcurrencyLimitsIdOrNamePatchMutationBody =
	ConcurrencyLimitV2Update;
export type UpdateConcurrencyLimitV2V2ConcurrencyLimitsIdOrNamePatchMutationError =
	HTTPValidationError;

/**
 * @summary Update Concurrency Limit V2
 */
export const useUpdateConcurrencyLimitV2V2ConcurrencyLimitsIdOrNamePatch = <
	TError = HTTPValidationError,
	TContext = unknown,
>(options?: {
	mutation?: UseMutationOptions<
		Awaited<
			ReturnType<
				typeof updateConcurrencyLimitV2V2ConcurrencyLimitsIdOrNamePatch
			>
		>,
		TError,
		{ idOrName: string | string; data: ConcurrencyLimitV2Update },
		TContext
	>;
	fetch?: RequestInit;
}): UseMutationResult<
	Awaited<
		ReturnType<typeof updateConcurrencyLimitV2V2ConcurrencyLimitsIdOrNamePatch>
	>,
	TError,
	{ idOrName: string | string; data: ConcurrencyLimitV2Update },
	TContext
> => {
	const mutationOptions =
		getUpdateConcurrencyLimitV2V2ConcurrencyLimitsIdOrNamePatchMutationOptions(
			options,
		);

	return useMutation(mutationOptions);
};
/**
 * @summary Delete Concurrency Limit V2
 */
export type deleteConcurrencyLimitV2V2ConcurrencyLimitsIdOrNameDeleteResponse =
	{
		data: void | HTTPValidationError;
		status: number;
		headers: Headers;
	};

export const getDeleteConcurrencyLimitV2V2ConcurrencyLimitsIdOrNameDeleteUrl = (
	idOrName: string | string,
) => {
	return `http://prefect.grose.click/api/v2/concurrency_limits/${idOrName}`;
};

export const deleteConcurrencyLimitV2V2ConcurrencyLimitsIdOrNameDelete = async (
	idOrName: string | string,
	options?: RequestInit,
): Promise<deleteConcurrencyLimitV2V2ConcurrencyLimitsIdOrNameDeleteResponse> => {
	const res = await fetch(
		getDeleteConcurrencyLimitV2V2ConcurrencyLimitsIdOrNameDeleteUrl(idOrName),
		{
			...options,
			method: "DELETE",
		},
	);

	const body = [204, 205, 304].includes(res.status) ? null : await res.text();
	const data: deleteConcurrencyLimitV2V2ConcurrencyLimitsIdOrNameDeleteResponse["data"] =
		body ? JSON.parse(body) : {};

	return {
		data,
		status: res.status,
		headers: res.headers,
	} as deleteConcurrencyLimitV2V2ConcurrencyLimitsIdOrNameDeleteResponse;
};

export const getDeleteConcurrencyLimitV2V2ConcurrencyLimitsIdOrNameDeleteMutationOptions =
	<TError = HTTPValidationError, TContext = unknown>(options?: {
		mutation?: UseMutationOptions<
			Awaited<
				ReturnType<
					typeof deleteConcurrencyLimitV2V2ConcurrencyLimitsIdOrNameDelete
				>
			>,
			TError,
			{ idOrName: string | string },
			TContext
		>;
		fetch?: RequestInit;
	}): UseMutationOptions<
		Awaited<
			ReturnType<
				typeof deleteConcurrencyLimitV2V2ConcurrencyLimitsIdOrNameDelete
			>
		>,
		TError,
		{ idOrName: string | string },
		TContext
	> => {
		const mutationKey = [
			"deleteConcurrencyLimitV2V2ConcurrencyLimitsIdOrNameDelete",
		];
		const { mutation: mutationOptions, fetch: fetchOptions } = options
			? options.mutation &&
				"mutationKey" in options.mutation &&
				options.mutation.mutationKey
				? options
				: { ...options, mutation: { ...options.mutation, mutationKey } }
			: { mutation: { mutationKey }, fetch: undefined };

		const mutationFn: MutationFunction<
			Awaited<
				ReturnType<
					typeof deleteConcurrencyLimitV2V2ConcurrencyLimitsIdOrNameDelete
				>
			>,
			{ idOrName: string | string }
		> = (props) => {
			const { idOrName } = props ?? {};

			return deleteConcurrencyLimitV2V2ConcurrencyLimitsIdOrNameDelete(
				idOrName,
				fetchOptions,
			);
		};

		return { mutationFn, ...mutationOptions };
	};

export type DeleteConcurrencyLimitV2V2ConcurrencyLimitsIdOrNameDeleteMutationResult =
	NonNullable<
		Awaited<
			ReturnType<
				typeof deleteConcurrencyLimitV2V2ConcurrencyLimitsIdOrNameDelete
			>
		>
	>;

export type DeleteConcurrencyLimitV2V2ConcurrencyLimitsIdOrNameDeleteMutationError =
	HTTPValidationError;

/**
 * @summary Delete Concurrency Limit V2
 */
export const useDeleteConcurrencyLimitV2V2ConcurrencyLimitsIdOrNameDelete = <
	TError = HTTPValidationError,
	TContext = unknown,
>(options?: {
	mutation?: UseMutationOptions<
		Awaited<
			ReturnType<
				typeof deleteConcurrencyLimitV2V2ConcurrencyLimitsIdOrNameDelete
			>
		>,
		TError,
		{ idOrName: string | string },
		TContext
	>;
	fetch?: RequestInit;
}): UseMutationResult<
	Awaited<
		ReturnType<typeof deleteConcurrencyLimitV2V2ConcurrencyLimitsIdOrNameDelete>
	>,
	TError,
	{ idOrName: string | string },
	TContext
> => {
	const mutationOptions =
		getDeleteConcurrencyLimitV2V2ConcurrencyLimitsIdOrNameDeleteMutationOptions(
			options,
		);

	return useMutation(mutationOptions);
};
/**
 * @summary Read All Concurrency Limits V2
 */
export type readAllConcurrencyLimitsV2V2ConcurrencyLimitsFilterPostResponse = {
	data: GlobalConcurrencyLimitResponse[] | HTTPValidationError;
	status: number;
	headers: Headers;
};

export const getReadAllConcurrencyLimitsV2V2ConcurrencyLimitsFilterPostUrl =
	() => {
		return `http://prefect.grose.click/api/v2/concurrency_limits/filter`;
	};

export const readAllConcurrencyLimitsV2V2ConcurrencyLimitsFilterPost = async (
	bodyReadAllConcurrencyLimitsV2V2ConcurrencyLimitsFilterPost: BodyReadAllConcurrencyLimitsV2V2ConcurrencyLimitsFilterPost,
	options?: RequestInit,
): Promise<readAllConcurrencyLimitsV2V2ConcurrencyLimitsFilterPostResponse> => {
	const res = await fetch(
		getReadAllConcurrencyLimitsV2V2ConcurrencyLimitsFilterPostUrl(),
		{
			...options,
			method: "POST",
			headers: { "Content-Type": "application/json", ...options?.headers },
			body: JSON.stringify(
				bodyReadAllConcurrencyLimitsV2V2ConcurrencyLimitsFilterPost,
			),
		},
	);

	const body = [204, 205, 304].includes(res.status) ? null : await res.text();
	const data: readAllConcurrencyLimitsV2V2ConcurrencyLimitsFilterPostResponse["data"] =
		body ? JSON.parse(body) : {};

	return {
		data,
		status: res.status,
		headers: res.headers,
	} as readAllConcurrencyLimitsV2V2ConcurrencyLimitsFilterPostResponse;
};

export const getReadAllConcurrencyLimitsV2V2ConcurrencyLimitsFilterPostMutationOptions =
	<TError = HTTPValidationError, TContext = unknown>(options?: {
		mutation?: UseMutationOptions<
			Awaited<
				ReturnType<
					typeof readAllConcurrencyLimitsV2V2ConcurrencyLimitsFilterPost
				>
			>,
			TError,
			{ data: BodyReadAllConcurrencyLimitsV2V2ConcurrencyLimitsFilterPost },
			TContext
		>;
		fetch?: RequestInit;
	}): UseMutationOptions<
		Awaited<
			ReturnType<typeof readAllConcurrencyLimitsV2V2ConcurrencyLimitsFilterPost>
		>,
		TError,
		{ data: BodyReadAllConcurrencyLimitsV2V2ConcurrencyLimitsFilterPost },
		TContext
	> => {
		const mutationKey = [
			"readAllConcurrencyLimitsV2V2ConcurrencyLimitsFilterPost",
		];
		const { mutation: mutationOptions, fetch: fetchOptions } = options
			? options.mutation &&
				"mutationKey" in options.mutation &&
				options.mutation.mutationKey
				? options
				: { ...options, mutation: { ...options.mutation, mutationKey } }
			: { mutation: { mutationKey }, fetch: undefined };

		const mutationFn: MutationFunction<
			Awaited<
				ReturnType<
					typeof readAllConcurrencyLimitsV2V2ConcurrencyLimitsFilterPost
				>
			>,
			{ data: BodyReadAllConcurrencyLimitsV2V2ConcurrencyLimitsFilterPost }
		> = (props) => {
			const { data } = props ?? {};

			return readAllConcurrencyLimitsV2V2ConcurrencyLimitsFilterPost(
				data,
				fetchOptions,
			);
		};

		return { mutationFn, ...mutationOptions };
	};

export type ReadAllConcurrencyLimitsV2V2ConcurrencyLimitsFilterPostMutationResult =
	NonNullable<
		Awaited<
			ReturnType<typeof readAllConcurrencyLimitsV2V2ConcurrencyLimitsFilterPost>
		>
	>;
export type ReadAllConcurrencyLimitsV2V2ConcurrencyLimitsFilterPostMutationBody =
	BodyReadAllConcurrencyLimitsV2V2ConcurrencyLimitsFilterPost;
export type ReadAllConcurrencyLimitsV2V2ConcurrencyLimitsFilterPostMutationError =
	HTTPValidationError;

/**
 * @summary Read All Concurrency Limits V2
 */
export const useReadAllConcurrencyLimitsV2V2ConcurrencyLimitsFilterPost = <
	TError = HTTPValidationError,
	TContext = unknown,
>(options?: {
	mutation?: UseMutationOptions<
		Awaited<
			ReturnType<typeof readAllConcurrencyLimitsV2V2ConcurrencyLimitsFilterPost>
		>,
		TError,
		{ data: BodyReadAllConcurrencyLimitsV2V2ConcurrencyLimitsFilterPost },
		TContext
	>;
	fetch?: RequestInit;
}): UseMutationResult<
	Awaited<
		ReturnType<typeof readAllConcurrencyLimitsV2V2ConcurrencyLimitsFilterPost>
	>,
	TError,
	{ data: BodyReadAllConcurrencyLimitsV2V2ConcurrencyLimitsFilterPost },
	TContext
> => {
	const mutationOptions =
		getReadAllConcurrencyLimitsV2V2ConcurrencyLimitsFilterPostMutationOptions(
			options,
		);

	return useMutation(mutationOptions);
};
/**
 * @summary Bulk Increment Active Slots
 */
export type bulkIncrementActiveSlotsV2ConcurrencyLimitsIncrementPostResponse = {
	data: MinimalConcurrencyLimitResponse[] | HTTPValidationError;
	status: number;
	headers: Headers;
};

export const getBulkIncrementActiveSlotsV2ConcurrencyLimitsIncrementPostUrl =
	() => {
		return `http://prefect.grose.click/api/v2/concurrency_limits/increment`;
	};

export const bulkIncrementActiveSlotsV2ConcurrencyLimitsIncrementPost = async (
	bodyBulkIncrementActiveSlotsV2ConcurrencyLimitsIncrementPost: BodyBulkIncrementActiveSlotsV2ConcurrencyLimitsIncrementPost,
	options?: RequestInit,
): Promise<bulkIncrementActiveSlotsV2ConcurrencyLimitsIncrementPostResponse> => {
	const res = await fetch(
		getBulkIncrementActiveSlotsV2ConcurrencyLimitsIncrementPostUrl(),
		{
			...options,
			method: "POST",
			headers: { "Content-Type": "application/json", ...options?.headers },
			body: JSON.stringify(
				bodyBulkIncrementActiveSlotsV2ConcurrencyLimitsIncrementPost,
			),
		},
	);

	const body = [204, 205, 304].includes(res.status) ? null : await res.text();
	const data: bulkIncrementActiveSlotsV2ConcurrencyLimitsIncrementPostResponse["data"] =
		body ? JSON.parse(body) : {};

	return {
		data,
		status: res.status,
		headers: res.headers,
	} as bulkIncrementActiveSlotsV2ConcurrencyLimitsIncrementPostResponse;
};

export const getBulkIncrementActiveSlotsV2ConcurrencyLimitsIncrementPostMutationOptions =
	<TError = HTTPValidationError, TContext = unknown>(options?: {
		mutation?: UseMutationOptions<
			Awaited<
				ReturnType<
					typeof bulkIncrementActiveSlotsV2ConcurrencyLimitsIncrementPost
				>
			>,
			TError,
			{ data: BodyBulkIncrementActiveSlotsV2ConcurrencyLimitsIncrementPost },
			TContext
		>;
		fetch?: RequestInit;
	}): UseMutationOptions<
		Awaited<
			ReturnType<
				typeof bulkIncrementActiveSlotsV2ConcurrencyLimitsIncrementPost
			>
		>,
		TError,
		{ data: BodyBulkIncrementActiveSlotsV2ConcurrencyLimitsIncrementPost },
		TContext
	> => {
		const mutationKey = [
			"bulkIncrementActiveSlotsV2ConcurrencyLimitsIncrementPost",
		];
		const { mutation: mutationOptions, fetch: fetchOptions } = options
			? options.mutation &&
				"mutationKey" in options.mutation &&
				options.mutation.mutationKey
				? options
				: { ...options, mutation: { ...options.mutation, mutationKey } }
			: { mutation: { mutationKey }, fetch: undefined };

		const mutationFn: MutationFunction<
			Awaited<
				ReturnType<
					typeof bulkIncrementActiveSlotsV2ConcurrencyLimitsIncrementPost
				>
			>,
			{ data: BodyBulkIncrementActiveSlotsV2ConcurrencyLimitsIncrementPost }
		> = (props) => {
			const { data } = props ?? {};

			return bulkIncrementActiveSlotsV2ConcurrencyLimitsIncrementPost(
				data,
				fetchOptions,
			);
		};

		return { mutationFn, ...mutationOptions };
	};

export type BulkIncrementActiveSlotsV2ConcurrencyLimitsIncrementPostMutationResult =
	NonNullable<
		Awaited<
			ReturnType<
				typeof bulkIncrementActiveSlotsV2ConcurrencyLimitsIncrementPost
			>
		>
	>;
export type BulkIncrementActiveSlotsV2ConcurrencyLimitsIncrementPostMutationBody =
	BodyBulkIncrementActiveSlotsV2ConcurrencyLimitsIncrementPost;
export type BulkIncrementActiveSlotsV2ConcurrencyLimitsIncrementPostMutationError =
	HTTPValidationError;

/**
 * @summary Bulk Increment Active Slots
 */
export const useBulkIncrementActiveSlotsV2ConcurrencyLimitsIncrementPost = <
	TError = HTTPValidationError,
	TContext = unknown,
>(options?: {
	mutation?: UseMutationOptions<
		Awaited<
			ReturnType<
				typeof bulkIncrementActiveSlotsV2ConcurrencyLimitsIncrementPost
			>
		>,
		TError,
		{ data: BodyBulkIncrementActiveSlotsV2ConcurrencyLimitsIncrementPost },
		TContext
	>;
	fetch?: RequestInit;
}): UseMutationResult<
	Awaited<
		ReturnType<typeof bulkIncrementActiveSlotsV2ConcurrencyLimitsIncrementPost>
	>,
	TError,
	{ data: BodyBulkIncrementActiveSlotsV2ConcurrencyLimitsIncrementPost },
	TContext
> => {
	const mutationOptions =
		getBulkIncrementActiveSlotsV2ConcurrencyLimitsIncrementPostMutationOptions(
			options,
		);

	return useMutation(mutationOptions);
};
/**
 * @summary Bulk Decrement Active Slots
 */
export type bulkDecrementActiveSlotsV2ConcurrencyLimitsDecrementPostResponse = {
	data: MinimalConcurrencyLimitResponse[] | HTTPValidationError;
	status: number;
	headers: Headers;
};

export const getBulkDecrementActiveSlotsV2ConcurrencyLimitsDecrementPostUrl =
	() => {
		return `http://prefect.grose.click/api/v2/concurrency_limits/decrement`;
	};

export const bulkDecrementActiveSlotsV2ConcurrencyLimitsDecrementPost = async (
	bodyBulkDecrementActiveSlotsV2ConcurrencyLimitsDecrementPost: BodyBulkDecrementActiveSlotsV2ConcurrencyLimitsDecrementPost,
	options?: RequestInit,
): Promise<bulkDecrementActiveSlotsV2ConcurrencyLimitsDecrementPostResponse> => {
	const res = await fetch(
		getBulkDecrementActiveSlotsV2ConcurrencyLimitsDecrementPostUrl(),
		{
			...options,
			method: "POST",
			headers: { "Content-Type": "application/json", ...options?.headers },
			body: JSON.stringify(
				bodyBulkDecrementActiveSlotsV2ConcurrencyLimitsDecrementPost,
			),
		},
	);

	const body = [204, 205, 304].includes(res.status) ? null : await res.text();
	const data: bulkDecrementActiveSlotsV2ConcurrencyLimitsDecrementPostResponse["data"] =
		body ? JSON.parse(body) : {};

	return {
		data,
		status: res.status,
		headers: res.headers,
	} as bulkDecrementActiveSlotsV2ConcurrencyLimitsDecrementPostResponse;
};

export const getBulkDecrementActiveSlotsV2ConcurrencyLimitsDecrementPostMutationOptions =
	<TError = HTTPValidationError, TContext = unknown>(options?: {
		mutation?: UseMutationOptions<
			Awaited<
				ReturnType<
					typeof bulkDecrementActiveSlotsV2ConcurrencyLimitsDecrementPost
				>
			>,
			TError,
			{ data: BodyBulkDecrementActiveSlotsV2ConcurrencyLimitsDecrementPost },
			TContext
		>;
		fetch?: RequestInit;
	}): UseMutationOptions<
		Awaited<
			ReturnType<
				typeof bulkDecrementActiveSlotsV2ConcurrencyLimitsDecrementPost
			>
		>,
		TError,
		{ data: BodyBulkDecrementActiveSlotsV2ConcurrencyLimitsDecrementPost },
		TContext
	> => {
		const mutationKey = [
			"bulkDecrementActiveSlotsV2ConcurrencyLimitsDecrementPost",
		];
		const { mutation: mutationOptions, fetch: fetchOptions } = options
			? options.mutation &&
				"mutationKey" in options.mutation &&
				options.mutation.mutationKey
				? options
				: { ...options, mutation: { ...options.mutation, mutationKey } }
			: { mutation: { mutationKey }, fetch: undefined };

		const mutationFn: MutationFunction<
			Awaited<
				ReturnType<
					typeof bulkDecrementActiveSlotsV2ConcurrencyLimitsDecrementPost
				>
			>,
			{ data: BodyBulkDecrementActiveSlotsV2ConcurrencyLimitsDecrementPost }
		> = (props) => {
			const { data } = props ?? {};

			return bulkDecrementActiveSlotsV2ConcurrencyLimitsDecrementPost(
				data,
				fetchOptions,
			);
		};

		return { mutationFn, ...mutationOptions };
	};

export type BulkDecrementActiveSlotsV2ConcurrencyLimitsDecrementPostMutationResult =
	NonNullable<
		Awaited<
			ReturnType<
				typeof bulkDecrementActiveSlotsV2ConcurrencyLimitsDecrementPost
			>
		>
	>;
export type BulkDecrementActiveSlotsV2ConcurrencyLimitsDecrementPostMutationBody =
	BodyBulkDecrementActiveSlotsV2ConcurrencyLimitsDecrementPost;
export type BulkDecrementActiveSlotsV2ConcurrencyLimitsDecrementPostMutationError =
	HTTPValidationError;

/**
 * @summary Bulk Decrement Active Slots
 */
export const useBulkDecrementActiveSlotsV2ConcurrencyLimitsDecrementPost = <
	TError = HTTPValidationError,
	TContext = unknown,
>(options?: {
	mutation?: UseMutationOptions<
		Awaited<
			ReturnType<
				typeof bulkDecrementActiveSlotsV2ConcurrencyLimitsDecrementPost
			>
		>,
		TError,
		{ data: BodyBulkDecrementActiveSlotsV2ConcurrencyLimitsDecrementPost },
		TContext
	>;
	fetch?: RequestInit;
}): UseMutationResult<
	Awaited<
		ReturnType<typeof bulkDecrementActiveSlotsV2ConcurrencyLimitsDecrementPost>
	>,
	TError,
	{ data: BodyBulkDecrementActiveSlotsV2ConcurrencyLimitsDecrementPost },
	TContext
> => {
	const mutationOptions =
		getBulkDecrementActiveSlotsV2ConcurrencyLimitsDecrementPostMutationOptions(
			options,
		);

	return useMutation(mutationOptions);
};
