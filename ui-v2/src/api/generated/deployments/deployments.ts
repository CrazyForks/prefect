/**
 * Generated by orval v7.5.0 🍺
 * Do not edit manually.
 * Prefect Prefect REST API
 * OpenAPI spec version: 0.1.0
 */
import { useMutation, useQuery, useSuspenseQuery } from "@tanstack/react-query";
import type {
	DataTag,
	DefinedInitialDataOptions,
	DefinedUseQueryResult,
	MutationFunction,
	QueryFunction,
	QueryKey,
	UndefinedInitialDataOptions,
	UseMutationOptions,
	UseMutationResult,
	UseQueryOptions,
	UseQueryResult,
	UseSuspenseQueryOptions,
	UseSuspenseQueryResult,
} from "@tanstack/react-query";
import type {
	BodyCountDeploymentsDeploymentsCountPost,
	BodyGetScheduledFlowRunsForDeploymentsDeploymentsGetScheduledFlowRunsPost,
	BodyPaginateDeploymentsDeploymentsPaginatePost,
	BodyReadDeploymentsDeploymentsFilterPost,
	BodyScheduleDeploymentDeploymentsIdSchedulePost,
	DeploymentCreate,
	DeploymentFlowRunCreate,
	DeploymentPaginationResponse,
	DeploymentResponse,
	DeploymentSchedule,
	DeploymentScheduleCreate,
	DeploymentScheduleUpdate,
	DeploymentUpdate,
	FlowRunResponse,
	HTTPValidationError,
	WorkQueue,
} from "../../models";

/**
 * Gracefully creates a new deployment from the provided schema. If a deployment with
the same name and flow_id already exists, the deployment is updated.

If the deployment has an active schedule, flow runs will be scheduled.
When upserting, any scheduled runs from the existing deployment will be deleted.
 * @summary Create Deployment
 */
export type createDeploymentDeploymentsPostResponse = {
	data: DeploymentResponse | HTTPValidationError;
	status: number;
	headers: Headers;
};

export const getCreateDeploymentDeploymentsPostUrl = () => {
	return `http://prefect.grose.click/api/deployments/`;
};

export const createDeploymentDeploymentsPost = async (
	deploymentCreate: DeploymentCreate,
	options?: RequestInit,
): Promise<createDeploymentDeploymentsPostResponse> => {
	const res = await fetch(getCreateDeploymentDeploymentsPostUrl(), {
		...options,
		method: "POST",
		headers: { "Content-Type": "application/json", ...options?.headers },
		body: JSON.stringify(deploymentCreate),
	});

	const body = [204, 205, 304].includes(res.status) ? null : await res.text();
	const data: createDeploymentDeploymentsPostResponse["data"] = body
		? JSON.parse(body)
		: {};

	return {
		data,
		status: res.status,
		headers: res.headers,
	} as createDeploymentDeploymentsPostResponse;
};

export const getCreateDeploymentDeploymentsPostMutationOptions = <
	TError = HTTPValidationError,
	TContext = unknown,
>(options?: {
	mutation?: UseMutationOptions<
		Awaited<ReturnType<typeof createDeploymentDeploymentsPost>>,
		TError,
		{ data: DeploymentCreate },
		TContext
	>;
	fetch?: RequestInit;
}): UseMutationOptions<
	Awaited<ReturnType<typeof createDeploymentDeploymentsPost>>,
	TError,
	{ data: DeploymentCreate },
	TContext
> => {
	const mutationKey = ["createDeploymentDeploymentsPost"];
	const { mutation: mutationOptions, fetch: fetchOptions } = options
		? options.mutation &&
			"mutationKey" in options.mutation &&
			options.mutation.mutationKey
			? options
			: { ...options, mutation: { ...options.mutation, mutationKey } }
		: { mutation: { mutationKey }, fetch: undefined };

	const mutationFn: MutationFunction<
		Awaited<ReturnType<typeof createDeploymentDeploymentsPost>>,
		{ data: DeploymentCreate }
	> = (props) => {
		const { data } = props ?? {};

		return createDeploymentDeploymentsPost(data, fetchOptions);
	};

	return { mutationFn, ...mutationOptions };
};

export type CreateDeploymentDeploymentsPostMutationResult = NonNullable<
	Awaited<ReturnType<typeof createDeploymentDeploymentsPost>>
>;
export type CreateDeploymentDeploymentsPostMutationBody = DeploymentCreate;
export type CreateDeploymentDeploymentsPostMutationError = HTTPValidationError;

/**
 * @summary Create Deployment
 */
export const useCreateDeploymentDeploymentsPost = <
	TError = HTTPValidationError,
	TContext = unknown,
>(options?: {
	mutation?: UseMutationOptions<
		Awaited<ReturnType<typeof createDeploymentDeploymentsPost>>,
		TError,
		{ data: DeploymentCreate },
		TContext
	>;
	fetch?: RequestInit;
}): UseMutationResult<
	Awaited<ReturnType<typeof createDeploymentDeploymentsPost>>,
	TError,
	{ data: DeploymentCreate },
	TContext
> => {
	const mutationOptions =
		getCreateDeploymentDeploymentsPostMutationOptions(options);

	return useMutation(mutationOptions);
};
/**
 * @summary Update Deployment
 */
export type updateDeploymentDeploymentsIdPatchResponse = {
	data: void | HTTPValidationError;
	status: number;
	headers: Headers;
};

export const getUpdateDeploymentDeploymentsIdPatchUrl = (id: string) => {
	return `http://prefect.grose.click/api/deployments/${id}`;
};

export const updateDeploymentDeploymentsIdPatch = async (
	id: string,
	deploymentUpdate: DeploymentUpdate,
	options?: RequestInit,
): Promise<updateDeploymentDeploymentsIdPatchResponse> => {
	const res = await fetch(getUpdateDeploymentDeploymentsIdPatchUrl(id), {
		...options,
		method: "PATCH",
		headers: { "Content-Type": "application/json", ...options?.headers },
		body: JSON.stringify(deploymentUpdate),
	});

	const body = [204, 205, 304].includes(res.status) ? null : await res.text();
	const data: updateDeploymentDeploymentsIdPatchResponse["data"] = body
		? JSON.parse(body)
		: {};

	return {
		data,
		status: res.status,
		headers: res.headers,
	} as updateDeploymentDeploymentsIdPatchResponse;
};

export const getUpdateDeploymentDeploymentsIdPatchMutationOptions = <
	TError = HTTPValidationError,
	TContext = unknown,
>(options?: {
	mutation?: UseMutationOptions<
		Awaited<ReturnType<typeof updateDeploymentDeploymentsIdPatch>>,
		TError,
		{ id: string; data: DeploymentUpdate },
		TContext
	>;
	fetch?: RequestInit;
}): UseMutationOptions<
	Awaited<ReturnType<typeof updateDeploymentDeploymentsIdPatch>>,
	TError,
	{ id: string; data: DeploymentUpdate },
	TContext
> => {
	const mutationKey = ["updateDeploymentDeploymentsIdPatch"];
	const { mutation: mutationOptions, fetch: fetchOptions } = options
		? options.mutation &&
			"mutationKey" in options.mutation &&
			options.mutation.mutationKey
			? options
			: { ...options, mutation: { ...options.mutation, mutationKey } }
		: { mutation: { mutationKey }, fetch: undefined };

	const mutationFn: MutationFunction<
		Awaited<ReturnType<typeof updateDeploymentDeploymentsIdPatch>>,
		{ id: string; data: DeploymentUpdate }
	> = (props) => {
		const { id, data } = props ?? {};

		return updateDeploymentDeploymentsIdPatch(id, data, fetchOptions);
	};

	return { mutationFn, ...mutationOptions };
};

export type UpdateDeploymentDeploymentsIdPatchMutationResult = NonNullable<
	Awaited<ReturnType<typeof updateDeploymentDeploymentsIdPatch>>
>;
export type UpdateDeploymentDeploymentsIdPatchMutationBody = DeploymentUpdate;
export type UpdateDeploymentDeploymentsIdPatchMutationError =
	HTTPValidationError;

/**
 * @summary Update Deployment
 */
export const useUpdateDeploymentDeploymentsIdPatch = <
	TError = HTTPValidationError,
	TContext = unknown,
>(options?: {
	mutation?: UseMutationOptions<
		Awaited<ReturnType<typeof updateDeploymentDeploymentsIdPatch>>,
		TError,
		{ id: string; data: DeploymentUpdate },
		TContext
	>;
	fetch?: RequestInit;
}): UseMutationResult<
	Awaited<ReturnType<typeof updateDeploymentDeploymentsIdPatch>>,
	TError,
	{ id: string; data: DeploymentUpdate },
	TContext
> => {
	const mutationOptions =
		getUpdateDeploymentDeploymentsIdPatchMutationOptions(options);

	return useMutation(mutationOptions);
};
/**
 * Get a deployment by id.
 * @summary Read Deployment
 */
export type readDeploymentDeploymentsIdGetResponse = {
	data: DeploymentResponse | HTTPValidationError;
	status: number;
	headers: Headers;
};

export const getReadDeploymentDeploymentsIdGetUrl = (id: string) => {
	return `http://prefect.grose.click/api/deployments/${id}`;
};

export const readDeploymentDeploymentsIdGet = async (
	id: string,
	options?: RequestInit,
): Promise<readDeploymentDeploymentsIdGetResponse> => {
	const res = await fetch(getReadDeploymentDeploymentsIdGetUrl(id), {
		...options,
		method: "GET",
	});

	const body = [204, 205, 304].includes(res.status) ? null : await res.text();
	const data: readDeploymentDeploymentsIdGetResponse["data"] = body
		? JSON.parse(body)
		: {};

	return {
		data,
		status: res.status,
		headers: res.headers,
	} as readDeploymentDeploymentsIdGetResponse;
};

export const getReadDeploymentDeploymentsIdGetQueryKey = (id: string) => {
	return [`http://prefect.grose.click/api/deployments/${id}`] as const;
};

export const getReadDeploymentDeploymentsIdGetQueryOptions = <
	TData = Awaited<ReturnType<typeof readDeploymentDeploymentsIdGet>>,
	TError = HTTPValidationError,
>(
	id: string,
	options?: {
		query?: Partial<
			UseQueryOptions<
				Awaited<ReturnType<typeof readDeploymentDeploymentsIdGet>>,
				TError,
				TData
			>
		>;
		fetch?: RequestInit;
	},
) => {
	const { query: queryOptions, fetch: fetchOptions } = options ?? {};

	const queryKey =
		queryOptions?.queryKey ?? getReadDeploymentDeploymentsIdGetQueryKey(id);

	const queryFn: QueryFunction<
		Awaited<ReturnType<typeof readDeploymentDeploymentsIdGet>>
	> = ({ signal }) =>
		readDeploymentDeploymentsIdGet(id, { signal, ...fetchOptions });

	return {
		queryKey,
		queryFn,
		enabled: !!id,
		...queryOptions,
	} as UseQueryOptions<
		Awaited<ReturnType<typeof readDeploymentDeploymentsIdGet>>,
		TError,
		TData
	> & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type ReadDeploymentDeploymentsIdGetQueryResult = NonNullable<
	Awaited<ReturnType<typeof readDeploymentDeploymentsIdGet>>
>;
export type ReadDeploymentDeploymentsIdGetQueryError = HTTPValidationError;

export function useReadDeploymentDeploymentsIdGet<
	TData = Awaited<ReturnType<typeof readDeploymentDeploymentsIdGet>>,
	TError = HTTPValidationError,
>(
	id: string,
	options: {
		query: Partial<
			UseQueryOptions<
				Awaited<ReturnType<typeof readDeploymentDeploymentsIdGet>>,
				TError,
				TData
			>
		> &
			Pick<
				DefinedInitialDataOptions<
					Awaited<ReturnType<typeof readDeploymentDeploymentsIdGet>>,
					TError,
					Awaited<ReturnType<typeof readDeploymentDeploymentsIdGet>>
				>,
				"initialData"
			>;
		fetch?: RequestInit;
	},
): DefinedUseQueryResult<TData, TError> & {
	queryKey: DataTag<QueryKey, TData, TError>;
};
export function useReadDeploymentDeploymentsIdGet<
	TData = Awaited<ReturnType<typeof readDeploymentDeploymentsIdGet>>,
	TError = HTTPValidationError,
>(
	id: string,
	options?: {
		query?: Partial<
			UseQueryOptions<
				Awaited<ReturnType<typeof readDeploymentDeploymentsIdGet>>,
				TError,
				TData
			>
		> &
			Pick<
				UndefinedInitialDataOptions<
					Awaited<ReturnType<typeof readDeploymentDeploymentsIdGet>>,
					TError,
					Awaited<ReturnType<typeof readDeploymentDeploymentsIdGet>>
				>,
				"initialData"
			>;
		fetch?: RequestInit;
	},
): UseQueryResult<TData, TError> & {
	queryKey: DataTag<QueryKey, TData, TError>;
};
export function useReadDeploymentDeploymentsIdGet<
	TData = Awaited<ReturnType<typeof readDeploymentDeploymentsIdGet>>,
	TError = HTTPValidationError,
>(
	id: string,
	options?: {
		query?: Partial<
			UseQueryOptions<
				Awaited<ReturnType<typeof readDeploymentDeploymentsIdGet>>,
				TError,
				TData
			>
		>;
		fetch?: RequestInit;
	},
): UseQueryResult<TData, TError> & {
	queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Read Deployment
 */

export function useReadDeploymentDeploymentsIdGet<
	TData = Awaited<ReturnType<typeof readDeploymentDeploymentsIdGet>>,
	TError = HTTPValidationError,
>(
	id: string,
	options?: {
		query?: Partial<
			UseQueryOptions<
				Awaited<ReturnType<typeof readDeploymentDeploymentsIdGet>>,
				TError,
				TData
			>
		>;
		fetch?: RequestInit;
	},
): UseQueryResult<TData, TError> & {
	queryKey: DataTag<QueryKey, TData, TError>;
} {
	const queryOptions = getReadDeploymentDeploymentsIdGetQueryOptions(
		id,
		options,
	);

	const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
		queryKey: DataTag<QueryKey, TData, TError>;
	};

	query.queryKey = queryOptions.queryKey;

	return query;
}

export const getReadDeploymentDeploymentsIdGetSuspenseQueryOptions = <
	TData = Awaited<ReturnType<typeof readDeploymentDeploymentsIdGet>>,
	TError = HTTPValidationError,
>(
	id: string,
	options?: {
		query?: Partial<
			UseSuspenseQueryOptions<
				Awaited<ReturnType<typeof readDeploymentDeploymentsIdGet>>,
				TError,
				TData
			>
		>;
		fetch?: RequestInit;
	},
) => {
	const { query: queryOptions, fetch: fetchOptions } = options ?? {};

	const queryKey =
		queryOptions?.queryKey ?? getReadDeploymentDeploymentsIdGetQueryKey(id);

	const queryFn: QueryFunction<
		Awaited<ReturnType<typeof readDeploymentDeploymentsIdGet>>
	> = ({ signal }) =>
		readDeploymentDeploymentsIdGet(id, { signal, ...fetchOptions });

	return { queryKey, queryFn, ...queryOptions } as UseSuspenseQueryOptions<
		Awaited<ReturnType<typeof readDeploymentDeploymentsIdGet>>,
		TError,
		TData
	> & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type ReadDeploymentDeploymentsIdGetSuspenseQueryResult = NonNullable<
	Awaited<ReturnType<typeof readDeploymentDeploymentsIdGet>>
>;
export type ReadDeploymentDeploymentsIdGetSuspenseQueryError =
	HTTPValidationError;

export function useReadDeploymentDeploymentsIdGetSuspense<
	TData = Awaited<ReturnType<typeof readDeploymentDeploymentsIdGet>>,
	TError = HTTPValidationError,
>(
	id: string,
	options: {
		query: Partial<
			UseSuspenseQueryOptions<
				Awaited<ReturnType<typeof readDeploymentDeploymentsIdGet>>,
				TError,
				TData
			>
		>;
		fetch?: RequestInit;
	},
): UseSuspenseQueryResult<TData, TError> & {
	queryKey: DataTag<QueryKey, TData, TError>;
};
export function useReadDeploymentDeploymentsIdGetSuspense<
	TData = Awaited<ReturnType<typeof readDeploymentDeploymentsIdGet>>,
	TError = HTTPValidationError,
>(
	id: string,
	options?: {
		query?: Partial<
			UseSuspenseQueryOptions<
				Awaited<ReturnType<typeof readDeploymentDeploymentsIdGet>>,
				TError,
				TData
			>
		>;
		fetch?: RequestInit;
	},
): UseSuspenseQueryResult<TData, TError> & {
	queryKey: DataTag<QueryKey, TData, TError>;
};
export function useReadDeploymentDeploymentsIdGetSuspense<
	TData = Awaited<ReturnType<typeof readDeploymentDeploymentsIdGet>>,
	TError = HTTPValidationError,
>(
	id: string,
	options?: {
		query?: Partial<
			UseSuspenseQueryOptions<
				Awaited<ReturnType<typeof readDeploymentDeploymentsIdGet>>,
				TError,
				TData
			>
		>;
		fetch?: RequestInit;
	},
): UseSuspenseQueryResult<TData, TError> & {
	queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Read Deployment
 */

export function useReadDeploymentDeploymentsIdGetSuspense<
	TData = Awaited<ReturnType<typeof readDeploymentDeploymentsIdGet>>,
	TError = HTTPValidationError,
>(
	id: string,
	options?: {
		query?: Partial<
			UseSuspenseQueryOptions<
				Awaited<ReturnType<typeof readDeploymentDeploymentsIdGet>>,
				TError,
				TData
			>
		>;
		fetch?: RequestInit;
	},
): UseSuspenseQueryResult<TData, TError> & {
	queryKey: DataTag<QueryKey, TData, TError>;
} {
	const queryOptions = getReadDeploymentDeploymentsIdGetSuspenseQueryOptions(
		id,
		options,
	);

	const query = useSuspenseQuery(queryOptions) as UseSuspenseQueryResult<
		TData,
		TError
	> & { queryKey: DataTag<QueryKey, TData, TError> };

	query.queryKey = queryOptions.queryKey;

	return query;
}

/**
 * Delete a deployment by id.
 * @summary Delete Deployment
 */
export type deleteDeploymentDeploymentsIdDeleteResponse = {
	data: void | HTTPValidationError;
	status: number;
	headers: Headers;
};

export const getDeleteDeploymentDeploymentsIdDeleteUrl = (id: string) => {
	return `http://prefect.grose.click/api/deployments/${id}`;
};

export const deleteDeploymentDeploymentsIdDelete = async (
	id: string,
	options?: RequestInit,
): Promise<deleteDeploymentDeploymentsIdDeleteResponse> => {
	const res = await fetch(getDeleteDeploymentDeploymentsIdDeleteUrl(id), {
		...options,
		method: "DELETE",
	});

	const body = [204, 205, 304].includes(res.status) ? null : await res.text();
	const data: deleteDeploymentDeploymentsIdDeleteResponse["data"] = body
		? JSON.parse(body)
		: {};

	return {
		data,
		status: res.status,
		headers: res.headers,
	} as deleteDeploymentDeploymentsIdDeleteResponse;
};

export const getDeleteDeploymentDeploymentsIdDeleteMutationOptions = <
	TError = HTTPValidationError,
	TContext = unknown,
>(options?: {
	mutation?: UseMutationOptions<
		Awaited<ReturnType<typeof deleteDeploymentDeploymentsIdDelete>>,
		TError,
		{ id: string },
		TContext
	>;
	fetch?: RequestInit;
}): UseMutationOptions<
	Awaited<ReturnType<typeof deleteDeploymentDeploymentsIdDelete>>,
	TError,
	{ id: string },
	TContext
> => {
	const mutationKey = ["deleteDeploymentDeploymentsIdDelete"];
	const { mutation: mutationOptions, fetch: fetchOptions } = options
		? options.mutation &&
			"mutationKey" in options.mutation &&
			options.mutation.mutationKey
			? options
			: { ...options, mutation: { ...options.mutation, mutationKey } }
		: { mutation: { mutationKey }, fetch: undefined };

	const mutationFn: MutationFunction<
		Awaited<ReturnType<typeof deleteDeploymentDeploymentsIdDelete>>,
		{ id: string }
	> = (props) => {
		const { id } = props ?? {};

		return deleteDeploymentDeploymentsIdDelete(id, fetchOptions);
	};

	return { mutationFn, ...mutationOptions };
};

export type DeleteDeploymentDeploymentsIdDeleteMutationResult = NonNullable<
	Awaited<ReturnType<typeof deleteDeploymentDeploymentsIdDelete>>
>;

export type DeleteDeploymentDeploymentsIdDeleteMutationError =
	HTTPValidationError;

/**
 * @summary Delete Deployment
 */
export const useDeleteDeploymentDeploymentsIdDelete = <
	TError = HTTPValidationError,
	TContext = unknown,
>(options?: {
	mutation?: UseMutationOptions<
		Awaited<ReturnType<typeof deleteDeploymentDeploymentsIdDelete>>,
		TError,
		{ id: string },
		TContext
	>;
	fetch?: RequestInit;
}): UseMutationResult<
	Awaited<ReturnType<typeof deleteDeploymentDeploymentsIdDelete>>,
	TError,
	{ id: string },
	TContext
> => {
	const mutationOptions =
		getDeleteDeploymentDeploymentsIdDeleteMutationOptions(options);

	return useMutation(mutationOptions);
};
/**
 * Get a deployment using the name of the flow and the deployment.
 * @summary Read Deployment By Name
 */
export type readDeploymentByNameDeploymentsNameFlowNameDeploymentNameGetResponse =
	{
		data: DeploymentResponse | HTTPValidationError;
		status: number;
		headers: Headers;
	};

export const getReadDeploymentByNameDeploymentsNameFlowNameDeploymentNameGetUrl =
	(flowName: string, deploymentName: string) => {
		return `http://prefect.grose.click/api/deployments/name/${flowName}/${deploymentName}`;
	};

export const readDeploymentByNameDeploymentsNameFlowNameDeploymentNameGet =
	async (
		flowName: string,
		deploymentName: string,
		options?: RequestInit,
	): Promise<readDeploymentByNameDeploymentsNameFlowNameDeploymentNameGetResponse> => {
		const res = await fetch(
			getReadDeploymentByNameDeploymentsNameFlowNameDeploymentNameGetUrl(
				flowName,
				deploymentName,
			),
			{
				...options,
				method: "GET",
			},
		);

		const body = [204, 205, 304].includes(res.status) ? null : await res.text();
		const data: readDeploymentByNameDeploymentsNameFlowNameDeploymentNameGetResponse["data"] =
			body ? JSON.parse(body) : {};

		return {
			data,
			status: res.status,
			headers: res.headers,
		} as readDeploymentByNameDeploymentsNameFlowNameDeploymentNameGetResponse;
	};

export const getReadDeploymentByNameDeploymentsNameFlowNameDeploymentNameGetQueryKey =
	(flowName: string, deploymentName: string) => {
		return [
			`http://prefect.grose.click/api/deployments/name/${flowName}/${deploymentName}`,
		] as const;
	};

export const getReadDeploymentByNameDeploymentsNameFlowNameDeploymentNameGetQueryOptions =
	<
		TData = Awaited<
			ReturnType<
				typeof readDeploymentByNameDeploymentsNameFlowNameDeploymentNameGet
			>
		>,
		TError = HTTPValidationError,
	>(
		flowName: string,
		deploymentName: string,
		options?: {
			query?: Partial<
				UseQueryOptions<
					Awaited<
						ReturnType<
							typeof readDeploymentByNameDeploymentsNameFlowNameDeploymentNameGet
						>
					>,
					TError,
					TData
				>
			>;
			fetch?: RequestInit;
		},
	) => {
		const { query: queryOptions, fetch: fetchOptions } = options ?? {};

		const queryKey =
			queryOptions?.queryKey ??
			getReadDeploymentByNameDeploymentsNameFlowNameDeploymentNameGetQueryKey(
				flowName,
				deploymentName,
			);

		const queryFn: QueryFunction<
			Awaited<
				ReturnType<
					typeof readDeploymentByNameDeploymentsNameFlowNameDeploymentNameGet
				>
			>
		> = ({ signal }) =>
			readDeploymentByNameDeploymentsNameFlowNameDeploymentNameGet(
				flowName,
				deploymentName,
				{ signal, ...fetchOptions },
			);

		return {
			queryKey,
			queryFn,
			enabled: !!(flowName && deploymentName),
			...queryOptions,
		} as UseQueryOptions<
			Awaited<
				ReturnType<
					typeof readDeploymentByNameDeploymentsNameFlowNameDeploymentNameGet
				>
			>,
			TError,
			TData
		> & { queryKey: DataTag<QueryKey, TData, TError> };
	};

export type ReadDeploymentByNameDeploymentsNameFlowNameDeploymentNameGetQueryResult =
	NonNullable<
		Awaited<
			ReturnType<
				typeof readDeploymentByNameDeploymentsNameFlowNameDeploymentNameGet
			>
		>
	>;
export type ReadDeploymentByNameDeploymentsNameFlowNameDeploymentNameGetQueryError =
	HTTPValidationError;

export function useReadDeploymentByNameDeploymentsNameFlowNameDeploymentNameGet<
	TData = Awaited<
		ReturnType<
			typeof readDeploymentByNameDeploymentsNameFlowNameDeploymentNameGet
		>
	>,
	TError = HTTPValidationError,
>(
	flowName: string,
	deploymentName: string,
	options: {
		query: Partial<
			UseQueryOptions<
				Awaited<
					ReturnType<
						typeof readDeploymentByNameDeploymentsNameFlowNameDeploymentNameGet
					>
				>,
				TError,
				TData
			>
		> &
			Pick<
				DefinedInitialDataOptions<
					Awaited<
						ReturnType<
							typeof readDeploymentByNameDeploymentsNameFlowNameDeploymentNameGet
						>
					>,
					TError,
					Awaited<
						ReturnType<
							typeof readDeploymentByNameDeploymentsNameFlowNameDeploymentNameGet
						>
					>
				>,
				"initialData"
			>;
		fetch?: RequestInit;
	},
): DefinedUseQueryResult<TData, TError> & {
	queryKey: DataTag<QueryKey, TData, TError>;
};
export function useReadDeploymentByNameDeploymentsNameFlowNameDeploymentNameGet<
	TData = Awaited<
		ReturnType<
			typeof readDeploymentByNameDeploymentsNameFlowNameDeploymentNameGet
		>
	>,
	TError = HTTPValidationError,
>(
	flowName: string,
	deploymentName: string,
	options?: {
		query?: Partial<
			UseQueryOptions<
				Awaited<
					ReturnType<
						typeof readDeploymentByNameDeploymentsNameFlowNameDeploymentNameGet
					>
				>,
				TError,
				TData
			>
		> &
			Pick<
				UndefinedInitialDataOptions<
					Awaited<
						ReturnType<
							typeof readDeploymentByNameDeploymentsNameFlowNameDeploymentNameGet
						>
					>,
					TError,
					Awaited<
						ReturnType<
							typeof readDeploymentByNameDeploymentsNameFlowNameDeploymentNameGet
						>
					>
				>,
				"initialData"
			>;
		fetch?: RequestInit;
	},
): UseQueryResult<TData, TError> & {
	queryKey: DataTag<QueryKey, TData, TError>;
};
export function useReadDeploymentByNameDeploymentsNameFlowNameDeploymentNameGet<
	TData = Awaited<
		ReturnType<
			typeof readDeploymentByNameDeploymentsNameFlowNameDeploymentNameGet
		>
	>,
	TError = HTTPValidationError,
>(
	flowName: string,
	deploymentName: string,
	options?: {
		query?: Partial<
			UseQueryOptions<
				Awaited<
					ReturnType<
						typeof readDeploymentByNameDeploymentsNameFlowNameDeploymentNameGet
					>
				>,
				TError,
				TData
			>
		>;
		fetch?: RequestInit;
	},
): UseQueryResult<TData, TError> & {
	queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Read Deployment By Name
 */

export function useReadDeploymentByNameDeploymentsNameFlowNameDeploymentNameGet<
	TData = Awaited<
		ReturnType<
			typeof readDeploymentByNameDeploymentsNameFlowNameDeploymentNameGet
		>
	>,
	TError = HTTPValidationError,
>(
	flowName: string,
	deploymentName: string,
	options?: {
		query?: Partial<
			UseQueryOptions<
				Awaited<
					ReturnType<
						typeof readDeploymentByNameDeploymentsNameFlowNameDeploymentNameGet
					>
				>,
				TError,
				TData
			>
		>;
		fetch?: RequestInit;
	},
): UseQueryResult<TData, TError> & {
	queryKey: DataTag<QueryKey, TData, TError>;
} {
	const queryOptions =
		getReadDeploymentByNameDeploymentsNameFlowNameDeploymentNameGetQueryOptions(
			flowName,
			deploymentName,
			options,
		);

	const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
		queryKey: DataTag<QueryKey, TData, TError>;
	};

	query.queryKey = queryOptions.queryKey;

	return query;
}

export const getReadDeploymentByNameDeploymentsNameFlowNameDeploymentNameGetSuspenseQueryOptions =
	<
		TData = Awaited<
			ReturnType<
				typeof readDeploymentByNameDeploymentsNameFlowNameDeploymentNameGet
			>
		>,
		TError = HTTPValidationError,
	>(
		flowName: string,
		deploymentName: string,
		options?: {
			query?: Partial<
				UseSuspenseQueryOptions<
					Awaited<
						ReturnType<
							typeof readDeploymentByNameDeploymentsNameFlowNameDeploymentNameGet
						>
					>,
					TError,
					TData
				>
			>;
			fetch?: RequestInit;
		},
	) => {
		const { query: queryOptions, fetch: fetchOptions } = options ?? {};

		const queryKey =
			queryOptions?.queryKey ??
			getReadDeploymentByNameDeploymentsNameFlowNameDeploymentNameGetQueryKey(
				flowName,
				deploymentName,
			);

		const queryFn: QueryFunction<
			Awaited<
				ReturnType<
					typeof readDeploymentByNameDeploymentsNameFlowNameDeploymentNameGet
				>
			>
		> = ({ signal }) =>
			readDeploymentByNameDeploymentsNameFlowNameDeploymentNameGet(
				flowName,
				deploymentName,
				{ signal, ...fetchOptions },
			);

		return { queryKey, queryFn, ...queryOptions } as UseSuspenseQueryOptions<
			Awaited<
				ReturnType<
					typeof readDeploymentByNameDeploymentsNameFlowNameDeploymentNameGet
				>
			>,
			TError,
			TData
		> & { queryKey: DataTag<QueryKey, TData, TError> };
	};

export type ReadDeploymentByNameDeploymentsNameFlowNameDeploymentNameGetSuspenseQueryResult =
	NonNullable<
		Awaited<
			ReturnType<
				typeof readDeploymentByNameDeploymentsNameFlowNameDeploymentNameGet
			>
		>
	>;
export type ReadDeploymentByNameDeploymentsNameFlowNameDeploymentNameGetSuspenseQueryError =
	HTTPValidationError;

export function useReadDeploymentByNameDeploymentsNameFlowNameDeploymentNameGetSuspense<
	TData = Awaited<
		ReturnType<
			typeof readDeploymentByNameDeploymentsNameFlowNameDeploymentNameGet
		>
	>,
	TError = HTTPValidationError,
>(
	flowName: string,
	deploymentName: string,
	options: {
		query: Partial<
			UseSuspenseQueryOptions<
				Awaited<
					ReturnType<
						typeof readDeploymentByNameDeploymentsNameFlowNameDeploymentNameGet
					>
				>,
				TError,
				TData
			>
		>;
		fetch?: RequestInit;
	},
): UseSuspenseQueryResult<TData, TError> & {
	queryKey: DataTag<QueryKey, TData, TError>;
};
export function useReadDeploymentByNameDeploymentsNameFlowNameDeploymentNameGetSuspense<
	TData = Awaited<
		ReturnType<
			typeof readDeploymentByNameDeploymentsNameFlowNameDeploymentNameGet
		>
	>,
	TError = HTTPValidationError,
>(
	flowName: string,
	deploymentName: string,
	options?: {
		query?: Partial<
			UseSuspenseQueryOptions<
				Awaited<
					ReturnType<
						typeof readDeploymentByNameDeploymentsNameFlowNameDeploymentNameGet
					>
				>,
				TError,
				TData
			>
		>;
		fetch?: RequestInit;
	},
): UseSuspenseQueryResult<TData, TError> & {
	queryKey: DataTag<QueryKey, TData, TError>;
};
export function useReadDeploymentByNameDeploymentsNameFlowNameDeploymentNameGetSuspense<
	TData = Awaited<
		ReturnType<
			typeof readDeploymentByNameDeploymentsNameFlowNameDeploymentNameGet
		>
	>,
	TError = HTTPValidationError,
>(
	flowName: string,
	deploymentName: string,
	options?: {
		query?: Partial<
			UseSuspenseQueryOptions<
				Awaited<
					ReturnType<
						typeof readDeploymentByNameDeploymentsNameFlowNameDeploymentNameGet
					>
				>,
				TError,
				TData
			>
		>;
		fetch?: RequestInit;
	},
): UseSuspenseQueryResult<TData, TError> & {
	queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Read Deployment By Name
 */

export function useReadDeploymentByNameDeploymentsNameFlowNameDeploymentNameGetSuspense<
	TData = Awaited<
		ReturnType<
			typeof readDeploymentByNameDeploymentsNameFlowNameDeploymentNameGet
		>
	>,
	TError = HTTPValidationError,
>(
	flowName: string,
	deploymentName: string,
	options?: {
		query?: Partial<
			UseSuspenseQueryOptions<
				Awaited<
					ReturnType<
						typeof readDeploymentByNameDeploymentsNameFlowNameDeploymentNameGet
					>
				>,
				TError,
				TData
			>
		>;
		fetch?: RequestInit;
	},
): UseSuspenseQueryResult<TData, TError> & {
	queryKey: DataTag<QueryKey, TData, TError>;
} {
	const queryOptions =
		getReadDeploymentByNameDeploymentsNameFlowNameDeploymentNameGetSuspenseQueryOptions(
			flowName,
			deploymentName,
			options,
		);

	const query = useSuspenseQuery(queryOptions) as UseSuspenseQueryResult<
		TData,
		TError
	> & { queryKey: DataTag<QueryKey, TData, TError> };

	query.queryKey = queryOptions.queryKey;

	return query;
}

/**
 * Query for deployments.
 * @summary Read Deployments
 */
export type readDeploymentsDeploymentsFilterPostResponse = {
	data: DeploymentResponse[] | HTTPValidationError;
	status: number;
	headers: Headers;
};

export const getReadDeploymentsDeploymentsFilterPostUrl = () => {
	return `http://prefect.grose.click/api/deployments/filter`;
};

export const readDeploymentsDeploymentsFilterPost = async (
	bodyReadDeploymentsDeploymentsFilterPost: BodyReadDeploymentsDeploymentsFilterPost,
	options?: RequestInit,
): Promise<readDeploymentsDeploymentsFilterPostResponse> => {
	const res = await fetch(getReadDeploymentsDeploymentsFilterPostUrl(), {
		...options,
		method: "POST",
		headers: { "Content-Type": "application/json", ...options?.headers },
		body: JSON.stringify(bodyReadDeploymentsDeploymentsFilterPost),
	});

	const body = [204, 205, 304].includes(res.status) ? null : await res.text();
	const data: readDeploymentsDeploymentsFilterPostResponse["data"] = body
		? JSON.parse(body)
		: {};

	return {
		data,
		status: res.status,
		headers: res.headers,
	} as readDeploymentsDeploymentsFilterPostResponse;
};

export const getReadDeploymentsDeploymentsFilterPostMutationOptions = <
	TError = HTTPValidationError,
	TContext = unknown,
>(options?: {
	mutation?: UseMutationOptions<
		Awaited<ReturnType<typeof readDeploymentsDeploymentsFilterPost>>,
		TError,
		{ data: BodyReadDeploymentsDeploymentsFilterPost },
		TContext
	>;
	fetch?: RequestInit;
}): UseMutationOptions<
	Awaited<ReturnType<typeof readDeploymentsDeploymentsFilterPost>>,
	TError,
	{ data: BodyReadDeploymentsDeploymentsFilterPost },
	TContext
> => {
	const mutationKey = ["readDeploymentsDeploymentsFilterPost"];
	const { mutation: mutationOptions, fetch: fetchOptions } = options
		? options.mutation &&
			"mutationKey" in options.mutation &&
			options.mutation.mutationKey
			? options
			: { ...options, mutation: { ...options.mutation, mutationKey } }
		: { mutation: { mutationKey }, fetch: undefined };

	const mutationFn: MutationFunction<
		Awaited<ReturnType<typeof readDeploymentsDeploymentsFilterPost>>,
		{ data: BodyReadDeploymentsDeploymentsFilterPost }
	> = (props) => {
		const { data } = props ?? {};

		return readDeploymentsDeploymentsFilterPost(data, fetchOptions);
	};

	return { mutationFn, ...mutationOptions };
};

export type ReadDeploymentsDeploymentsFilterPostMutationResult = NonNullable<
	Awaited<ReturnType<typeof readDeploymentsDeploymentsFilterPost>>
>;
export type ReadDeploymentsDeploymentsFilterPostMutationBody =
	BodyReadDeploymentsDeploymentsFilterPost;
export type ReadDeploymentsDeploymentsFilterPostMutationError =
	HTTPValidationError;

/**
 * @summary Read Deployments
 */
export const useReadDeploymentsDeploymentsFilterPost = <
	TError = HTTPValidationError,
	TContext = unknown,
>(options?: {
	mutation?: UseMutationOptions<
		Awaited<ReturnType<typeof readDeploymentsDeploymentsFilterPost>>,
		TError,
		{ data: BodyReadDeploymentsDeploymentsFilterPost },
		TContext
	>;
	fetch?: RequestInit;
}): UseMutationResult<
	Awaited<ReturnType<typeof readDeploymentsDeploymentsFilterPost>>,
	TError,
	{ data: BodyReadDeploymentsDeploymentsFilterPost },
	TContext
> => {
	const mutationOptions =
		getReadDeploymentsDeploymentsFilterPostMutationOptions(options);

	return useMutation(mutationOptions);
};
/**
 * Pagination query for flow runs.
 * @summary Paginate Deployments
 */
export type paginateDeploymentsDeploymentsPaginatePostResponse = {
	data: DeploymentPaginationResponse | HTTPValidationError;
	status: number;
	headers: Headers;
};

export const getPaginateDeploymentsDeploymentsPaginatePostUrl = () => {
	return `http://prefect.grose.click/api/deployments/paginate`;
};

export const paginateDeploymentsDeploymentsPaginatePost = async (
	bodyPaginateDeploymentsDeploymentsPaginatePost: BodyPaginateDeploymentsDeploymentsPaginatePost,
	options?: RequestInit,
): Promise<paginateDeploymentsDeploymentsPaginatePostResponse> => {
	const res = await fetch(getPaginateDeploymentsDeploymentsPaginatePostUrl(), {
		...options,
		method: "POST",
		headers: { "Content-Type": "application/json", ...options?.headers },
		body: JSON.stringify(bodyPaginateDeploymentsDeploymentsPaginatePost),
	});

	const body = [204, 205, 304].includes(res.status) ? null : await res.text();
	const data: paginateDeploymentsDeploymentsPaginatePostResponse["data"] = body
		? JSON.parse(body)
		: {};

	return {
		data,
		status: res.status,
		headers: res.headers,
	} as paginateDeploymentsDeploymentsPaginatePostResponse;
};

export const getPaginateDeploymentsDeploymentsPaginatePostMutationOptions = <
	TError = HTTPValidationError,
	TContext = unknown,
>(options?: {
	mutation?: UseMutationOptions<
		Awaited<ReturnType<typeof paginateDeploymentsDeploymentsPaginatePost>>,
		TError,
		{ data: BodyPaginateDeploymentsDeploymentsPaginatePost },
		TContext
	>;
	fetch?: RequestInit;
}): UseMutationOptions<
	Awaited<ReturnType<typeof paginateDeploymentsDeploymentsPaginatePost>>,
	TError,
	{ data: BodyPaginateDeploymentsDeploymentsPaginatePost },
	TContext
> => {
	const mutationKey = ["paginateDeploymentsDeploymentsPaginatePost"];
	const { mutation: mutationOptions, fetch: fetchOptions } = options
		? options.mutation &&
			"mutationKey" in options.mutation &&
			options.mutation.mutationKey
			? options
			: { ...options, mutation: { ...options.mutation, mutationKey } }
		: { mutation: { mutationKey }, fetch: undefined };

	const mutationFn: MutationFunction<
		Awaited<ReturnType<typeof paginateDeploymentsDeploymentsPaginatePost>>,
		{ data: BodyPaginateDeploymentsDeploymentsPaginatePost }
	> = (props) => {
		const { data } = props ?? {};

		return paginateDeploymentsDeploymentsPaginatePost(data, fetchOptions);
	};

	return { mutationFn, ...mutationOptions };
};

export type PaginateDeploymentsDeploymentsPaginatePostMutationResult =
	NonNullable<
		Awaited<ReturnType<typeof paginateDeploymentsDeploymentsPaginatePost>>
	>;
export type PaginateDeploymentsDeploymentsPaginatePostMutationBody =
	BodyPaginateDeploymentsDeploymentsPaginatePost;
export type PaginateDeploymentsDeploymentsPaginatePostMutationError =
	HTTPValidationError;

/**
 * @summary Paginate Deployments
 */
export const usePaginateDeploymentsDeploymentsPaginatePost = <
	TError = HTTPValidationError,
	TContext = unknown,
>(options?: {
	mutation?: UseMutationOptions<
		Awaited<ReturnType<typeof paginateDeploymentsDeploymentsPaginatePost>>,
		TError,
		{ data: BodyPaginateDeploymentsDeploymentsPaginatePost },
		TContext
	>;
	fetch?: RequestInit;
}): UseMutationResult<
	Awaited<ReturnType<typeof paginateDeploymentsDeploymentsPaginatePost>>,
	TError,
	{ data: BodyPaginateDeploymentsDeploymentsPaginatePost },
	TContext
> => {
	const mutationOptions =
		getPaginateDeploymentsDeploymentsPaginatePostMutationOptions(options);

	return useMutation(mutationOptions);
};
/**
 * Get scheduled runs for a set of deployments. Used by a runner to poll for work.
 * @summary Get Scheduled Flow Runs For Deployments
 */
export type getScheduledFlowRunsForDeploymentsDeploymentsGetScheduledFlowRunsPostResponse =
	{
		data: FlowRunResponse[] | HTTPValidationError;
		status: number;
		headers: Headers;
	};

export const getGetScheduledFlowRunsForDeploymentsDeploymentsGetScheduledFlowRunsPostUrl =
	() => {
		return `http://prefect.grose.click/api/deployments/get_scheduled_flow_runs`;
	};

export const getScheduledFlowRunsForDeploymentsDeploymentsGetScheduledFlowRunsPost =
	async (
		bodyGetScheduledFlowRunsForDeploymentsDeploymentsGetScheduledFlowRunsPost: BodyGetScheduledFlowRunsForDeploymentsDeploymentsGetScheduledFlowRunsPost,
		options?: RequestInit,
	): Promise<getScheduledFlowRunsForDeploymentsDeploymentsGetScheduledFlowRunsPostResponse> => {
		const res = await fetch(
			getGetScheduledFlowRunsForDeploymentsDeploymentsGetScheduledFlowRunsPostUrl(),
			{
				...options,
				method: "POST",
				headers: { "Content-Type": "application/json", ...options?.headers },
				body: JSON.stringify(
					bodyGetScheduledFlowRunsForDeploymentsDeploymentsGetScheduledFlowRunsPost,
				),
			},
		);

		const body = [204, 205, 304].includes(res.status) ? null : await res.text();
		const data: getScheduledFlowRunsForDeploymentsDeploymentsGetScheduledFlowRunsPostResponse["data"] =
			body ? JSON.parse(body) : {};

		return {
			data,
			status: res.status,
			headers: res.headers,
		} as getScheduledFlowRunsForDeploymentsDeploymentsGetScheduledFlowRunsPostResponse;
	};

export const getGetScheduledFlowRunsForDeploymentsDeploymentsGetScheduledFlowRunsPostMutationOptions =
	<TError = HTTPValidationError, TContext = unknown>(options?: {
		mutation?: UseMutationOptions<
			Awaited<
				ReturnType<
					typeof getScheduledFlowRunsForDeploymentsDeploymentsGetScheduledFlowRunsPost
				>
			>,
			TError,
			{
				data: BodyGetScheduledFlowRunsForDeploymentsDeploymentsGetScheduledFlowRunsPost;
			},
			TContext
		>;
		fetch?: RequestInit;
	}): UseMutationOptions<
		Awaited<
			ReturnType<
				typeof getScheduledFlowRunsForDeploymentsDeploymentsGetScheduledFlowRunsPost
			>
		>,
		TError,
		{
			data: BodyGetScheduledFlowRunsForDeploymentsDeploymentsGetScheduledFlowRunsPost;
		},
		TContext
	> => {
		const mutationKey = [
			"getScheduledFlowRunsForDeploymentsDeploymentsGetScheduledFlowRunsPost",
		];
		const { mutation: mutationOptions, fetch: fetchOptions } = options
			? options.mutation &&
				"mutationKey" in options.mutation &&
				options.mutation.mutationKey
				? options
				: { ...options, mutation: { ...options.mutation, mutationKey } }
			: { mutation: { mutationKey }, fetch: undefined };

		const mutationFn: MutationFunction<
			Awaited<
				ReturnType<
					typeof getScheduledFlowRunsForDeploymentsDeploymentsGetScheduledFlowRunsPost
				>
			>,
			{
				data: BodyGetScheduledFlowRunsForDeploymentsDeploymentsGetScheduledFlowRunsPost;
			}
		> = (props) => {
			const { data } = props ?? {};

			return getScheduledFlowRunsForDeploymentsDeploymentsGetScheduledFlowRunsPost(
				data,
				fetchOptions,
			);
		};

		return { mutationFn, ...mutationOptions };
	};

export type GetScheduledFlowRunsForDeploymentsDeploymentsGetScheduledFlowRunsPostMutationResult =
	NonNullable<
		Awaited<
			ReturnType<
				typeof getScheduledFlowRunsForDeploymentsDeploymentsGetScheduledFlowRunsPost
			>
		>
	>;
export type GetScheduledFlowRunsForDeploymentsDeploymentsGetScheduledFlowRunsPostMutationBody =
	BodyGetScheduledFlowRunsForDeploymentsDeploymentsGetScheduledFlowRunsPost;
export type GetScheduledFlowRunsForDeploymentsDeploymentsGetScheduledFlowRunsPostMutationError =
	HTTPValidationError;

/**
 * @summary Get Scheduled Flow Runs For Deployments
 */
export const useGetScheduledFlowRunsForDeploymentsDeploymentsGetScheduledFlowRunsPost =
	<TError = HTTPValidationError, TContext = unknown>(options?: {
		mutation?: UseMutationOptions<
			Awaited<
				ReturnType<
					typeof getScheduledFlowRunsForDeploymentsDeploymentsGetScheduledFlowRunsPost
				>
			>,
			TError,
			{
				data: BodyGetScheduledFlowRunsForDeploymentsDeploymentsGetScheduledFlowRunsPost;
			},
			TContext
		>;
		fetch?: RequestInit;
	}): UseMutationResult<
		Awaited<
			ReturnType<
				typeof getScheduledFlowRunsForDeploymentsDeploymentsGetScheduledFlowRunsPost
			>
		>,
		TError,
		{
			data: BodyGetScheduledFlowRunsForDeploymentsDeploymentsGetScheduledFlowRunsPost;
		},
		TContext
	> => {
		const mutationOptions =
			getGetScheduledFlowRunsForDeploymentsDeploymentsGetScheduledFlowRunsPostMutationOptions(
				options,
			);

		return useMutation(mutationOptions);
	};
/**
 * Count deployments.
 * @summary Count Deployments
 */
export type countDeploymentsDeploymentsCountPostResponse = {
	data: number | HTTPValidationError;
	status: number;
	headers: Headers;
};

export const getCountDeploymentsDeploymentsCountPostUrl = () => {
	return `http://prefect.grose.click/api/deployments/count`;
};

export const countDeploymentsDeploymentsCountPost = async (
	bodyCountDeploymentsDeploymentsCountPost: BodyCountDeploymentsDeploymentsCountPost,
	options?: RequestInit,
): Promise<countDeploymentsDeploymentsCountPostResponse> => {
	const res = await fetch(getCountDeploymentsDeploymentsCountPostUrl(), {
		...options,
		method: "POST",
		headers: { "Content-Type": "application/json", ...options?.headers },
		body: JSON.stringify(bodyCountDeploymentsDeploymentsCountPost),
	});

	const body = [204, 205, 304].includes(res.status) ? null : await res.text();
	const data: countDeploymentsDeploymentsCountPostResponse["data"] = body
		? JSON.parse(body)
		: {};

	return {
		data,
		status: res.status,
		headers: res.headers,
	} as countDeploymentsDeploymentsCountPostResponse;
};

export const getCountDeploymentsDeploymentsCountPostMutationOptions = <
	TError = HTTPValidationError,
	TContext = unknown,
>(options?: {
	mutation?: UseMutationOptions<
		Awaited<ReturnType<typeof countDeploymentsDeploymentsCountPost>>,
		TError,
		{ data: BodyCountDeploymentsDeploymentsCountPost },
		TContext
	>;
	fetch?: RequestInit;
}): UseMutationOptions<
	Awaited<ReturnType<typeof countDeploymentsDeploymentsCountPost>>,
	TError,
	{ data: BodyCountDeploymentsDeploymentsCountPost },
	TContext
> => {
	const mutationKey = ["countDeploymentsDeploymentsCountPost"];
	const { mutation: mutationOptions, fetch: fetchOptions } = options
		? options.mutation &&
			"mutationKey" in options.mutation &&
			options.mutation.mutationKey
			? options
			: { ...options, mutation: { ...options.mutation, mutationKey } }
		: { mutation: { mutationKey }, fetch: undefined };

	const mutationFn: MutationFunction<
		Awaited<ReturnType<typeof countDeploymentsDeploymentsCountPost>>,
		{ data: BodyCountDeploymentsDeploymentsCountPost }
	> = (props) => {
		const { data } = props ?? {};

		return countDeploymentsDeploymentsCountPost(data, fetchOptions);
	};

	return { mutationFn, ...mutationOptions };
};

export type CountDeploymentsDeploymentsCountPostMutationResult = NonNullable<
	Awaited<ReturnType<typeof countDeploymentsDeploymentsCountPost>>
>;
export type CountDeploymentsDeploymentsCountPostMutationBody =
	BodyCountDeploymentsDeploymentsCountPost;
export type CountDeploymentsDeploymentsCountPostMutationError =
	HTTPValidationError;

/**
 * @summary Count Deployments
 */
export const useCountDeploymentsDeploymentsCountPost = <
	TError = HTTPValidationError,
	TContext = unknown,
>(options?: {
	mutation?: UseMutationOptions<
		Awaited<ReturnType<typeof countDeploymentsDeploymentsCountPost>>,
		TError,
		{ data: BodyCountDeploymentsDeploymentsCountPost },
		TContext
	>;
	fetch?: RequestInit;
}): UseMutationResult<
	Awaited<ReturnType<typeof countDeploymentsDeploymentsCountPost>>,
	TError,
	{ data: BodyCountDeploymentsDeploymentsCountPost },
	TContext
> => {
	const mutationOptions =
		getCountDeploymentsDeploymentsCountPostMutationOptions(options);

	return useMutation(mutationOptions);
};
/**
 * Schedule runs for a deployment. For backfills, provide start/end times in the past.

This function will generate the minimum number of runs that satisfy the min
and max times, and the min and max counts. Specifically, the following order
will be respected.

    - Runs will be generated starting on or after the `start_time`
    - No more than `max_runs` runs will be generated
    - No runs will be generated after `end_time` is reached
    - At least `min_runs` runs will be generated
    - Runs will be generated until at least `start_time + min_time` is reached
 * @summary Schedule Deployment
 */
export type scheduleDeploymentDeploymentsIdSchedulePostResponse = {
	data: HTTPValidationError;
	status: number;
	headers: Headers;
};

export const getScheduleDeploymentDeploymentsIdSchedulePostUrl = (
	id: string,
) => {
	return `http://prefect.grose.click/api/deployments/${id}/schedule`;
};

export const scheduleDeploymentDeploymentsIdSchedulePost = async (
	id: string,
	bodyScheduleDeploymentDeploymentsIdSchedulePost: BodyScheduleDeploymentDeploymentsIdSchedulePost,
	options?: RequestInit,
): Promise<scheduleDeploymentDeploymentsIdSchedulePostResponse> => {
	const res = await fetch(
		getScheduleDeploymentDeploymentsIdSchedulePostUrl(id),
		{
			...options,
			method: "POST",
			headers: { "Content-Type": "application/json", ...options?.headers },
			body: JSON.stringify(bodyScheduleDeploymentDeploymentsIdSchedulePost),
		},
	);

	const body = [204, 205, 304].includes(res.status) ? null : await res.text();
	const data: scheduleDeploymentDeploymentsIdSchedulePostResponse["data"] = body
		? JSON.parse(body)
		: {};

	return {
		data,
		status: res.status,
		headers: res.headers,
	} as scheduleDeploymentDeploymentsIdSchedulePostResponse;
};

export const getScheduleDeploymentDeploymentsIdSchedulePostMutationOptions = <
	TError = HTTPValidationError,
	TContext = unknown,
>(options?: {
	mutation?: UseMutationOptions<
		Awaited<ReturnType<typeof scheduleDeploymentDeploymentsIdSchedulePost>>,
		TError,
		{ id: string; data: BodyScheduleDeploymentDeploymentsIdSchedulePost },
		TContext
	>;
	fetch?: RequestInit;
}): UseMutationOptions<
	Awaited<ReturnType<typeof scheduleDeploymentDeploymentsIdSchedulePost>>,
	TError,
	{ id: string; data: BodyScheduleDeploymentDeploymentsIdSchedulePost },
	TContext
> => {
	const mutationKey = ["scheduleDeploymentDeploymentsIdSchedulePost"];
	const { mutation: mutationOptions, fetch: fetchOptions } = options
		? options.mutation &&
			"mutationKey" in options.mutation &&
			options.mutation.mutationKey
			? options
			: { ...options, mutation: { ...options.mutation, mutationKey } }
		: { mutation: { mutationKey }, fetch: undefined };

	const mutationFn: MutationFunction<
		Awaited<ReturnType<typeof scheduleDeploymentDeploymentsIdSchedulePost>>,
		{ id: string; data: BodyScheduleDeploymentDeploymentsIdSchedulePost }
	> = (props) => {
		const { id, data } = props ?? {};

		return scheduleDeploymentDeploymentsIdSchedulePost(id, data, fetchOptions);
	};

	return { mutationFn, ...mutationOptions };
};

export type ScheduleDeploymentDeploymentsIdSchedulePostMutationResult =
	NonNullable<
		Awaited<ReturnType<typeof scheduleDeploymentDeploymentsIdSchedulePost>>
	>;
export type ScheduleDeploymentDeploymentsIdSchedulePostMutationBody =
	BodyScheduleDeploymentDeploymentsIdSchedulePost;
export type ScheduleDeploymentDeploymentsIdSchedulePostMutationError =
	HTTPValidationError;

/**
 * @summary Schedule Deployment
 */
export const useScheduleDeploymentDeploymentsIdSchedulePost = <
	TError = HTTPValidationError,
	TContext = unknown,
>(options?: {
	mutation?: UseMutationOptions<
		Awaited<ReturnType<typeof scheduleDeploymentDeploymentsIdSchedulePost>>,
		TError,
		{ id: string; data: BodyScheduleDeploymentDeploymentsIdSchedulePost },
		TContext
	>;
	fetch?: RequestInit;
}): UseMutationResult<
	Awaited<ReturnType<typeof scheduleDeploymentDeploymentsIdSchedulePost>>,
	TError,
	{ id: string; data: BodyScheduleDeploymentDeploymentsIdSchedulePost },
	TContext
> => {
	const mutationOptions =
		getScheduleDeploymentDeploymentsIdSchedulePostMutationOptions(options);

	return useMutation(mutationOptions);
};
/**
 * Set a deployment schedule to active. Runs will be scheduled immediately.
 * @summary Resume Deployment
 */
export type resumeDeploymentDeploymentsIdResumeDeploymentPostResponse = {
	data: HTTPValidationError;
	status: number;
	headers: Headers;
};

export const getResumeDeploymentDeploymentsIdResumeDeploymentPostUrl = (
	id: string,
) => {
	return `http://prefect.grose.click/api/deployments/${id}/resume_deployment`;
};

export const resumeDeploymentDeploymentsIdResumeDeploymentPost = async (
	id: string,
	options?: RequestInit,
): Promise<resumeDeploymentDeploymentsIdResumeDeploymentPostResponse> => {
	const res = await fetch(
		getResumeDeploymentDeploymentsIdResumeDeploymentPostUrl(id),
		{
			...options,
			method: "POST",
		},
	);

	const body = [204, 205, 304].includes(res.status) ? null : await res.text();
	const data: resumeDeploymentDeploymentsIdResumeDeploymentPostResponse["data"] =
		body ? JSON.parse(body) : {};

	return {
		data,
		status: res.status,
		headers: res.headers,
	} as resumeDeploymentDeploymentsIdResumeDeploymentPostResponse;
};

export const getResumeDeploymentDeploymentsIdResumeDeploymentPostMutationOptions =
	<TError = HTTPValidationError, TContext = unknown>(options?: {
		mutation?: UseMutationOptions<
			Awaited<
				ReturnType<typeof resumeDeploymentDeploymentsIdResumeDeploymentPost>
			>,
			TError,
			{ id: string },
			TContext
		>;
		fetch?: RequestInit;
	}): UseMutationOptions<
		Awaited<
			ReturnType<typeof resumeDeploymentDeploymentsIdResumeDeploymentPost>
		>,
		TError,
		{ id: string },
		TContext
	> => {
		const mutationKey = ["resumeDeploymentDeploymentsIdResumeDeploymentPost"];
		const { mutation: mutationOptions, fetch: fetchOptions } = options
			? options.mutation &&
				"mutationKey" in options.mutation &&
				options.mutation.mutationKey
				? options
				: { ...options, mutation: { ...options.mutation, mutationKey } }
			: { mutation: { mutationKey }, fetch: undefined };

		const mutationFn: MutationFunction<
			Awaited<
				ReturnType<typeof resumeDeploymentDeploymentsIdResumeDeploymentPost>
			>,
			{ id: string }
		> = (props) => {
			const { id } = props ?? {};

			return resumeDeploymentDeploymentsIdResumeDeploymentPost(
				id,
				fetchOptions,
			);
		};

		return { mutationFn, ...mutationOptions };
	};

export type ResumeDeploymentDeploymentsIdResumeDeploymentPostMutationResult =
	NonNullable<
		Awaited<
			ReturnType<typeof resumeDeploymentDeploymentsIdResumeDeploymentPost>
		>
	>;

export type ResumeDeploymentDeploymentsIdResumeDeploymentPostMutationError =
	HTTPValidationError;

/**
 * @summary Resume Deployment
 */
export const useResumeDeploymentDeploymentsIdResumeDeploymentPost = <
	TError = HTTPValidationError,
	TContext = unknown,
>(options?: {
	mutation?: UseMutationOptions<
		Awaited<
			ReturnType<typeof resumeDeploymentDeploymentsIdResumeDeploymentPost>
		>,
		TError,
		{ id: string },
		TContext
	>;
	fetch?: RequestInit;
}): UseMutationResult<
	Awaited<ReturnType<typeof resumeDeploymentDeploymentsIdResumeDeploymentPost>>,
	TError,
	{ id: string },
	TContext
> => {
	const mutationOptions =
		getResumeDeploymentDeploymentsIdResumeDeploymentPostMutationOptions(
			options,
		);

	return useMutation(mutationOptions);
};
/**
 * Set a deployment schedule to inactive. Any auto-scheduled runs still in a Scheduled
state will be deleted.
 * @summary Pause Deployment
 */
export type pauseDeploymentDeploymentsIdPauseDeploymentPostResponse = {
	data: HTTPValidationError;
	status: number;
	headers: Headers;
};

export const getPauseDeploymentDeploymentsIdPauseDeploymentPostUrl = (
	id: string,
) => {
	return `http://prefect.grose.click/api/deployments/${id}/pause_deployment`;
};

export const pauseDeploymentDeploymentsIdPauseDeploymentPost = async (
	id: string,
	options?: RequestInit,
): Promise<pauseDeploymentDeploymentsIdPauseDeploymentPostResponse> => {
	const res = await fetch(
		getPauseDeploymentDeploymentsIdPauseDeploymentPostUrl(id),
		{
			...options,
			method: "POST",
		},
	);

	const body = [204, 205, 304].includes(res.status) ? null : await res.text();
	const data: pauseDeploymentDeploymentsIdPauseDeploymentPostResponse["data"] =
		body ? JSON.parse(body) : {};

	return {
		data,
		status: res.status,
		headers: res.headers,
	} as pauseDeploymentDeploymentsIdPauseDeploymentPostResponse;
};

export const getPauseDeploymentDeploymentsIdPauseDeploymentPostMutationOptions =
	<TError = HTTPValidationError, TContext = unknown>(options?: {
		mutation?: UseMutationOptions<
			Awaited<
				ReturnType<typeof pauseDeploymentDeploymentsIdPauseDeploymentPost>
			>,
			TError,
			{ id: string },
			TContext
		>;
		fetch?: RequestInit;
	}): UseMutationOptions<
		Awaited<ReturnType<typeof pauseDeploymentDeploymentsIdPauseDeploymentPost>>,
		TError,
		{ id: string },
		TContext
	> => {
		const mutationKey = ["pauseDeploymentDeploymentsIdPauseDeploymentPost"];
		const { mutation: mutationOptions, fetch: fetchOptions } = options
			? options.mutation &&
				"mutationKey" in options.mutation &&
				options.mutation.mutationKey
				? options
				: { ...options, mutation: { ...options.mutation, mutationKey } }
			: { mutation: { mutationKey }, fetch: undefined };

		const mutationFn: MutationFunction<
			Awaited<
				ReturnType<typeof pauseDeploymentDeploymentsIdPauseDeploymentPost>
			>,
			{ id: string }
		> = (props) => {
			const { id } = props ?? {};

			return pauseDeploymentDeploymentsIdPauseDeploymentPost(id, fetchOptions);
		};

		return { mutationFn, ...mutationOptions };
	};

export type PauseDeploymentDeploymentsIdPauseDeploymentPostMutationResult =
	NonNullable<
		Awaited<ReturnType<typeof pauseDeploymentDeploymentsIdPauseDeploymentPost>>
	>;

export type PauseDeploymentDeploymentsIdPauseDeploymentPostMutationError =
	HTTPValidationError;

/**
 * @summary Pause Deployment
 */
export const usePauseDeploymentDeploymentsIdPauseDeploymentPost = <
	TError = HTTPValidationError,
	TContext = unknown,
>(options?: {
	mutation?: UseMutationOptions<
		Awaited<ReturnType<typeof pauseDeploymentDeploymentsIdPauseDeploymentPost>>,
		TError,
		{ id: string },
		TContext
	>;
	fetch?: RequestInit;
}): UseMutationResult<
	Awaited<ReturnType<typeof pauseDeploymentDeploymentsIdPauseDeploymentPost>>,
	TError,
	{ id: string },
	TContext
> => {
	const mutationOptions =
		getPauseDeploymentDeploymentsIdPauseDeploymentPostMutationOptions(options);

	return useMutation(mutationOptions);
};
/**
 * Create a flow run from a deployment.

Any parameters not provided will be inferred from the deployment's parameters.
If tags are not provided, the deployment's tags will be used.

If no state is provided, the flow run will be created in a SCHEDULED state.
 * @summary Create Flow Run From Deployment
 */
export type createFlowRunFromDeploymentDeploymentsIdCreateFlowRunPostResponse =
	{
		data: FlowRunResponse | HTTPValidationError;
		status: number;
		headers: Headers;
	};

export const getCreateFlowRunFromDeploymentDeploymentsIdCreateFlowRunPostUrl = (
	id: string,
) => {
	return `http://prefect.grose.click/api/deployments/${id}/create_flow_run`;
};

export const createFlowRunFromDeploymentDeploymentsIdCreateFlowRunPost = async (
	id: string,
	deploymentFlowRunCreate: DeploymentFlowRunCreate,
	options?: RequestInit,
): Promise<createFlowRunFromDeploymentDeploymentsIdCreateFlowRunPostResponse> => {
	const res = await fetch(
		getCreateFlowRunFromDeploymentDeploymentsIdCreateFlowRunPostUrl(id),
		{
			...options,
			method: "POST",
			headers: { "Content-Type": "application/json", ...options?.headers },
			body: JSON.stringify(deploymentFlowRunCreate),
		},
	);

	const body = [204, 205, 304].includes(res.status) ? null : await res.text();
	const data: createFlowRunFromDeploymentDeploymentsIdCreateFlowRunPostResponse["data"] =
		body ? JSON.parse(body) : {};

	return {
		data,
		status: res.status,
		headers: res.headers,
	} as createFlowRunFromDeploymentDeploymentsIdCreateFlowRunPostResponse;
};

export const getCreateFlowRunFromDeploymentDeploymentsIdCreateFlowRunPostMutationOptions =
	<TError = HTTPValidationError, TContext = unknown>(options?: {
		mutation?: UseMutationOptions<
			Awaited<
				ReturnType<
					typeof createFlowRunFromDeploymentDeploymentsIdCreateFlowRunPost
				>
			>,
			TError,
			{ id: string; data: DeploymentFlowRunCreate },
			TContext
		>;
		fetch?: RequestInit;
	}): UseMutationOptions<
		Awaited<
			ReturnType<
				typeof createFlowRunFromDeploymentDeploymentsIdCreateFlowRunPost
			>
		>,
		TError,
		{ id: string; data: DeploymentFlowRunCreate },
		TContext
	> => {
		const mutationKey = [
			"createFlowRunFromDeploymentDeploymentsIdCreateFlowRunPost",
		];
		const { mutation: mutationOptions, fetch: fetchOptions } = options
			? options.mutation &&
				"mutationKey" in options.mutation &&
				options.mutation.mutationKey
				? options
				: { ...options, mutation: { ...options.mutation, mutationKey } }
			: { mutation: { mutationKey }, fetch: undefined };

		const mutationFn: MutationFunction<
			Awaited<
				ReturnType<
					typeof createFlowRunFromDeploymentDeploymentsIdCreateFlowRunPost
				>
			>,
			{ id: string; data: DeploymentFlowRunCreate }
		> = (props) => {
			const { id, data } = props ?? {};

			return createFlowRunFromDeploymentDeploymentsIdCreateFlowRunPost(
				id,
				data,
				fetchOptions,
			);
		};

		return { mutationFn, ...mutationOptions };
	};

export type CreateFlowRunFromDeploymentDeploymentsIdCreateFlowRunPostMutationResult =
	NonNullable<
		Awaited<
			ReturnType<
				typeof createFlowRunFromDeploymentDeploymentsIdCreateFlowRunPost
			>
		>
	>;
export type CreateFlowRunFromDeploymentDeploymentsIdCreateFlowRunPostMutationBody =
	DeploymentFlowRunCreate;
export type CreateFlowRunFromDeploymentDeploymentsIdCreateFlowRunPostMutationError =
	HTTPValidationError;

/**
 * @summary Create Flow Run From Deployment
 */
export const useCreateFlowRunFromDeploymentDeploymentsIdCreateFlowRunPost = <
	TError = HTTPValidationError,
	TContext = unknown,
>(options?: {
	mutation?: UseMutationOptions<
		Awaited<
			ReturnType<
				typeof createFlowRunFromDeploymentDeploymentsIdCreateFlowRunPost
			>
		>,
		TError,
		{ id: string; data: DeploymentFlowRunCreate },
		TContext
	>;
	fetch?: RequestInit;
}): UseMutationResult<
	Awaited<
		ReturnType<typeof createFlowRunFromDeploymentDeploymentsIdCreateFlowRunPost>
	>,
	TError,
	{ id: string; data: DeploymentFlowRunCreate },
	TContext
> => {
	const mutationOptions =
		getCreateFlowRunFromDeploymentDeploymentsIdCreateFlowRunPostMutationOptions(
			options,
		);

	return useMutation(mutationOptions);
};
/**
 * Get list of work-queues that are able to pick up the specified deployment.

This endpoint is intended to be used by the UI to provide users warnings
about deployments that are unable to be executed because there are no work
queues that will pick up their runs, based on existing filter criteria. It
may be deprecated in the future because there is not a strict relationship
between work queues and deployments.
 * @deprecated
 * @summary Work Queue Check For Deployment
 */
export type workQueueCheckForDeploymentDeploymentsIdWorkQueueCheckGetResponse =
	{
		data: WorkQueue[] | HTTPValidationError;
		status: number;
		headers: Headers;
	};

export const getWorkQueueCheckForDeploymentDeploymentsIdWorkQueueCheckGetUrl = (
	id: string,
) => {
	return `http://prefect.grose.click/api/deployments/${id}/work_queue_check`;
};

export const workQueueCheckForDeploymentDeploymentsIdWorkQueueCheckGet = async (
	id: string,
	options?: RequestInit,
): Promise<workQueueCheckForDeploymentDeploymentsIdWorkQueueCheckGetResponse> => {
	const res = await fetch(
		getWorkQueueCheckForDeploymentDeploymentsIdWorkQueueCheckGetUrl(id),
		{
			...options,
			method: "GET",
		},
	);

	const body = [204, 205, 304].includes(res.status) ? null : await res.text();
	const data: workQueueCheckForDeploymentDeploymentsIdWorkQueueCheckGetResponse["data"] =
		body ? JSON.parse(body) : {};

	return {
		data,
		status: res.status,
		headers: res.headers,
	} as workQueueCheckForDeploymentDeploymentsIdWorkQueueCheckGetResponse;
};

export const getWorkQueueCheckForDeploymentDeploymentsIdWorkQueueCheckGetQueryKey =
	(id: string) => {
		return [
			`http://prefect.grose.click/api/deployments/${id}/work_queue_check`,
		] as const;
	};

export const getWorkQueueCheckForDeploymentDeploymentsIdWorkQueueCheckGetQueryOptions =
	<
		TData = Awaited<
			ReturnType<
				typeof workQueueCheckForDeploymentDeploymentsIdWorkQueueCheckGet
			>
		>,
		TError = HTTPValidationError,
	>(
		id: string,
		options?: {
			query?: Partial<
				UseQueryOptions<
					Awaited<
						ReturnType<
							typeof workQueueCheckForDeploymentDeploymentsIdWorkQueueCheckGet
						>
					>,
					TError,
					TData
				>
			>;
			fetch?: RequestInit;
		},
	) => {
		const { query: queryOptions, fetch: fetchOptions } = options ?? {};

		const queryKey =
			queryOptions?.queryKey ??
			getWorkQueueCheckForDeploymentDeploymentsIdWorkQueueCheckGetQueryKey(id);

		const queryFn: QueryFunction<
			Awaited<
				ReturnType<
					typeof workQueueCheckForDeploymentDeploymentsIdWorkQueueCheckGet
				>
			>
		> = ({ signal }) =>
			workQueueCheckForDeploymentDeploymentsIdWorkQueueCheckGet(id, {
				signal,
				...fetchOptions,
			});

		return {
			queryKey,
			queryFn,
			enabled: !!id,
			...queryOptions,
		} as UseQueryOptions<
			Awaited<
				ReturnType<
					typeof workQueueCheckForDeploymentDeploymentsIdWorkQueueCheckGet
				>
			>,
			TError,
			TData
		> & { queryKey: DataTag<QueryKey, TData, TError> };
	};

export type WorkQueueCheckForDeploymentDeploymentsIdWorkQueueCheckGetQueryResult =
	NonNullable<
		Awaited<
			ReturnType<
				typeof workQueueCheckForDeploymentDeploymentsIdWorkQueueCheckGet
			>
		>
	>;
export type WorkQueueCheckForDeploymentDeploymentsIdWorkQueueCheckGetQueryError =
	HTTPValidationError;

export function useWorkQueueCheckForDeploymentDeploymentsIdWorkQueueCheckGet<
	TData = Awaited<
		ReturnType<typeof workQueueCheckForDeploymentDeploymentsIdWorkQueueCheckGet>
	>,
	TError = HTTPValidationError,
>(
	id: string,
	options: {
		query: Partial<
			UseQueryOptions<
				Awaited<
					ReturnType<
						typeof workQueueCheckForDeploymentDeploymentsIdWorkQueueCheckGet
					>
				>,
				TError,
				TData
			>
		> &
			Pick<
				DefinedInitialDataOptions<
					Awaited<
						ReturnType<
							typeof workQueueCheckForDeploymentDeploymentsIdWorkQueueCheckGet
						>
					>,
					TError,
					Awaited<
						ReturnType<
							typeof workQueueCheckForDeploymentDeploymentsIdWorkQueueCheckGet
						>
					>
				>,
				"initialData"
			>;
		fetch?: RequestInit;
	},
): DefinedUseQueryResult<TData, TError> & {
	queryKey: DataTag<QueryKey, TData, TError>;
};
export function useWorkQueueCheckForDeploymentDeploymentsIdWorkQueueCheckGet<
	TData = Awaited<
		ReturnType<typeof workQueueCheckForDeploymentDeploymentsIdWorkQueueCheckGet>
	>,
	TError = HTTPValidationError,
>(
	id: string,
	options?: {
		query?: Partial<
			UseQueryOptions<
				Awaited<
					ReturnType<
						typeof workQueueCheckForDeploymentDeploymentsIdWorkQueueCheckGet
					>
				>,
				TError,
				TData
			>
		> &
			Pick<
				UndefinedInitialDataOptions<
					Awaited<
						ReturnType<
							typeof workQueueCheckForDeploymentDeploymentsIdWorkQueueCheckGet
						>
					>,
					TError,
					Awaited<
						ReturnType<
							typeof workQueueCheckForDeploymentDeploymentsIdWorkQueueCheckGet
						>
					>
				>,
				"initialData"
			>;
		fetch?: RequestInit;
	},
): UseQueryResult<TData, TError> & {
	queryKey: DataTag<QueryKey, TData, TError>;
};
export function useWorkQueueCheckForDeploymentDeploymentsIdWorkQueueCheckGet<
	TData = Awaited<
		ReturnType<typeof workQueueCheckForDeploymentDeploymentsIdWorkQueueCheckGet>
	>,
	TError = HTTPValidationError,
>(
	id: string,
	options?: {
		query?: Partial<
			UseQueryOptions<
				Awaited<
					ReturnType<
						typeof workQueueCheckForDeploymentDeploymentsIdWorkQueueCheckGet
					>
				>,
				TError,
				TData
			>
		>;
		fetch?: RequestInit;
	},
): UseQueryResult<TData, TError> & {
	queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @deprecated
 * @summary Work Queue Check For Deployment
 */

export function useWorkQueueCheckForDeploymentDeploymentsIdWorkQueueCheckGet<
	TData = Awaited<
		ReturnType<typeof workQueueCheckForDeploymentDeploymentsIdWorkQueueCheckGet>
	>,
	TError = HTTPValidationError,
>(
	id: string,
	options?: {
		query?: Partial<
			UseQueryOptions<
				Awaited<
					ReturnType<
						typeof workQueueCheckForDeploymentDeploymentsIdWorkQueueCheckGet
					>
				>,
				TError,
				TData
			>
		>;
		fetch?: RequestInit;
	},
): UseQueryResult<TData, TError> & {
	queryKey: DataTag<QueryKey, TData, TError>;
} {
	const queryOptions =
		getWorkQueueCheckForDeploymentDeploymentsIdWorkQueueCheckGetQueryOptions(
			id,
			options,
		);

	const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
		queryKey: DataTag<QueryKey, TData, TError>;
	};

	query.queryKey = queryOptions.queryKey;

	return query;
}

export const getWorkQueueCheckForDeploymentDeploymentsIdWorkQueueCheckGetSuspenseQueryOptions =
	<
		TData = Awaited<
			ReturnType<
				typeof workQueueCheckForDeploymentDeploymentsIdWorkQueueCheckGet
			>
		>,
		TError = HTTPValidationError,
	>(
		id: string,
		options?: {
			query?: Partial<
				UseSuspenseQueryOptions<
					Awaited<
						ReturnType<
							typeof workQueueCheckForDeploymentDeploymentsIdWorkQueueCheckGet
						>
					>,
					TError,
					TData
				>
			>;
			fetch?: RequestInit;
		},
	) => {
		const { query: queryOptions, fetch: fetchOptions } = options ?? {};

		const queryKey =
			queryOptions?.queryKey ??
			getWorkQueueCheckForDeploymentDeploymentsIdWorkQueueCheckGetQueryKey(id);

		const queryFn: QueryFunction<
			Awaited<
				ReturnType<
					typeof workQueueCheckForDeploymentDeploymentsIdWorkQueueCheckGet
				>
			>
		> = ({ signal }) =>
			workQueueCheckForDeploymentDeploymentsIdWorkQueueCheckGet(id, {
				signal,
				...fetchOptions,
			});

		return { queryKey, queryFn, ...queryOptions } as UseSuspenseQueryOptions<
			Awaited<
				ReturnType<
					typeof workQueueCheckForDeploymentDeploymentsIdWorkQueueCheckGet
				>
			>,
			TError,
			TData
		> & { queryKey: DataTag<QueryKey, TData, TError> };
	};

export type WorkQueueCheckForDeploymentDeploymentsIdWorkQueueCheckGetSuspenseQueryResult =
	NonNullable<
		Awaited<
			ReturnType<
				typeof workQueueCheckForDeploymentDeploymentsIdWorkQueueCheckGet
			>
		>
	>;
export type WorkQueueCheckForDeploymentDeploymentsIdWorkQueueCheckGetSuspenseQueryError =
	HTTPValidationError;

export function useWorkQueueCheckForDeploymentDeploymentsIdWorkQueueCheckGetSuspense<
	TData = Awaited<
		ReturnType<typeof workQueueCheckForDeploymentDeploymentsIdWorkQueueCheckGet>
	>,
	TError = HTTPValidationError,
>(
	id: string,
	options: {
		query: Partial<
			UseSuspenseQueryOptions<
				Awaited<
					ReturnType<
						typeof workQueueCheckForDeploymentDeploymentsIdWorkQueueCheckGet
					>
				>,
				TError,
				TData
			>
		>;
		fetch?: RequestInit;
	},
): UseSuspenseQueryResult<TData, TError> & {
	queryKey: DataTag<QueryKey, TData, TError>;
};
export function useWorkQueueCheckForDeploymentDeploymentsIdWorkQueueCheckGetSuspense<
	TData = Awaited<
		ReturnType<typeof workQueueCheckForDeploymentDeploymentsIdWorkQueueCheckGet>
	>,
	TError = HTTPValidationError,
>(
	id: string,
	options?: {
		query?: Partial<
			UseSuspenseQueryOptions<
				Awaited<
					ReturnType<
						typeof workQueueCheckForDeploymentDeploymentsIdWorkQueueCheckGet
					>
				>,
				TError,
				TData
			>
		>;
		fetch?: RequestInit;
	},
): UseSuspenseQueryResult<TData, TError> & {
	queryKey: DataTag<QueryKey, TData, TError>;
};
export function useWorkQueueCheckForDeploymentDeploymentsIdWorkQueueCheckGetSuspense<
	TData = Awaited<
		ReturnType<typeof workQueueCheckForDeploymentDeploymentsIdWorkQueueCheckGet>
	>,
	TError = HTTPValidationError,
>(
	id: string,
	options?: {
		query?: Partial<
			UseSuspenseQueryOptions<
				Awaited<
					ReturnType<
						typeof workQueueCheckForDeploymentDeploymentsIdWorkQueueCheckGet
					>
				>,
				TError,
				TData
			>
		>;
		fetch?: RequestInit;
	},
): UseSuspenseQueryResult<TData, TError> & {
	queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @deprecated
 * @summary Work Queue Check For Deployment
 */

export function useWorkQueueCheckForDeploymentDeploymentsIdWorkQueueCheckGetSuspense<
	TData = Awaited<
		ReturnType<typeof workQueueCheckForDeploymentDeploymentsIdWorkQueueCheckGet>
	>,
	TError = HTTPValidationError,
>(
	id: string,
	options?: {
		query?: Partial<
			UseSuspenseQueryOptions<
				Awaited<
					ReturnType<
						typeof workQueueCheckForDeploymentDeploymentsIdWorkQueueCheckGet
					>
				>,
				TError,
				TData
			>
		>;
		fetch?: RequestInit;
	},
): UseSuspenseQueryResult<TData, TError> & {
	queryKey: DataTag<QueryKey, TData, TError>;
} {
	const queryOptions =
		getWorkQueueCheckForDeploymentDeploymentsIdWorkQueueCheckGetSuspenseQueryOptions(
			id,
			options,
		);

	const query = useSuspenseQuery(queryOptions) as UseSuspenseQueryResult<
		TData,
		TError
	> & { queryKey: DataTag<QueryKey, TData, TError> };

	query.queryKey = queryOptions.queryKey;

	return query;
}

/**
 * @summary Read Deployment Schedules
 */
export type readDeploymentSchedulesDeploymentsIdSchedulesGetResponse = {
	data: DeploymentSchedule[] | HTTPValidationError;
	status: number;
	headers: Headers;
};

export const getReadDeploymentSchedulesDeploymentsIdSchedulesGetUrl = (
	id: string,
) => {
	return `http://prefect.grose.click/api/deployments/${id}/schedules`;
};

export const readDeploymentSchedulesDeploymentsIdSchedulesGet = async (
	id: string,
	options?: RequestInit,
): Promise<readDeploymentSchedulesDeploymentsIdSchedulesGetResponse> => {
	const res = await fetch(
		getReadDeploymentSchedulesDeploymentsIdSchedulesGetUrl(id),
		{
			...options,
			method: "GET",
		},
	);

	const body = [204, 205, 304].includes(res.status) ? null : await res.text();
	const data: readDeploymentSchedulesDeploymentsIdSchedulesGetResponse["data"] =
		body ? JSON.parse(body) : {};

	return {
		data,
		status: res.status,
		headers: res.headers,
	} as readDeploymentSchedulesDeploymentsIdSchedulesGetResponse;
};

export const getReadDeploymentSchedulesDeploymentsIdSchedulesGetQueryKey = (
	id: string,
) => {
	return [
		`http://prefect.grose.click/api/deployments/${id}/schedules`,
	] as const;
};

export const getReadDeploymentSchedulesDeploymentsIdSchedulesGetQueryOptions = <
	TData = Awaited<
		ReturnType<typeof readDeploymentSchedulesDeploymentsIdSchedulesGet>
	>,
	TError = HTTPValidationError,
>(
	id: string,
	options?: {
		query?: Partial<
			UseQueryOptions<
				Awaited<
					ReturnType<typeof readDeploymentSchedulesDeploymentsIdSchedulesGet>
				>,
				TError,
				TData
			>
		>;
		fetch?: RequestInit;
	},
) => {
	const { query: queryOptions, fetch: fetchOptions } = options ?? {};

	const queryKey =
		queryOptions?.queryKey ??
		getReadDeploymentSchedulesDeploymentsIdSchedulesGetQueryKey(id);

	const queryFn: QueryFunction<
		Awaited<ReturnType<typeof readDeploymentSchedulesDeploymentsIdSchedulesGet>>
	> = ({ signal }) =>
		readDeploymentSchedulesDeploymentsIdSchedulesGet(id, {
			signal,
			...fetchOptions,
		});

	return {
		queryKey,
		queryFn,
		enabled: !!id,
		...queryOptions,
	} as UseQueryOptions<
		Awaited<
			ReturnType<typeof readDeploymentSchedulesDeploymentsIdSchedulesGet>
		>,
		TError,
		TData
	> & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type ReadDeploymentSchedulesDeploymentsIdSchedulesGetQueryResult =
	NonNullable<
		Awaited<ReturnType<typeof readDeploymentSchedulesDeploymentsIdSchedulesGet>>
	>;
export type ReadDeploymentSchedulesDeploymentsIdSchedulesGetQueryError =
	HTTPValidationError;

export function useReadDeploymentSchedulesDeploymentsIdSchedulesGet<
	TData = Awaited<
		ReturnType<typeof readDeploymentSchedulesDeploymentsIdSchedulesGet>
	>,
	TError = HTTPValidationError,
>(
	id: string,
	options: {
		query: Partial<
			UseQueryOptions<
				Awaited<
					ReturnType<typeof readDeploymentSchedulesDeploymentsIdSchedulesGet>
				>,
				TError,
				TData
			>
		> &
			Pick<
				DefinedInitialDataOptions<
					Awaited<
						ReturnType<typeof readDeploymentSchedulesDeploymentsIdSchedulesGet>
					>,
					TError,
					Awaited<
						ReturnType<typeof readDeploymentSchedulesDeploymentsIdSchedulesGet>
					>
				>,
				"initialData"
			>;
		fetch?: RequestInit;
	},
): DefinedUseQueryResult<TData, TError> & {
	queryKey: DataTag<QueryKey, TData, TError>;
};
export function useReadDeploymentSchedulesDeploymentsIdSchedulesGet<
	TData = Awaited<
		ReturnType<typeof readDeploymentSchedulesDeploymentsIdSchedulesGet>
	>,
	TError = HTTPValidationError,
>(
	id: string,
	options?: {
		query?: Partial<
			UseQueryOptions<
				Awaited<
					ReturnType<typeof readDeploymentSchedulesDeploymentsIdSchedulesGet>
				>,
				TError,
				TData
			>
		> &
			Pick<
				UndefinedInitialDataOptions<
					Awaited<
						ReturnType<typeof readDeploymentSchedulesDeploymentsIdSchedulesGet>
					>,
					TError,
					Awaited<
						ReturnType<typeof readDeploymentSchedulesDeploymentsIdSchedulesGet>
					>
				>,
				"initialData"
			>;
		fetch?: RequestInit;
	},
): UseQueryResult<TData, TError> & {
	queryKey: DataTag<QueryKey, TData, TError>;
};
export function useReadDeploymentSchedulesDeploymentsIdSchedulesGet<
	TData = Awaited<
		ReturnType<typeof readDeploymentSchedulesDeploymentsIdSchedulesGet>
	>,
	TError = HTTPValidationError,
>(
	id: string,
	options?: {
		query?: Partial<
			UseQueryOptions<
				Awaited<
					ReturnType<typeof readDeploymentSchedulesDeploymentsIdSchedulesGet>
				>,
				TError,
				TData
			>
		>;
		fetch?: RequestInit;
	},
): UseQueryResult<TData, TError> & {
	queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Read Deployment Schedules
 */

export function useReadDeploymentSchedulesDeploymentsIdSchedulesGet<
	TData = Awaited<
		ReturnType<typeof readDeploymentSchedulesDeploymentsIdSchedulesGet>
	>,
	TError = HTTPValidationError,
>(
	id: string,
	options?: {
		query?: Partial<
			UseQueryOptions<
				Awaited<
					ReturnType<typeof readDeploymentSchedulesDeploymentsIdSchedulesGet>
				>,
				TError,
				TData
			>
		>;
		fetch?: RequestInit;
	},
): UseQueryResult<TData, TError> & {
	queryKey: DataTag<QueryKey, TData, TError>;
} {
	const queryOptions =
		getReadDeploymentSchedulesDeploymentsIdSchedulesGetQueryOptions(
			id,
			options,
		);

	const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
		queryKey: DataTag<QueryKey, TData, TError>;
	};

	query.queryKey = queryOptions.queryKey;

	return query;
}

export const getReadDeploymentSchedulesDeploymentsIdSchedulesGetSuspenseQueryOptions =
	<
		TData = Awaited<
			ReturnType<typeof readDeploymentSchedulesDeploymentsIdSchedulesGet>
		>,
		TError = HTTPValidationError,
	>(
		id: string,
		options?: {
			query?: Partial<
				UseSuspenseQueryOptions<
					Awaited<
						ReturnType<typeof readDeploymentSchedulesDeploymentsIdSchedulesGet>
					>,
					TError,
					TData
				>
			>;
			fetch?: RequestInit;
		},
	) => {
		const { query: queryOptions, fetch: fetchOptions } = options ?? {};

		const queryKey =
			queryOptions?.queryKey ??
			getReadDeploymentSchedulesDeploymentsIdSchedulesGetQueryKey(id);

		const queryFn: QueryFunction<
			Awaited<
				ReturnType<typeof readDeploymentSchedulesDeploymentsIdSchedulesGet>
			>
		> = ({ signal }) =>
			readDeploymentSchedulesDeploymentsIdSchedulesGet(id, {
				signal,
				...fetchOptions,
			});

		return { queryKey, queryFn, ...queryOptions } as UseSuspenseQueryOptions<
			Awaited<
				ReturnType<typeof readDeploymentSchedulesDeploymentsIdSchedulesGet>
			>,
			TError,
			TData
		> & { queryKey: DataTag<QueryKey, TData, TError> };
	};

export type ReadDeploymentSchedulesDeploymentsIdSchedulesGetSuspenseQueryResult =
	NonNullable<
		Awaited<ReturnType<typeof readDeploymentSchedulesDeploymentsIdSchedulesGet>>
	>;
export type ReadDeploymentSchedulesDeploymentsIdSchedulesGetSuspenseQueryError =
	HTTPValidationError;

export function useReadDeploymentSchedulesDeploymentsIdSchedulesGetSuspense<
	TData = Awaited<
		ReturnType<typeof readDeploymentSchedulesDeploymentsIdSchedulesGet>
	>,
	TError = HTTPValidationError,
>(
	id: string,
	options: {
		query: Partial<
			UseSuspenseQueryOptions<
				Awaited<
					ReturnType<typeof readDeploymentSchedulesDeploymentsIdSchedulesGet>
				>,
				TError,
				TData
			>
		>;
		fetch?: RequestInit;
	},
): UseSuspenseQueryResult<TData, TError> & {
	queryKey: DataTag<QueryKey, TData, TError>;
};
export function useReadDeploymentSchedulesDeploymentsIdSchedulesGetSuspense<
	TData = Awaited<
		ReturnType<typeof readDeploymentSchedulesDeploymentsIdSchedulesGet>
	>,
	TError = HTTPValidationError,
>(
	id: string,
	options?: {
		query?: Partial<
			UseSuspenseQueryOptions<
				Awaited<
					ReturnType<typeof readDeploymentSchedulesDeploymentsIdSchedulesGet>
				>,
				TError,
				TData
			>
		>;
		fetch?: RequestInit;
	},
): UseSuspenseQueryResult<TData, TError> & {
	queryKey: DataTag<QueryKey, TData, TError>;
};
export function useReadDeploymentSchedulesDeploymentsIdSchedulesGetSuspense<
	TData = Awaited<
		ReturnType<typeof readDeploymentSchedulesDeploymentsIdSchedulesGet>
	>,
	TError = HTTPValidationError,
>(
	id: string,
	options?: {
		query?: Partial<
			UseSuspenseQueryOptions<
				Awaited<
					ReturnType<typeof readDeploymentSchedulesDeploymentsIdSchedulesGet>
				>,
				TError,
				TData
			>
		>;
		fetch?: RequestInit;
	},
): UseSuspenseQueryResult<TData, TError> & {
	queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Read Deployment Schedules
 */

export function useReadDeploymentSchedulesDeploymentsIdSchedulesGetSuspense<
	TData = Awaited<
		ReturnType<typeof readDeploymentSchedulesDeploymentsIdSchedulesGet>
	>,
	TError = HTTPValidationError,
>(
	id: string,
	options?: {
		query?: Partial<
			UseSuspenseQueryOptions<
				Awaited<
					ReturnType<typeof readDeploymentSchedulesDeploymentsIdSchedulesGet>
				>,
				TError,
				TData
			>
		>;
		fetch?: RequestInit;
	},
): UseSuspenseQueryResult<TData, TError> & {
	queryKey: DataTag<QueryKey, TData, TError>;
} {
	const queryOptions =
		getReadDeploymentSchedulesDeploymentsIdSchedulesGetSuspenseQueryOptions(
			id,
			options,
		);

	const query = useSuspenseQuery(queryOptions) as UseSuspenseQueryResult<
		TData,
		TError
	> & { queryKey: DataTag<QueryKey, TData, TError> };

	query.queryKey = queryOptions.queryKey;

	return query;
}

/**
 * @summary Create Deployment Schedules
 */
export type createDeploymentSchedulesDeploymentsIdSchedulesPostResponse = {
	data: DeploymentSchedule[] | HTTPValidationError;
	status: number;
	headers: Headers;
};

export const getCreateDeploymentSchedulesDeploymentsIdSchedulesPostUrl = (
	id: string,
) => {
	return `http://prefect.grose.click/api/deployments/${id}/schedules`;
};

export const createDeploymentSchedulesDeploymentsIdSchedulesPost = async (
	id: string,
	deploymentScheduleCreate: DeploymentScheduleCreate[],
	options?: RequestInit,
): Promise<createDeploymentSchedulesDeploymentsIdSchedulesPostResponse> => {
	const res = await fetch(
		getCreateDeploymentSchedulesDeploymentsIdSchedulesPostUrl(id),
		{
			...options,
			method: "POST",
			headers: { "Content-Type": "application/json", ...options?.headers },
			body: JSON.stringify(deploymentScheduleCreate),
		},
	);

	const body = [204, 205, 304].includes(res.status) ? null : await res.text();
	const data: createDeploymentSchedulesDeploymentsIdSchedulesPostResponse["data"] =
		body ? JSON.parse(body) : {};

	return {
		data,
		status: res.status,
		headers: res.headers,
	} as createDeploymentSchedulesDeploymentsIdSchedulesPostResponse;
};

export const getCreateDeploymentSchedulesDeploymentsIdSchedulesPostMutationOptions =
	<TError = HTTPValidationError, TContext = unknown>(options?: {
		mutation?: UseMutationOptions<
			Awaited<
				ReturnType<typeof createDeploymentSchedulesDeploymentsIdSchedulesPost>
			>,
			TError,
			{ id: string; data: DeploymentScheduleCreate[] },
			TContext
		>;
		fetch?: RequestInit;
	}): UseMutationOptions<
		Awaited<
			ReturnType<typeof createDeploymentSchedulesDeploymentsIdSchedulesPost>
		>,
		TError,
		{ id: string; data: DeploymentScheduleCreate[] },
		TContext
	> => {
		const mutationKey = ["createDeploymentSchedulesDeploymentsIdSchedulesPost"];
		const { mutation: mutationOptions, fetch: fetchOptions } = options
			? options.mutation &&
				"mutationKey" in options.mutation &&
				options.mutation.mutationKey
				? options
				: { ...options, mutation: { ...options.mutation, mutationKey } }
			: { mutation: { mutationKey }, fetch: undefined };

		const mutationFn: MutationFunction<
			Awaited<
				ReturnType<typeof createDeploymentSchedulesDeploymentsIdSchedulesPost>
			>,
			{ id: string; data: DeploymentScheduleCreate[] }
		> = (props) => {
			const { id, data } = props ?? {};

			return createDeploymentSchedulesDeploymentsIdSchedulesPost(
				id,
				data,
				fetchOptions,
			);
		};

		return { mutationFn, ...mutationOptions };
	};

export type CreateDeploymentSchedulesDeploymentsIdSchedulesPostMutationResult =
	NonNullable<
		Awaited<
			ReturnType<typeof createDeploymentSchedulesDeploymentsIdSchedulesPost>
		>
	>;
export type CreateDeploymentSchedulesDeploymentsIdSchedulesPostMutationBody =
	DeploymentScheduleCreate[];
export type CreateDeploymentSchedulesDeploymentsIdSchedulesPostMutationError =
	HTTPValidationError;

/**
 * @summary Create Deployment Schedules
 */
export const useCreateDeploymentSchedulesDeploymentsIdSchedulesPost = <
	TError = HTTPValidationError,
	TContext = unknown,
>(options?: {
	mutation?: UseMutationOptions<
		Awaited<
			ReturnType<typeof createDeploymentSchedulesDeploymentsIdSchedulesPost>
		>,
		TError,
		{ id: string; data: DeploymentScheduleCreate[] },
		TContext
	>;
	fetch?: RequestInit;
}): UseMutationResult<
	Awaited<
		ReturnType<typeof createDeploymentSchedulesDeploymentsIdSchedulesPost>
	>,
	TError,
	{ id: string; data: DeploymentScheduleCreate[] },
	TContext
> => {
	const mutationOptions =
		getCreateDeploymentSchedulesDeploymentsIdSchedulesPostMutationOptions(
			options,
		);

	return useMutation(mutationOptions);
};
/**
 * @summary Update Deployment Schedule
 */
export type updateDeploymentScheduleDeploymentsIdSchedulesScheduleIdPatchResponse =
	{
		data: void | HTTPValidationError;
		status: number;
		headers: Headers;
	};

export const getUpdateDeploymentScheduleDeploymentsIdSchedulesScheduleIdPatchUrl =
	(id: string, scheduleId: string) => {
		return `http://prefect.grose.click/api/deployments/${id}/schedules/${scheduleId}`;
	};

export const updateDeploymentScheduleDeploymentsIdSchedulesScheduleIdPatch =
	async (
		id: string,
		scheduleId: string,
		deploymentScheduleUpdate: DeploymentScheduleUpdate,
		options?: RequestInit,
	): Promise<updateDeploymentScheduleDeploymentsIdSchedulesScheduleIdPatchResponse> => {
		const res = await fetch(
			getUpdateDeploymentScheduleDeploymentsIdSchedulesScheduleIdPatchUrl(
				id,
				scheduleId,
			),
			{
				...options,
				method: "PATCH",
				headers: { "Content-Type": "application/json", ...options?.headers },
				body: JSON.stringify(deploymentScheduleUpdate),
			},
		);

		const body = [204, 205, 304].includes(res.status) ? null : await res.text();
		const data: updateDeploymentScheduleDeploymentsIdSchedulesScheduleIdPatchResponse["data"] =
			body ? JSON.parse(body) : {};

		return {
			data,
			status: res.status,
			headers: res.headers,
		} as updateDeploymentScheduleDeploymentsIdSchedulesScheduleIdPatchResponse;
	};

export const getUpdateDeploymentScheduleDeploymentsIdSchedulesScheduleIdPatchMutationOptions =
	<TError = HTTPValidationError, TContext = unknown>(options?: {
		mutation?: UseMutationOptions<
			Awaited<
				ReturnType<
					typeof updateDeploymentScheduleDeploymentsIdSchedulesScheduleIdPatch
				>
			>,
			TError,
			{ id: string; scheduleId: string; data: DeploymentScheduleUpdate },
			TContext
		>;
		fetch?: RequestInit;
	}): UseMutationOptions<
		Awaited<
			ReturnType<
				typeof updateDeploymentScheduleDeploymentsIdSchedulesScheduleIdPatch
			>
		>,
		TError,
		{ id: string; scheduleId: string; data: DeploymentScheduleUpdate },
		TContext
	> => {
		const mutationKey = [
			"updateDeploymentScheduleDeploymentsIdSchedulesScheduleIdPatch",
		];
		const { mutation: mutationOptions, fetch: fetchOptions } = options
			? options.mutation &&
				"mutationKey" in options.mutation &&
				options.mutation.mutationKey
				? options
				: { ...options, mutation: { ...options.mutation, mutationKey } }
			: { mutation: { mutationKey }, fetch: undefined };

		const mutationFn: MutationFunction<
			Awaited<
				ReturnType<
					typeof updateDeploymentScheduleDeploymentsIdSchedulesScheduleIdPatch
				>
			>,
			{ id: string; scheduleId: string; data: DeploymentScheduleUpdate }
		> = (props) => {
			const { id, scheduleId, data } = props ?? {};

			return updateDeploymentScheduleDeploymentsIdSchedulesScheduleIdPatch(
				id,
				scheduleId,
				data,
				fetchOptions,
			);
		};

		return { mutationFn, ...mutationOptions };
	};

export type UpdateDeploymentScheduleDeploymentsIdSchedulesScheduleIdPatchMutationResult =
	NonNullable<
		Awaited<
			ReturnType<
				typeof updateDeploymentScheduleDeploymentsIdSchedulesScheduleIdPatch
			>
		>
	>;
export type UpdateDeploymentScheduleDeploymentsIdSchedulesScheduleIdPatchMutationBody =
	DeploymentScheduleUpdate;
export type UpdateDeploymentScheduleDeploymentsIdSchedulesScheduleIdPatchMutationError =
	HTTPValidationError;

/**
 * @summary Update Deployment Schedule
 */
export const useUpdateDeploymentScheduleDeploymentsIdSchedulesScheduleIdPatch =
	<TError = HTTPValidationError, TContext = unknown>(options?: {
		mutation?: UseMutationOptions<
			Awaited<
				ReturnType<
					typeof updateDeploymentScheduleDeploymentsIdSchedulesScheduleIdPatch
				>
			>,
			TError,
			{ id: string; scheduleId: string; data: DeploymentScheduleUpdate },
			TContext
		>;
		fetch?: RequestInit;
	}): UseMutationResult<
		Awaited<
			ReturnType<
				typeof updateDeploymentScheduleDeploymentsIdSchedulesScheduleIdPatch
			>
		>,
		TError,
		{ id: string; scheduleId: string; data: DeploymentScheduleUpdate },
		TContext
	> => {
		const mutationOptions =
			getUpdateDeploymentScheduleDeploymentsIdSchedulesScheduleIdPatchMutationOptions(
				options,
			);

		return useMutation(mutationOptions);
	};
/**
 * @summary Delete Deployment Schedule
 */
export type deleteDeploymentScheduleDeploymentsIdSchedulesScheduleIdDeleteResponse =
	{
		data: void | HTTPValidationError;
		status: number;
		headers: Headers;
	};

export const getDeleteDeploymentScheduleDeploymentsIdSchedulesScheduleIdDeleteUrl =
	(id: string, scheduleId: string) => {
		return `http://prefect.grose.click/api/deployments/${id}/schedules/${scheduleId}`;
	};

export const deleteDeploymentScheduleDeploymentsIdSchedulesScheduleIdDelete =
	async (
		id: string,
		scheduleId: string,
		options?: RequestInit,
	): Promise<deleteDeploymentScheduleDeploymentsIdSchedulesScheduleIdDeleteResponse> => {
		const res = await fetch(
			getDeleteDeploymentScheduleDeploymentsIdSchedulesScheduleIdDeleteUrl(
				id,
				scheduleId,
			),
			{
				...options,
				method: "DELETE",
			},
		);

		const body = [204, 205, 304].includes(res.status) ? null : await res.text();
		const data: deleteDeploymentScheduleDeploymentsIdSchedulesScheduleIdDeleteResponse["data"] =
			body ? JSON.parse(body) : {};

		return {
			data,
			status: res.status,
			headers: res.headers,
		} as deleteDeploymentScheduleDeploymentsIdSchedulesScheduleIdDeleteResponse;
	};

export const getDeleteDeploymentScheduleDeploymentsIdSchedulesScheduleIdDeleteMutationOptions =
	<TError = HTTPValidationError, TContext = unknown>(options?: {
		mutation?: UseMutationOptions<
			Awaited<
				ReturnType<
					typeof deleteDeploymentScheduleDeploymentsIdSchedulesScheduleIdDelete
				>
			>,
			TError,
			{ id: string; scheduleId: string },
			TContext
		>;
		fetch?: RequestInit;
	}): UseMutationOptions<
		Awaited<
			ReturnType<
				typeof deleteDeploymentScheduleDeploymentsIdSchedulesScheduleIdDelete
			>
		>,
		TError,
		{ id: string; scheduleId: string },
		TContext
	> => {
		const mutationKey = [
			"deleteDeploymentScheduleDeploymentsIdSchedulesScheduleIdDelete",
		];
		const { mutation: mutationOptions, fetch: fetchOptions } = options
			? options.mutation &&
				"mutationKey" in options.mutation &&
				options.mutation.mutationKey
				? options
				: { ...options, mutation: { ...options.mutation, mutationKey } }
			: { mutation: { mutationKey }, fetch: undefined };

		const mutationFn: MutationFunction<
			Awaited<
				ReturnType<
					typeof deleteDeploymentScheduleDeploymentsIdSchedulesScheduleIdDelete
				>
			>,
			{ id: string; scheduleId: string }
		> = (props) => {
			const { id, scheduleId } = props ?? {};

			return deleteDeploymentScheduleDeploymentsIdSchedulesScheduleIdDelete(
				id,
				scheduleId,
				fetchOptions,
			);
		};

		return { mutationFn, ...mutationOptions };
	};

export type DeleteDeploymentScheduleDeploymentsIdSchedulesScheduleIdDeleteMutationResult =
	NonNullable<
		Awaited<
			ReturnType<
				typeof deleteDeploymentScheduleDeploymentsIdSchedulesScheduleIdDelete
			>
		>
	>;

export type DeleteDeploymentScheduleDeploymentsIdSchedulesScheduleIdDeleteMutationError =
	HTTPValidationError;

/**
 * @summary Delete Deployment Schedule
 */
export const useDeleteDeploymentScheduleDeploymentsIdSchedulesScheduleIdDelete =
	<TError = HTTPValidationError, TContext = unknown>(options?: {
		mutation?: UseMutationOptions<
			Awaited<
				ReturnType<
					typeof deleteDeploymentScheduleDeploymentsIdSchedulesScheduleIdDelete
				>
			>,
			TError,
			{ id: string; scheduleId: string },
			TContext
		>;
		fetch?: RequestInit;
	}): UseMutationResult<
		Awaited<
			ReturnType<
				typeof deleteDeploymentScheduleDeploymentsIdSchedulesScheduleIdDelete
			>
		>,
		TError,
		{ id: string; scheduleId: string },
		TContext
	> => {
		const mutationOptions =
			getDeleteDeploymentScheduleDeploymentsIdSchedulesScheduleIdDeleteMutationOptions(
				options,
			);

		return useMutation(mutationOptions);
	};
