// This file is auto-generated by @hey-api/openapi-ts

export type Artifact = {
    id?: string;
    created?: string | null;
    updated?: string | null;
    /**
     * An optional unique reference key for this artifact.
     */
    key?: string | null;
    /**
     * An identifier that describes the shape of the data field. e.g. 'result', 'table', 'markdown'
     */
    type?: string | null;
    /**
     * A markdown-enabled description of the artifact.
     */
    description?: string | null;
    /**
     * Data associated with the artifact, e.g. a result.; structure depends on the artifact type.
     */
    data?: {
    [key: string]: unknown;
} | unknown | null;
    /**
     * User-defined artifact metadata. Content must be string key and value pairs.
     */
    metadata_?: {
    [key: string]: (string);
} | null;
    /**
     * The flow run associated with the artifact.
     */
    flow_run_id?: string | null;
    /**
     * The task run associated with the artifact.
     */
    task_run_id?: string | null;
};

export type ArtifactCollection = {
    id: string;
    created: string | null;
    updated: string | null;
    /**
     * An optional unique reference key for this artifact.
     */
    key: string;
    /**
     * The latest artifact ID associated with the key.
     */
    latest_id: string;
    /**
     * An identifier that describes the shape of the data field. e.g. 'result', 'table', 'markdown'
     */
    type?: string | null;
    /**
     * A markdown-enabled description of the artifact.
     */
    description?: string | null;
    /**
     * Data associated with the artifact, e.g. a result.; structure depends on the artifact type.
     */
    data?: {
    [key: string]: unknown;
} | unknown | null;
    /**
     * User-defined artifact metadata. Content must be string key and value pairs.
     */
    metadata_?: {
    [key: string]: (string);
} | null;
    /**
     * The flow run associated with the artifact.
     */
    flow_run_id?: string | null;
    /**
     * The task run associated with the artifact.
     */
    task_run_id?: string | null;
};

/**
 * Filter artifact collections. Only artifact collections matching all criteria will be returned
 */
export type ArtifactCollectionFilter = {
    /**
     * Operator for combining filter criteria. Defaults to 'and_'.
     */
    operator?: Operator;
    /**
     * Filter criteria for `Artifact.id`
     */
    latest_id?: ArtifactCollectionFilterLatestId | null;
    /**
     * Filter criteria for `Artifact.key`
     */
    key?: ArtifactCollectionFilterKey | null;
    /**
     * Filter criteria for `Artifact.flow_run_id`
     */
    flow_run_id?: ArtifactCollectionFilterFlowRunId | null;
    /**
     * Filter criteria for `Artifact.task_run_id`
     */
    task_run_id?: ArtifactCollectionFilterTaskRunId | null;
    /**
     * Filter criteria for `Artifact.type`
     */
    type?: ArtifactCollectionFilterType | null;
};

/**
 * Filter by `ArtifactCollection.flow_run_id`.
 */
export type ArtifactCollectionFilterFlowRunId = {
    /**
     * A list of flow run IDs to include
     */
    any_?: Array<(string)> | null;
};

/**
 * Filter by `ArtifactCollection.key`.
 */
export type ArtifactCollectionFilterKey = {
    /**
     * A list of artifact keys to include
     */
    any_?: Array<(string)> | null;
    /**
     * A string to match artifact keys against. This can include SQL wildcard characters like `%` and `_`.
     */
    like_?: string | null;
    /**
     * If `true`, only include artifacts with a non-null key. If `false`, only include artifacts with a null key. Should return all rows in the ArtifactCollection table if specified.
     */
    exists_?: boolean | null;
};

/**
 * Filter by `ArtifactCollection.latest_id`.
 */
export type ArtifactCollectionFilterLatestId = {
    /**
     * A list of artifact ids to include
     */
    any_?: Array<(string)> | null;
};

/**
 * Filter by `ArtifactCollection.task_run_id`.
 */
export type ArtifactCollectionFilterTaskRunId = {
    /**
     * A list of task run IDs to include
     */
    any_?: Array<(string)> | null;
};

/**
 * Filter by `ArtifactCollection.type`.
 */
export type ArtifactCollectionFilterType = {
    /**
     * A list of artifact types to include
     */
    any_?: Array<(string)> | null;
    /**
     * A list of artifact types to exclude
     */
    not_any_?: Array<(string)> | null;
};

/**
 * Defines artifact collection sorting options.
 */
export type ArtifactCollectionSort = 'CREATED_DESC' | 'UPDATED_DESC' | 'ID_DESC' | 'KEY_DESC' | 'KEY_ASC';

/**
 * Data used by the Prefect REST API to create an artifact.
 */
export type ArtifactCreate = {
    /**
     * An optional unique reference key for this artifact.
     */
    key?: string | null;
    /**
     * An identifier that describes the shape of the data field. e.g. 'result', 'table', 'markdown'
     */
    type?: string | null;
    /**
     * A markdown-enabled description of the artifact.
     */
    description?: string | null;
    /**
     * Data associated with the artifact, e.g. a result.; structure depends on the artifact type.
     */
    data?: {
    [key: string]: unknown;
} | unknown | null;
    /**
     * User-defined artifact metadata. Content must be string key and value pairs.
     */
    metadata_?: {
    [key: string]: (string);
} | null;
    /**
     * The flow run associated with the artifact.
     */
    flow_run_id?: string | null;
    /**
     * The task run associated with the artifact.
     */
    task_run_id?: string | null;
};

/**
 * Filter artifacts. Only artifacts matching all criteria will be returned
 */
export type ArtifactFilter = {
    /**
     * Operator for combining filter criteria. Defaults to 'and_'.
     */
    operator?: Operator;
    /**
     * Filter criteria for `Artifact.id`
     */
    id?: ArtifactFilterId | null;
    /**
     * Filter criteria for `Artifact.key`
     */
    key?: ArtifactFilterKey | null;
    /**
     * Filter criteria for `Artifact.flow_run_id`
     */
    flow_run_id?: ArtifactFilterFlowRunId | null;
    /**
     * Filter criteria for `Artifact.task_run_id`
     */
    task_run_id?: ArtifactFilterTaskRunId | null;
    /**
     * Filter criteria for `Artifact.type`
     */
    type?: ArtifactFilterType | null;
};

/**
 * Filter by `Artifact.flow_run_id`.
 */
export type ArtifactFilterFlowRunId = {
    /**
     * A list of flow run IDs to include
     */
    any_?: Array<(string)> | null;
};

/**
 * Filter by `Artifact.id`.
 */
export type ArtifactFilterId = {
    /**
     * A list of artifact ids to include
     */
    any_?: Array<(string)> | null;
};

/**
 * Filter by `Artifact.key`.
 */
export type ArtifactFilterKey = {
    /**
     * A list of artifact keys to include
     */
    any_?: Array<(string)> | null;
    /**
     * A string to match artifact keys against. This can include SQL wildcard characters like `%` and `_`.
     */
    like_?: string | null;
    /**
     * If `true`, only include artifacts with a non-null key. If `false`, only include artifacts with a null key.
     */
    exists_?: boolean | null;
};

/**
 * Filter by `Artifact.task_run_id`.
 */
export type ArtifactFilterTaskRunId = {
    /**
     * A list of task run IDs to include
     */
    any_?: Array<(string)> | null;
};

/**
 * Filter by `Artifact.type`.
 */
export type ArtifactFilterType = {
    /**
     * A list of artifact types to include
     */
    any_?: Array<(string)> | null;
    /**
     * A list of artifact types to exclude
     */
    not_any_?: Array<(string)> | null;
};

/**
 * Defines artifact sorting options.
 */
export type ArtifactSort = 'CREATED_DESC' | 'UPDATED_DESC' | 'ID_DESC' | 'KEY_DESC' | 'KEY_ASC';

/**
 * Data used by the Prefect REST API to update an artifact.
 */
export type ArtifactUpdate = {
    data?: {
    [key: string]: unknown;
} | unknown | null;
    description?: string | null;
    metadata_?: {
    [key: string]: (string);
} | null;
};

export type Automation = {
    /**
     * The name of this automation
     */
    name: string;
    /**
     * A longer description of this automation
     */
    description?: string;
    /**
     * Whether this automation will be evaluated
     */
    enabled?: boolean;
    /**
     * The criteria for which events this Automation covers and how it will respond to the presence or absence of those events
     */
    trigger: EventTrigger | CompoundTrigger_Output | SequenceTrigger_Output;
    /**
     * The actions to perform when this Automation triggers
     */
    actions: Array<(DoNothing | RunDeployment | PauseDeployment | ResumeDeployment | CancelFlowRun | ChangeFlowRunState | PauseWorkQueue | ResumeWorkQueue | SendNotification | CallWebhook | PauseAutomation | ResumeAutomation | SuspendFlowRun | ResumeFlowRun | PauseWorkPool | ResumeWorkPool)>;
    /**
     * The actions to perform when an Automation goes into a triggered state
     */
    actions_on_trigger?: Array<(DoNothing | RunDeployment | PauseDeployment | ResumeDeployment | CancelFlowRun | ChangeFlowRunState | PauseWorkQueue | ResumeWorkQueue | SendNotification | CallWebhook | PauseAutomation | ResumeAutomation | SuspendFlowRun | ResumeFlowRun | PauseWorkPool | ResumeWorkPool)>;
    /**
     * The actions to perform when an Automation goes into a resolving state
     */
    actions_on_resolve?: Array<(DoNothing | RunDeployment | PauseDeployment | ResumeDeployment | CancelFlowRun | ChangeFlowRunState | PauseWorkQueue | ResumeWorkQueue | SendNotification | CallWebhook | PauseAutomation | ResumeAutomation | SuspendFlowRun | ResumeFlowRun | PauseWorkPool | ResumeWorkPool)>;
    id: string;
    created: string | null;
    updated: string | null;
};

export type AutomationCreate = {
    /**
     * The name of this automation
     */
    name: string;
    /**
     * A longer description of this automation
     */
    description?: string;
    /**
     * Whether this automation will be evaluated
     */
    enabled?: boolean;
    /**
     * The criteria for which events this Automation covers and how it will respond to the presence or absence of those events
     */
    trigger: EventTrigger | CompoundTrigger_Input | SequenceTrigger_Input;
    /**
     * The actions to perform when this Automation triggers
     */
    actions: Array<(DoNothing | RunDeployment | PauseDeployment | ResumeDeployment | CancelFlowRun | ChangeFlowRunState | PauseWorkQueue | ResumeWorkQueue | SendNotification | CallWebhook | PauseAutomation | ResumeAutomation | SuspendFlowRun | ResumeFlowRun | PauseWorkPool | ResumeWorkPool)>;
    /**
     * The actions to perform when an Automation goes into a triggered state
     */
    actions_on_trigger?: Array<(DoNothing | RunDeployment | PauseDeployment | ResumeDeployment | CancelFlowRun | ChangeFlowRunState | PauseWorkQueue | ResumeWorkQueue | SendNotification | CallWebhook | PauseAutomation | ResumeAutomation | SuspendFlowRun | ResumeFlowRun | PauseWorkPool | ResumeWorkPool)>;
    /**
     * The actions to perform when an Automation goes into a resolving state
     */
    actions_on_resolve?: Array<(DoNothing | RunDeployment | PauseDeployment | ResumeDeployment | CancelFlowRun | ChangeFlowRunState | PauseWorkQueue | ResumeWorkQueue | SendNotification | CallWebhook | PauseAutomation | ResumeAutomation | SuspendFlowRun | ResumeFlowRun | PauseWorkPool | ResumeWorkPool)>;
    /**
     * The resource to which this automation belongs
     */
    owner_resource?: string | null;
};

export type AutomationFilter = {
    /**
     * Operator for combining filter criteria. Defaults to 'and_'.
     */
    operator?: Operator;
    /**
     * Filter criteria for `Automation.name`
     */
    name?: AutomationFilterName | null;
    /**
     * Filter criteria for `Automation.created`
     */
    created?: AutomationFilterCreated | null;
};

/**
 * Filter by `Automation.created`.
 */
export type AutomationFilterCreated = {
    /**
     * Only include automations created before this datetime
     */
    before_?: string | null;
};

/**
 * Filter by `Automation.created`.
 */
export type AutomationFilterName = {
    /**
     * Only include automations with names that match any of these strings
     */
    any_?: Array<(string)> | null;
};

export type AutomationPartialUpdate = {
    /**
     * Whether this automation will be evaluated
     */
    enabled?: boolean;
};

/**
 * Defines automations sorting options.
 */
export type AutomationSort = 'CREATED_DESC' | 'UPDATED_DESC' | 'NAME_ASC' | 'NAME_DESC';

export type AutomationUpdate = {
    /**
     * The name of this automation
     */
    name: string;
    /**
     * A longer description of this automation
     */
    description?: string;
    /**
     * Whether this automation will be evaluated
     */
    enabled?: boolean;
    /**
     * The criteria for which events this Automation covers and how it will respond to the presence or absence of those events
     */
    trigger: EventTrigger | CompoundTrigger_Input | SequenceTrigger_Input;
    /**
     * The actions to perform when this Automation triggers
     */
    actions: Array<(DoNothing | RunDeployment | PauseDeployment | ResumeDeployment | CancelFlowRun | ChangeFlowRunState | PauseWorkQueue | ResumeWorkQueue | SendNotification | CallWebhook | PauseAutomation | ResumeAutomation | SuspendFlowRun | ResumeFlowRun | PauseWorkPool | ResumeWorkPool)>;
    /**
     * The actions to perform when an Automation goes into a triggered state
     */
    actions_on_trigger?: Array<(DoNothing | RunDeployment | PauseDeployment | ResumeDeployment | CancelFlowRun | ChangeFlowRunState | PauseWorkQueue | ResumeWorkQueue | SendNotification | CallWebhook | PauseAutomation | ResumeAutomation | SuspendFlowRun | ResumeFlowRun | PauseWorkPool | ResumeWorkPool)>;
    /**
     * The actions to perform when an Automation goes into a resolving state
     */
    actions_on_resolve?: Array<(DoNothing | RunDeployment | PauseDeployment | ResumeDeployment | CancelFlowRun | ChangeFlowRunState | PauseWorkQueue | ResumeWorkQueue | SendNotification | CallWebhook | PauseAutomation | ResumeAutomation | SuspendFlowRun | ResumeFlowRun | PauseWorkPool | ResumeWorkPool)>;
};

/**
 * An ORM representation of a block document.
 */
export type BlockDocument = {
    id: string;
    created: string | null;
    updated: string | null;
    /**
     * The block document's name. Not required for anonymous block documents.
     */
    name?: string | null;
    /**
     * The block document's data
     */
    data?: {
        [key: string]: unknown;
    };
    /**
     * A block schema ID
     */
    block_schema_id: string;
    /**
     * The associated block schema
     */
    block_schema?: BlockSchema | null;
    /**
     * A block type ID
     */
    block_type_id: string;
    /**
     * The associated block type's name
     */
    block_type_name?: string | null;
    /**
     * The associated block type
     */
    block_type?: BlockType | null;
    /**
     * Record of the block document's references
     */
    block_document_references?: {
        [key: string]: {
            [key: string]: unknown;
        };
    };
    /**
     * Whether the block is anonymous (anonymous blocks are usually created by Prefect automatically)
     */
    is_anonymous?: boolean;
};

/**
 * Data used by the Prefect REST API to create a block document.
 */
export type BlockDocumentCreate = {
    /**
     * The block document's name. Not required for anonymous block documents.
     */
    name?: string | null;
    /**
     * The block document's data
     */
    data?: {
        [key: string]: unknown;
    };
    /**
     * A block schema ID
     */
    block_schema_id: string;
    /**
     * A block type ID
     */
    block_type_id: string;
    /**
     * Whether the block is anonymous (anonymous blocks are usually created by Prefect automatically)
     */
    is_anonymous?: boolean;
};

/**
 * Filter BlockDocuments. Only BlockDocuments matching all criteria will be returned
 */
export type BlockDocumentFilter = {
    /**
     * Operator for combining filter criteria. Defaults to 'and_'.
     */
    operator?: Operator;
    /**
     * Filter criteria for `BlockDocument.id`
     */
    id?: BlockDocumentFilterId | null;
    /**
     * Filter criteria for `BlockDocument.is_anonymous`. Defaults to excluding anonymous blocks.
     */
    is_anonymous?: BlockDocumentFilterIsAnonymous | null;
    /**
     * Filter criteria for `BlockDocument.block_type_id`
     */
    block_type_id?: BlockDocumentFilterBlockTypeId | null;
    /**
     * Filter criteria for `BlockDocument.name`
     */
    name?: BlockDocumentFilterName | null;
};

/**
 * Filter by `BlockDocument.block_type_id`.
 */
export type BlockDocumentFilterBlockTypeId = {
    /**
     * A list of block type ids to include
     */
    any_?: Array<(string)> | null;
};

/**
 * Filter by `BlockDocument.id`.
 */
export type BlockDocumentFilterId = {
    /**
     * A list of block ids to include
     */
    any_?: Array<(string)> | null;
};

/**
 * Filter by `BlockDocument.is_anonymous`.
 */
export type BlockDocumentFilterIsAnonymous = {
    /**
     * Filter block documents for only those that are or are not anonymous.
     */
    eq_?: boolean | null;
};

/**
 * Filter by `BlockDocument.name`.
 */
export type BlockDocumentFilterName = {
    /**
     * A list of block names to include
     */
    any_?: Array<(string)> | null;
    /**
     * A string to match block names against. This can include SQL wildcard characters like `%` and `_`.
     */
    like_?: string | null;
};

/**
 * Defines block document sorting options.
 */
export type BlockDocumentSort = 'NAME_DESC' | 'NAME_ASC' | 'BLOCK_TYPE_AND_NAME_ASC';

/**
 * Data used by the Prefect REST API to update a block document.
 */
export type BlockDocumentUpdate = {
    /**
     * A block schema ID
     */
    block_schema_id?: string | null;
    /**
     * The block document's data
     */
    data?: {
        [key: string]: unknown;
    };
    merge_existing_data?: boolean;
};

/**
 * An ORM representation of a block schema.
 */
export type BlockSchema = {
    id: string;
    created: string | null;
    updated: string | null;
    /**
     * The block schema's unique checksum
     */
    checksum: string;
    /**
     * The block schema's field schema
     */
    fields?: {
        [key: string]: unknown;
    };
    /**
     * A block type ID
     */
    block_type_id: string | null;
    /**
     * The associated block type
     */
    block_type?: BlockType | null;
    /**
     * A list of Block capabilities
     */
    capabilities?: Array<(string)>;
    /**
     * Human readable identifier for the block schema
     */
    version?: string;
};

/**
 * Data used by the Prefect REST API to create a block schema.
 */
export type BlockSchemaCreate = {
    /**
     * The block schema's field schema
     */
    fields?: {
        [key: string]: unknown;
    };
    /**
     * A block type ID
     */
    block_type_id: string;
    /**
     * A list of Block capabilities
     */
    capabilities?: Array<(string)>;
    /**
     * Human readable identifier for the block schema
     */
    version?: string;
};

/**
 * Filter BlockSchemas
 */
export type BlockSchemaFilter = {
    /**
     * Operator for combining filter criteria. Defaults to 'and_'.
     */
    operator?: Operator;
    /**
     * Filter criteria for `BlockSchema.block_type_id`
     */
    block_type_id?: BlockSchemaFilterBlockTypeId | null;
    /**
     * Filter criteria for `BlockSchema.capabilities`
     */
    block_capabilities?: BlockSchemaFilterCapabilities | null;
    /**
     * Filter criteria for `BlockSchema.id`
     */
    id?: BlockSchemaFilterId | null;
    /**
     * Filter criteria for `BlockSchema.version`
     */
    version?: BlockSchemaFilterVersion | null;
};

/**
 * Filter by `BlockSchema.block_type_id`.
 */
export type BlockSchemaFilterBlockTypeId = {
    /**
     * A list of block type ids to include
     */
    any_?: Array<(string)> | null;
};

/**
 * Filter by `BlockSchema.capabilities`
 */
export type BlockSchemaFilterCapabilities = {
    /**
     * A list of block capabilities. Block entities will be returned only if an associated block schema has a superset of the defined capabilities.
     */
    all_?: Array<(string)> | null;
};

/**
 * Filter by BlockSchema.id
 */
export type BlockSchemaFilterId = {
    /**
     * A list of IDs to include
     */
    any_?: Array<(string)> | null;
};

/**
 * Filter by `BlockSchema.capabilities`
 */
export type BlockSchemaFilterVersion = {
    /**
     * A list of block schema versions.
     */
    any_?: Array<(string)> | null;
};

/**
 * An ORM representation of a block type
 */
export type BlockType = {
    id: string;
    created: string | null;
    updated: string | null;
    /**
     * A block type's name
     */
    name: string;
    /**
     * A block type's slug
     */
    slug: string;
    /**
     * Web URL for the block type's logo
     */
    logo_url?: string | null;
    /**
     * Web URL for the block type's documentation
     */
    documentation_url?: string | null;
    /**
     * A short blurb about the corresponding block's intended use
     */
    description?: string | null;
    /**
     * A code snippet demonstrating use of the corresponding block
     */
    code_example?: string | null;
    /**
     * Protected block types cannot be modified via API.
     */
    is_protected?: boolean;
};

/**
 * Data used by the Prefect REST API to create a block type.
 */
export type BlockTypeCreate = {
    /**
     * A block type's name
     */
    name: string;
    /**
     * A block type's slug
     */
    slug: string;
    /**
     * Web URL for the block type's logo
     */
    logo_url?: string | null;
    /**
     * Web URL for the block type's documentation
     */
    documentation_url?: string | null;
    /**
     * A short blurb about the corresponding block's intended use
     */
    description?: string | null;
    /**
     * A code snippet demonstrating use of the corresponding block
     */
    code_example?: string | null;
};

/**
 * Filter BlockTypes
 */
export type BlockTypeFilter = {
    /**
     * Filter criteria for `BlockType.name`
     */
    name?: BlockTypeFilterName | null;
    /**
     * Filter criteria for `BlockType.slug`
     */
    slug?: BlockTypeFilterSlug | null;
};

/**
 * Filter by `BlockType.name`
 */
export type BlockTypeFilterName = {
    /**
     * A case-insensitive partial match. For example,  passing 'marvin' will match 'marvin', 'sad-Marvin', and 'marvin-robot'.
     */
    like_?: string | null;
};

/**
 * Filter by `BlockType.slug`
 */
export type BlockTypeFilterSlug = {
    /**
     * A list of slugs to match
     */
    any_?: Array<(string)> | null;
};

/**
 * Data used by the Prefect REST API to update a block type.
 */
export type BlockTypeUpdate = {
    logo_url?: string | null;
    documentation_url?: string | null;
    description?: string | null;
    code_example?: string | null;
};

export type Body_average_flow_run_lateness_flow_runs_lateness_post = {
    flows?: FlowFilter | null;
    flow_runs?: FlowRunFilter | null;
    task_runs?: TaskRunFilter | null;
    deployments?: DeploymentFilter | null;
    work_pools?: WorkPoolFilter | null;
    work_pool_queues?: WorkQueueFilter | null;
};

export type Body_bulk_decrement_active_slots_v2_concurrency_limits_decrement_post = {
    slots: number;
    names: Array<(string)>;
    occupancy_seconds?: number | null;
    create_if_missing?: boolean;
};

export type Body_bulk_increment_active_slots_v2_concurrency_limits_increment_post = {
    slots: number;
    names: Array<(string)>;
    mode?: 'concurrency' | 'rate_limit';
    create_if_missing?: boolean | null;
};

export type mode = 'concurrency' | 'rate_limit';

export type Body_clear_database_admin_database_clear_post = {
    /**
     * Pass confirm=True to confirm you want to modify the database.
     */
    confirm?: boolean;
};

export type Body_count_account_events_events_count_by__countable__post = {
    filter: EventFilter;
    time_unit?: TimeUnit;
    time_interval?: number;
};

export type Body_count_artifacts_artifacts_count_post = {
    artifacts?: ArtifactFilter;
    flow_runs?: FlowRunFilter;
    task_runs?: TaskRunFilter;
    flows?: FlowFilter;
    deployments?: DeploymentFilter;
};

export type Body_count_block_documents_block_documents_count_post = {
    block_documents?: BlockDocumentFilter | null;
    block_types?: BlockTypeFilter | null;
    block_schemas?: BlockSchemaFilter | null;
};

export type Body_count_deployments_by_flow_ui_flows_count_deployments_post = {
    flow_ids: Array<(string)>;
};

export type Body_count_deployments_deployments_count_post = {
    flows?: FlowFilter;
    flow_runs?: FlowRunFilter;
    task_runs?: TaskRunFilter;
    deployments?: DeploymentFilter;
    work_pools?: WorkPoolFilter;
    work_pool_queues?: WorkQueueFilter;
};

export type Body_count_flow_runs_flow_runs_count_post = {
    flows?: FlowFilter;
    flow_runs?: FlowRunFilter;
    task_runs?: TaskRunFilter;
    deployments?: DeploymentFilter;
    work_pools?: WorkPoolFilter;
    work_pool_queues?: WorkQueueFilter;
};

export type Body_count_flows_flows_count_post = {
    flows?: FlowFilter;
    flow_runs?: FlowRunFilter;
    task_runs?: TaskRunFilter;
    deployments?: DeploymentFilter;
    work_pools?: WorkPoolFilter;
};

export type Body_count_latest_artifacts_artifacts_latest_count_post = {
    artifacts?: ArtifactCollectionFilter;
    flow_runs?: FlowRunFilter;
    task_runs?: TaskRunFilter;
    flows?: FlowFilter;
    deployments?: DeploymentFilter;
};

export type Body_count_task_runs_by_flow_run_ui_flow_runs_count_task_runs_post = {
    flow_run_ids: Array<(string)>;
};

export type Body_count_task_runs_task_runs_count_post = {
    flows?: FlowFilter;
    flow_runs?: FlowRunFilter;
    task_runs?: TaskRunFilter;
    deployments?: DeploymentFilter;
};

export type Body_count_variables_variables_count_post = {
    variables?: VariableFilter | null;
};

export type Body_count_work_pools_work_pools_count_post = {
    work_pools?: WorkPoolFilter | null;
};

export type Body_create_database_admin_database_create_post = {
    /**
     * Pass confirm=True to confirm you want to modify the database.
     */
    confirm?: boolean;
};

export type Body_create_flow_run_input_flow_runs__id__input_post = {
    /**
     * The input key
     */
    key: string;
    /**
     * The value of the input
     */
    value: (Blob | File);
    /**
     * The sender of the input
     */
    sender?: string | null;
};

export type Body_decrement_concurrency_limits_v1_concurrency_limits_decrement_post = {
    /**
     * The tags to release a slot for
     */
    names: Array<(string)>;
    /**
     * The ID of the task run releasing the slot
     */
    task_run_id: string;
};

export type Body_drop_database_admin_database_drop_post = {
    /**
     * Pass confirm=True to confirm you want to modify the database.
     */
    confirm?: boolean;
};

export type Body_filter_flow_run_input_flow_runs__id__input_filter_post = {
    /**
     * The input key prefix
     */
    prefix: string;
    /**
     * The maximum number of results to return
     */
    limit?: number;
    /**
     * Exclude inputs with these keys
     */
    exclude_keys?: Array<(string)>;
};

export type Body_flow_run_history_flow_runs_history_post = {
    /**
     * The history's start time.
     */
    history_start: string;
    /**
     * The history's end time.
     */
    history_end: string;
    /**
     * The size of each history interval, in seconds. Must be at least 1 second.
     */
    history_interval: number;
    flows?: FlowFilter;
    flow_runs?: FlowRunFilter;
    task_runs?: TaskRunFilter;
    deployments?: DeploymentFilter;
    work_pools?: WorkPoolFilter;
    work_queues?: WorkQueueFilter;
};

export type Body_get_scheduled_flow_runs_for_deployments_deployments_get_scheduled_flow_runs_post = {
    /**
     * The deployment IDs to get scheduled runs for
     */
    deployment_ids: Array<(string)>;
    /**
     * The maximum time to look for scheduled flow runs
     */
    scheduled_before?: string;
    /**
     * Defaults to PREFECT_API_DEFAULT_LIMIT if not provided.
     */
    limit?: number;
};

export type Body_get_scheduled_flow_runs_work_pools__name__get_scheduled_flow_runs_post = {
    /**
     * The names of work pool queues
     */
    work_queue_names?: Array<(string)>;
    /**
     * The maximum time to look for scheduled flow runs
     */
    scheduled_before?: string;
    /**
     * The minimum time to look for scheduled flow runs
     */
    scheduled_after?: string;
    /**
     * Defaults to PREFECT_API_DEFAULT_LIMIT if not provided.
     */
    limit?: number;
};

export type Body_increment_concurrency_limits_v1_concurrency_limits_increment_post = {
    /**
     * The tags to acquire a slot for
     */
    names: Array<(string)>;
    /**
     * The ID of the task run acquiring the slot
     */
    task_run_id: string;
};

export type Body_next_runs_by_flow_ui_flows_next_runs_post = {
    flow_ids: Array<(string)>;
};

export type Body_paginate_deployments_deployments_paginate_post = {
    page?: number;
    flows?: FlowFilter;
    flow_runs?: FlowRunFilter;
    task_runs?: TaskRunFilter;
    deployments?: DeploymentFilter;
    work_pools?: WorkPoolFilter;
    work_pool_queues?: WorkQueueFilter;
    sort?: DeploymentSort;
    /**
     * Defaults to PREFECT_API_DEFAULT_LIMIT if not provided.
     */
    limit?: number;
};

export type Body_paginate_flow_runs_flow_runs_paginate_post = {
    sort?: FlowRunSort;
    page?: number;
    flows?: FlowFilter | null;
    flow_runs?: FlowRunFilter | null;
    task_runs?: TaskRunFilter | null;
    deployments?: DeploymentFilter | null;
    work_pools?: WorkPoolFilter | null;
    work_pool_queues?: WorkQueueFilter | null;
    /**
     * Defaults to PREFECT_API_DEFAULT_LIMIT if not provided.
     */
    limit?: number;
};

export type Body_paginate_flows_flows_paginate_post = {
    page?: number;
    flows?: FlowFilter | null;
    flow_runs?: FlowRunFilter | null;
    task_runs?: TaskRunFilter | null;
    deployments?: DeploymentFilter | null;
    work_pools?: WorkPoolFilter | null;
    sort?: FlowSort;
    /**
     * Defaults to PREFECT_API_DEFAULT_LIMIT if not provided.
     */
    limit?: number;
};

export type Body_read_all_concurrency_limits_v2_v2_concurrency_limits_filter_post = {
    offset?: number;
    /**
     * Defaults to PREFECT_API_DEFAULT_LIMIT if not provided.
     */
    limit?: number;
};

export type Body_read_artifacts_artifacts_filter_post = {
    sort?: ArtifactSort;
    offset?: number;
    artifacts?: ArtifactFilter;
    flow_runs?: FlowRunFilter;
    task_runs?: TaskRunFilter;
    flows?: FlowFilter;
    deployments?: DeploymentFilter;
    /**
     * Defaults to PREFECT_API_DEFAULT_LIMIT if not provided.
     */
    limit?: number;
};

export type Body_read_automations_automations_filter_post = {
    sort?: AutomationSort;
    offset?: number;
    automations?: AutomationFilter | null;
    /**
     * Defaults to PREFECT_API_DEFAULT_LIMIT if not provided.
     */
    limit?: number;
};

export type Body_read_block_documents_block_documents_filter_post = {
    block_documents?: BlockDocumentFilter | null;
    block_types?: BlockTypeFilter | null;
    block_schemas?: BlockSchemaFilter | null;
    /**
     * Whether to include sensitive values in the block document.
     */
    include_secrets?: boolean;
    sort?: BlockDocumentSort | null;
    offset?: number;
    /**
     * Defaults to PREFECT_API_DEFAULT_LIMIT if not provided.
     */
    limit?: number;
};

export type Body_read_block_schemas_block_schemas_filter_post = {
    block_schemas?: BlockSchemaFilter | null;
    offset?: number;
    /**
     * Defaults to PREFECT_API_DEFAULT_LIMIT if not provided.
     */
    limit?: number;
};

export type Body_read_block_types_block_types_filter_post = {
    block_types?: BlockTypeFilter | null;
    block_schemas?: BlockSchemaFilter | null;
    offset?: number;
    /**
     * Defaults to PREFECT_API_DEFAULT_LIMIT if not provided.
     */
    limit?: number;
};

export type Body_read_concurrency_limits_concurrency_limits_filter_post = {
    offset?: number;
    /**
     * Defaults to PREFECT_API_DEFAULT_LIMIT if not provided.
     */
    limit?: number;
};

export type Body_read_dashboard_task_run_counts_ui_task_runs_dashboard_counts_post = {
    task_runs: TaskRunFilter;
    flows?: FlowFilter | null;
    flow_runs?: FlowRunFilter | null;
    deployments?: DeploymentFilter | null;
    work_pools?: WorkPoolFilter | null;
    work_queues?: WorkQueueFilter | null;
};

export type Body_read_deployments_deployments_filter_post = {
    offset?: number;
    flows?: FlowFilter;
    flow_runs?: FlowRunFilter;
    task_runs?: TaskRunFilter;
    deployments?: DeploymentFilter;
    work_pools?: WorkPoolFilter;
    work_pool_queues?: WorkQueueFilter;
    sort?: DeploymentSort;
    /**
     * Defaults to PREFECT_API_DEFAULT_LIMIT if not provided.
     */
    limit?: number;
};

export type Body_read_events_events_filter_post = {
    /**
     * Additional optional filter criteria to narrow down the set of Events
     */
    filter?: EventFilter | null;
    /**
     * The number of events to return with each page
     */
    limit?: number;
};

export type Body_read_flow_run_history_ui_flow_runs_history_post = {
    sort?: FlowRunSort;
    limit?: number;
    offset?: number;
    flows?: FlowFilter;
    flow_runs?: FlowRunFilter;
    task_runs?: TaskRunFilter;
    deployments?: DeploymentFilter;
    work_pools?: WorkPoolFilter;
};

export type Body_read_flow_run_notification_policies_flow_run_notification_policies_filter_post = {
    flow_run_notification_policy_filter?: FlowRunNotificationPolicyFilter;
    offset?: number;
    /**
     * Defaults to PREFECT_API_DEFAULT_LIMIT if not provided.
     */
    limit?: number;
};

export type Body_read_flow_runs_flow_runs_filter_post = {
    sort?: FlowRunSort;
    offset?: number;
    flows?: FlowFilter | null;
    flow_runs?: FlowRunFilter | null;
    task_runs?: TaskRunFilter | null;
    deployments?: DeploymentFilter | null;
    work_pools?: WorkPoolFilter | null;
    work_pool_queues?: WorkQueueFilter | null;
    /**
     * Defaults to PREFECT_API_DEFAULT_LIMIT if not provided.
     */
    limit?: number;
};

export type Body_read_flows_flows_filter_post = {
    offset?: number;
    flows?: FlowFilter;
    flow_runs?: FlowRunFilter;
    task_runs?: TaskRunFilter;
    deployments?: DeploymentFilter;
    work_pools?: WorkPoolFilter;
    sort?: FlowSort;
    /**
     * Defaults to PREFECT_API_DEFAULT_LIMIT if not provided.
     */
    limit?: number;
};

export type Body_read_latest_artifacts_artifacts_latest_filter_post = {
    sort?: ArtifactCollectionSort;
    offset?: number;
    artifacts?: ArtifactCollectionFilter;
    flow_runs?: FlowRunFilter;
    task_runs?: TaskRunFilter;
    flows?: FlowFilter;
    deployments?: DeploymentFilter;
    /**
     * Defaults to PREFECT_API_DEFAULT_LIMIT if not provided.
     */
    limit?: number;
};

export type Body_read_logs_logs_filter_post = {
    offset?: number;
    logs?: LogFilter;
    sort?: LogSort;
    /**
     * Defaults to PREFECT_API_DEFAULT_LIMIT if not provided.
     */
    limit?: number;
};

export type Body_read_saved_searches_saved_searches_filter_post = {
    offset?: number;
    /**
     * Defaults to PREFECT_API_DEFAULT_LIMIT if not provided.
     */
    limit?: number;
};

export type Body_read_task_run_counts_by_state_ui_task_runs_count_post = {
    flows?: FlowFilter | null;
    flow_runs?: FlowRunFilter | null;
    task_runs?: TaskRunFilter | null;
    deployments?: DeploymentFilter | null;
};

export type Body_read_task_runs_task_runs_filter_post = {
    sort?: TaskRunSort;
    offset?: number;
    flows?: FlowFilter | null;
    flow_runs?: FlowRunFilter | null;
    task_runs?: TaskRunFilter | null;
    deployments?: DeploymentFilter | null;
    /**
     * Defaults to PREFECT_API_DEFAULT_LIMIT if not provided.
     */
    limit?: number;
};

export type Body_read_task_workers_task_workers_filter_post = {
    /**
     * The task worker filter
     */
    task_worker_filter?: TaskWorkerFilter | null;
};

export type Body_read_variables_variables_filter_post = {
    offset?: number;
    variables?: VariableFilter | null;
    sort?: VariableSort;
    /**
     * Defaults to PREFECT_API_DEFAULT_LIMIT if not provided.
     */
    limit?: number;
};

export type Body_read_work_pools_work_pools_filter_post = {
    work_pools?: WorkPoolFilter | null;
    offset?: number;
    /**
     * Defaults to PREFECT_API_DEFAULT_LIMIT if not provided.
     */
    limit?: number;
};

export type Body_read_work_queue_runs_work_queues__id__get_runs_post = {
    /**
     * Only flow runs scheduled to start before this time will be returned.
     */
    scheduled_before?: string;
    /**
     * An optional unique identifier for the agent making this query. If provided, the Prefect REST API will track the last time this agent polled the work queue.
     */
    agent_id?: string | null;
    /**
     * Defaults to PREFECT_API_DEFAULT_LIMIT if not provided.
     */
    limit?: number;
};

export type Body_read_work_queues_work_pools__work_pool_name__queues_filter_post = {
    work_queues?: WorkQueueFilter;
    offset?: number;
    /**
     * Defaults to PREFECT_API_DEFAULT_LIMIT if not provided.
     */
    limit?: number;
};

export type Body_read_work_queues_work_queues_filter_post = {
    offset?: number;
    work_queues?: WorkQueueFilter;
    /**
     * Defaults to PREFECT_API_DEFAULT_LIMIT if not provided.
     */
    limit?: number;
};

export type Body_read_workers_work_pools__work_pool_name__workers_filter_post = {
    workers?: WorkerFilter | null;
    offset?: number;
    /**
     * Defaults to PREFECT_API_DEFAULT_LIMIT if not provided.
     */
    limit?: number;
};

export type Body_reset_concurrency_limit_by_tag_concurrency_limits_tag__tag__reset_post = {
    /**
     * Manual override for active concurrency limit slots.
     */
    slot_override?: Array<(string)> | null;
};

export type Body_resume_flow_run_flow_runs__id__resume_post = {
    run_input?: {
    [key: string]: unknown;
} | null;
};

export type Body_schedule_deployment_deployments__id__schedule_post = {
    /**
     * The earliest date to schedule
     */
    start_time?: string;
    /**
     * The latest date to schedule
     */
    end_time?: string;
    /**
     * Runs will be scheduled until at least this long after the `start_time`
     */
    min_time?: number;
    /**
     * The minimum number of runs to schedule
     */
    min_runs?: number;
    /**
     * The maximum number of runs to schedule
     */
    max_runs?: number;
};

export type Body_set_flow_run_state_flow_runs__id__set_state_post = {
    /**
     * The intended state.
     */
    state: StateCreate;
    /**
     * If false, orchestration rules will be applied that may alter or prevent the state transition. If True, orchestration rules are not applied.
     */
    force?: boolean;
};

export type Body_set_task_run_state_task_runs__id__set_state_post = {
    /**
     * The intended state.
     */
    state: StateCreate;
    /**
     * If false, orchestration rules will be applied that may alter or prevent the state transition. If True, orchestration rules are not applied.
     */
    force?: boolean;
};

export type Body_task_run_history_task_runs_history_post = {
    /**
     * The history's start time.
     */
    history_start: string;
    /**
     * The history's end time.
     */
    history_end: string;
    /**
     * The size of each history interval, in seconds. Must be at least 1 second.
     */
    history_interval: number;
    flows?: FlowFilter;
    flow_runs?: FlowRunFilter;
    task_runs?: TaskRunFilter;
    deployments?: DeploymentFilter;
};

export type Body_validate_obj_ui_schemas_validate_post = {
    json_schema: {
        [key: string]: unknown;
    };
    values: {
        [key: string]: unknown;
    };
};

export type Body_worker_heartbeat_work_pools__work_pool_name__workers_heartbeat_post = {
    /**
     * The worker process name
     */
    name: string;
    /**
     * The worker's heartbeat interval in seconds
     */
    heartbeat_interval_seconds?: number | null;
};

/**
 * Call a webhook when an Automation is triggered.
 */
export type CallWebhook = {
    type?: "call-webhook";
    /**
     * The identifier of the webhook block to use
     */
    block_document_id: string;
    /**
     * An optional templatable payload to send when calling the webhook.
     */
    payload?: string;
};

/**
 * Cancels a flow run associated with the trigger
 */
export type CancelFlowRun = {
    type?: "cancel-flow-run";
};

/**
 * Changes the state of a flow run associated with the trigger
 */
export type ChangeFlowRunState = {
    type?: "change-flow-run-state";
    /**
     * The name of the state to change the flow run to
     */
    name?: string | null;
    /**
     * The type of the state to change the flow run to
     */
    state: StateType;
    /**
     * An optional message to associate with the state change
     */
    message?: string | null;
};

/**
 * A composite trigger that requires some number of triggers to have
 * fired within the given time period
 */
export type CompoundTrigger_Input = {
    type?: "compound";
    /**
     * The unique ID of this trigger
     */
    id?: string;
    triggers: Array<(EventTrigger | CompoundTrigger_Input | SequenceTrigger_Input)>;
    within: number | null;
    require: number | 'any' | 'all';
};

/**
 * A composite trigger that requires some number of triggers to have
 * fired within the given time period
 */
export type CompoundTrigger_Output = {
    type?: "compound";
    /**
     * The unique ID of this trigger
     */
    id?: string;
    triggers: Array<(EventTrigger | CompoundTrigger_Output | SequenceTrigger_Output)>;
    within: number | null;
    require: number | 'any' | 'all';
};

/**
 * An ORM representation of a concurrency limit.
 */
export type ConcurrencyLimit = {
    id: string;
    created: string | null;
    updated: string | null;
    /**
     * A tag the concurrency limit is applied to.
     */
    tag: string;
    /**
     * The concurrency limit.
     */
    concurrency_limit: number;
    /**
     * A list of active run ids using a concurrency slot
     */
    active_slots?: Array<(string)>;
};

/**
 * Data used by the Prefect REST API to create a concurrency limit.
 */
export type ConcurrencyLimitCreate = {
    /**
     * A tag the concurrency limit is applied to.
     */
    tag: string;
    /**
     * The concurrency limit.
     */
    concurrency_limit: number;
};

/**
 * Enumeration of concurrency collision strategies.
 */
export type ConcurrencyLimitStrategy = 'ENQUEUE' | 'CANCEL_NEW';

/**
 * An ORM representation of a v2 concurrency limit.
 */
export type ConcurrencyLimitV2 = {
    id: string;
    created: string | null;
    updated: string | null;
    /**
     * Whether the concurrency limit is active.
     */
    active?: boolean;
    /**
     * The name of the concurrency limit.
     */
    name: string;
    /**
     * The concurrency limit.
     */
    limit: number;
    /**
     * The number of active slots.
     */
    active_slots?: number;
    /**
     * The number of denied slots.
     */
    denied_slots?: number;
    /**
     * The decay rate for active slots when used as a rate limit.
     */
    slot_decay_per_second?: number;
    /**
     * The average amount of time a slot is occupied.
     */
    avg_slot_occupancy_seconds?: number;
};

/**
 * Data used by the Prefect REST API to create a v2 concurrency limit.
 */
export type ConcurrencyLimitV2Create = {
    /**
     * Whether the concurrency limit is active.
     */
    active?: boolean;
    /**
     * The name of the concurrency limit.
     */
    name: string;
    /**
     * The concurrency limit.
     */
    limit: number;
    /**
     * The number of active slots.
     */
    active_slots?: number;
    /**
     * The number of denied slots.
     */
    denied_slots?: number;
    /**
     * The decay rate for active slots when used as a rate limit.
     */
    slot_decay_per_second?: number;
};

/**
 * Data used by the Prefect REST API to update a v2 concurrency limit.
 */
export type ConcurrencyLimitV2Update = {
    active?: boolean | null;
    name?: string | null;
    limit?: number | null;
    active_slots?: number | null;
    denied_slots?: number | null;
    slot_decay_per_second?: number | null;
};

/**
 * Class for storing the concurrency config in database.
 */
export type ConcurrencyOptions = {
    collision_strategy: ConcurrencyLimitStrategy;
};

/**
 * Represents constant input value to a task run.
 */
export type Constant = {
    input_type?: "constant";
    type: string;
};

export type CountByState = {
    COMPLETED?: number;
    PENDING?: number;
    RUNNING?: number;
    FAILED?: number;
    CANCELLED?: number;
    CRASHED?: number;
    PAUSED?: number;
    CANCELLING?: number;
    SCHEDULED?: number;
};

export type Countable = 'day' | 'time' | 'event' | 'resource';

export type CreatedBy = {
    /**
     * The id of the creator of the object.
     */
    id?: string | null;
    /**
     * The type of the creator of the object.
     */
    type?: string | null;
    /**
     * The display value for the creator.
     */
    display_value?: string | null;
};

/**
 * Cron schedule
 *
 * NOTE: If the timezone is a DST-observing one, then the schedule will adjust
 * itself appropriately. Cron's rules for DST are based on schedule times, not
 * intervals. This means that an hourly cron schedule will fire on every new
 * schedule hour, not every elapsed hour; for example, when clocks are set back
 * this will result in a two-hour pause as the schedule will fire *the first
 * time* 1am is reached and *the first time* 2am is reached, 120 minutes later.
 * Longer schedules, such as one that fires at 9am every morning, will
 * automatically adjust for DST.
 *
 * Args:
 * cron (str): a valid cron string
 * timezone (str): a valid timezone string in IANA tzdata format (for example,
 * America/New_York).
 * day_or (bool, optional): Control how croniter handles `day` and `day_of_week`
 * entries. Defaults to True, matching cron which connects those values using
 * OR. If the switch is set to False, the values are connected using AND. This
 * behaves like fcron and enables you to e.g. define a job that executes each
 * 2nd friday of a month by setting the days of month and the weekday.
 */
export type CronSchedule = {
    cron: string;
    timezone?: string | null;
    /**
     * Control croniter behavior for handling day and day_of_week entries.
     */
    day_or?: boolean;
};

export type CsrfToken = {
    id: string;
    created: string | null;
    updated: string | null;
    /**
     * The CSRF token
     */
    token: string;
    /**
     * The client id associated with the CSRF token
     */
    client: string;
    /**
     * The expiration time of the CSRF token
     */
    expiration: string;
};

export type DependencyResult = {
    id: string;
    name: string;
    upstream_dependencies: Array<TaskRunResult>;
    state: State | null;
    expected_start_time: string | null;
    start_time: string | null;
    end_time: string | null;
    total_run_time: number | null;
    estimated_run_time: number | null;
    untrackable_result: boolean;
};

/**
 * Data used by the Prefect REST API to create a deployment.
 */
export type DeploymentCreate = {
    /**
     * The name of the deployment.
     */
    name: string;
    /**
     * The ID of the flow associated with the deployment.
     */
    flow_id: string;
    /**
     * Whether or not the deployment is paused.
     */
    paused?: boolean;
    /**
     * A list of schedules for the deployment.
     */
    schedules?: Array<DeploymentScheduleCreate>;
    /**
     * The deployment's concurrency limit.
     */
    concurrency_limit?: number | null;
    /**
     * The deployment's concurrency options.
     */
    concurrency_options?: ConcurrencyOptions | null;
    /**
     * Whether or not the deployment should enforce the parameter schema.
     */
    enforce_parameter_schema?: boolean;
    /**
     * The parameter schema of the flow, including defaults.
     */
    parameter_openapi_schema?: {
    [key: string]: unknown;
} | null;
    /**
     * Parameters for flow runs scheduled by the deployment.
     */
    parameters?: {
        [key: string]: unknown;
    };
    /**
     * A list of deployment tags.
     */
    tags?: Array<(string)>;
    /**
     * A dictionary of key-value labels. Values can be strings, numbers, or booleans.
     */
    labels?: {
    [key: string]: (boolean | number | string);
} | null;
    pull_steps?: Array<{
    [key: string]: unknown;
}> | null;
    work_queue_name?: string | null;
    /**
     * The name of the deployment's work pool.
     */
    work_pool_name?: string | null;
    storage_document_id?: string | null;
    infrastructure_document_id?: string | null;
    description?: string | null;
    path?: string | null;
    version?: string | null;
    entrypoint?: string | null;
    /**
     * Overrides for the flow's infrastructure configuration.
     */
    job_variables?: {
        [key: string]: unknown;
    };
};

/**
 * Filter for deployments. Only deployments matching all criteria will be returned.
 */
export type DeploymentFilter = {
    /**
     * Operator for combining filter criteria. Defaults to 'and_'.
     */
    operator?: Operator;
    /**
     * Filter criteria for `Deployment.id`
     */
    id?: DeploymentFilterId | null;
    /**
     * Filter criteria for `Deployment.name`
     */
    name?: DeploymentFilterName | null;
    /**
     * Filter criteria for `Deployment.name` or `Flow.name`
     */
    flow_or_deployment_name?: DeploymentOrFlowNameFilter | null;
    /**
     * Filter criteria for `Deployment.paused`
     */
    paused?: DeploymentFilterPaused | null;
    /**
     * Filter criteria for `Deployment.tags`
     */
    tags?: DeploymentFilterTags | null;
    /**
     * Filter criteria for `Deployment.work_queue_name`
     */
    work_queue_name?: DeploymentFilterWorkQueueName | null;
    /**
     * DEPRECATED: Prefer `Deployment.concurrency_limit_id` over `Deployment.concurrency_limit`. If provided, will be ignored for backwards-compatibility. Will be removed after December 2024.
     * @deprecated
     */
    concurrency_limit?: DeploymentFilterConcurrencyLimit | null;
};

/**
 * DEPRECATED: Prefer `Deployment.concurrency_limit_id` over `Deployment.concurrency_limit`.
 */
export type DeploymentFilterConcurrencyLimit = {
    /**
     * Only include deployments with a concurrency limit greater than or equal to this value
     */
    ge_?: number | null;
    /**
     * Only include deployments with a concurrency limit less than or equal to this value
     */
    le_?: number | null;
    /**
     * If true, only include deployments without a concurrency limit
     */
    is_null_?: boolean | null;
};

/**
 * Filter by `Deployment.id`.
 */
export type DeploymentFilterId = {
    /**
     * A list of deployment ids to include
     */
    any_?: Array<(string)> | null;
};

/**
 * Filter by `Deployment.name`.
 */
export type DeploymentFilterName = {
    /**
     * A list of deployment names to include
     */
    any_?: Array<(string)> | null;
    /**
     * A case-insensitive partial match. For example,  passing 'marvin' will match 'marvin', 'sad-Marvin', and 'marvin-robot'.
     */
    like_?: string | null;
};

/**
 * Filter by `Deployment.paused`.
 */
export type DeploymentFilterPaused = {
    /**
     * Only returns where deployment is/is not paused
     */
    eq_?: boolean | null;
};

/**
 * Filter by `Deployment.tags`.
 */
export type DeploymentFilterTags = {
    /**
     * Operator for combining filter criteria. Defaults to 'and_'.
     */
    operator?: Operator;
    /**
     * A list of tags. Deployments will be returned only if their tags are a superset of the list
     */
    all_?: Array<(string)> | null;
    /**
     * A list of tags to include
     */
    any_?: Array<(string)> | null;
    /**
     * If true, only include deployments without tags
     */
    is_null_?: boolean | null;
};

/**
 * Filter by `Deployment.work_queue_name`.
 */
export type DeploymentFilterWorkQueueName = {
    /**
     * A list of work queue names to include
     */
    any_?: Array<(string)> | null;
};

/**
 * Data used by the Prefect REST API to create a flow run from a deployment.
 */
export type DeploymentFlowRunCreate = {
    /**
     * The state of the flow run to create
     */
    state?: StateCreate | null;
    /**
     * The name of the flow run. Defaults to a random slug if not specified.
     */
    name?: string;
    parameters?: {
        [key: string]: unknown;
    };
    /**
     * Whether or not to enforce the parameter schema on this run.
     */
    enforce_parameter_schema?: boolean | null;
    context?: {
        [key: string]: unknown;
    };
    infrastructure_document_id?: string | null;
    /**
     * The empirical policy for the flow run.
     */
    empirical_policy?: FlowRunPolicy;
    /**
     * A list of tags for the flow run.
     */
    tags?: Array<(string)>;
    /**
     * An optional idempotency key. If a flow run with the same idempotency key has already been created, the existing flow run will be returned.
     */
    idempotency_key?: string | null;
    /**
     * A dictionary of key-value labels. Values can be strings, numbers, or booleans.
     */
    labels?: {
    [key: string]: (boolean | number | string);
} | null;
    parent_task_run_id?: string | null;
    work_queue_name?: string | null;
    job_variables?: {
    [key: string]: unknown;
} | null;
};

/**
 * Filter by `Deployment.name` or `Flow.name` with a single input string for ilike filtering.
 */
export type DeploymentOrFlowNameFilter = {
    /**
     * A case-insensitive partial match on deployment or flow names. For example, passing 'example' might match deployments or flows with 'example' in their names.
     */
    like_?: string | null;
};

export type DeploymentPaginationResponse = {
    results: Array<DeploymentResponse>;
    count: number;
    limit: number;
    pages: number;
    page: number;
};

export type DeploymentResponse = {
    id: string;
    created: string | null;
    updated: string | null;
    /**
     * The name of the deployment.
     */
    name: string;
    /**
     * An optional version for the deployment.
     */
    version?: string | null;
    /**
     * A description for the deployment.
     */
    description?: string | null;
    /**
     * The flow id associated with the deployment.
     */
    flow_id: string;
    /**
     * Whether or not the deployment is paused.
     */
    paused?: boolean;
    /**
     * A list of schedules for the deployment.
     */
    schedules?: Array<DeploymentSchedule>;
    /**
     * DEPRECATED: Prefer `global_concurrency_limit`. Will always be None for backwards compatibility. Will be removed after December 2024.
     * @deprecated
     */
    concurrency_limit?: number | null;
    /**
     * The global concurrency limit object for enforcing the maximum number of flow runs that can be active at once.
     */
    global_concurrency_limit?: GlobalConcurrencyLimitResponse | null;
    /**
     * The concurrency options for the deployment.
     */
    concurrency_options?: ConcurrencyOptions | null;
    /**
     * Overrides to apply to the base infrastructure block at runtime.
     */
    job_variables?: {
        [key: string]: unknown;
    };
    /**
     * Parameters for flow runs scheduled by the deployment.
     */
    parameters?: {
        [key: string]: unknown;
    };
    /**
     * A list of tags for the deployment
     */
    tags?: Array<(string)>;
    /**
     * A dictionary of key-value labels. Values can be strings, numbers, or booleans.
     */
    labels?: {
        [key: string]: (boolean | number | string);
    };
    /**
     * The work queue for the deployment. If no work queue is set, work will not be scheduled.
     */
    work_queue_name?: string | null;
    /**
     * The last time the deployment was polled for status updates.
     */
    last_polled?: string | null;
    /**
     * The parameter schema of the flow, including defaults.
     */
    parameter_openapi_schema?: {
    [key: string]: unknown;
} | null;
    /**
     * The path to the working directory for the workflow, relative to remote storage or an absolute path.
     */
    path?: string | null;
    /**
     * Pull steps for cloning and running this deployment.
     */
    pull_steps?: Array<{
    [key: string]: unknown;
}> | null;
    /**
     * The path to the entrypoint for the workflow, relative to the `path`.
     */
    entrypoint?: string | null;
    /**
     * The block document defining storage used for this flow.
     */
    storage_document_id?: string | null;
    /**
     * The block document defining infrastructure to use for flow runs.
     */
    infrastructure_document_id?: string | null;
    /**
     * Optional information about the creator of this deployment.
     */
    created_by?: CreatedBy | null;
    /**
     * Optional information about the updater of this deployment.
     */
    updated_by?: UpdatedBy | null;
    /**
     * The name of the deployment's work pool.
     */
    work_pool_name?: string | null;
    /**
     * Whether the deployment is ready to run flows.
     */
    status?: DeploymentStatus | null;
    /**
     * Whether or not the deployment should enforce the parameter schema.
     */
    enforce_parameter_schema?: boolean;
};

export type DeploymentSchedule = {
    id: string;
    created: string | null;
    updated: string | null;
    /**
     * The deployment id associated with this schedule.
     */
    deployment_id?: string | null;
    /**
     * The schedule for the deployment.
     */
    schedule: IntervalSchedule | CronSchedule | RRuleSchedule;
    /**
     * Whether or not the schedule is active.
     */
    active?: boolean;
    /**
     * The maximum number of scheduled runs for the schedule.
     */
    max_scheduled_runs?: number | null;
};

export type DeploymentScheduleCreate = {
    /**
     * Whether or not the schedule is active.
     */
    active?: boolean;
    /**
     * The schedule for the deployment.
     */
    schedule: IntervalSchedule | CronSchedule | RRuleSchedule;
    /**
     * The maximum number of scheduled runs for the schedule.
     */
    max_scheduled_runs?: number | null;
};

export type DeploymentScheduleUpdate = {
    /**
     * Whether or not the schedule is active.
     */
    active?: boolean | null;
    /**
     * The schedule for the deployment.
     */
    schedule?: IntervalSchedule | CronSchedule | RRuleSchedule | null;
    /**
     * The maximum number of scheduled runs for the schedule.
     */
    max_scheduled_runs?: number | null;
};

/**
 * Defines deployment sorting options.
 */
export type DeploymentSort = 'CREATED_DESC' | 'UPDATED_DESC' | 'NAME_ASC' | 'NAME_DESC';

/**
 * Enumeration of deployment statuses.
 */
export type DeploymentStatus = 'READY' | 'NOT_READY';

/**
 * Data used by the Prefect REST API to update a deployment.
 */
export type DeploymentUpdate = {
    version?: string | null;
    description?: string | null;
    /**
     * Whether or not the deployment is paused.
     */
    paused?: boolean;
    /**
     * A list of schedules for the deployment.
     */
    schedules?: Array<DeploymentScheduleCreate>;
    /**
     * The deployment's concurrency limit.
     */
    concurrency_limit?: number | null;
    /**
     * The deployment's concurrency options.
     */
    concurrency_options?: ConcurrencyOptions | null;
    /**
     * Parameters for flow runs scheduled by the deployment.
     */
    parameters?: {
    [key: string]: unknown;
} | null;
    /**
     * A list of deployment tags.
     */
    tags?: Array<(string)>;
    work_queue_name?: string | null;
    /**
     * The name of the deployment's work pool.
     */
    work_pool_name?: string | null;
    path?: string | null;
    /**
     * Overrides for the flow's infrastructure configuration.
     */
    job_variables?: {
    [key: string]: unknown;
} | null;
    entrypoint?: string | null;
    storage_document_id?: string | null;
    infrastructure_document_id?: string | null;
    /**
     * Whether or not the deployment should enforce the parameter schema.
     */
    enforce_parameter_schema?: boolean | null;
};

/**
 * Do nothing when an Automation is triggered
 */
export type DoNothing = {
    type?: "do-nothing";
};

export type Edge = {
    id: string;
};

/**
 * The client-side view of an event that has happened to a Resource
 */
export type Event = {
    /**
     * When the event happened from the sender's perspective
     */
    occurred: string;
    /**
     * The name of the event that happened
     */
    event: string;
    /**
     * The primary Resource this event concerns
     */
    resource: Resource;
    /**
     * A list of additional Resources involved in this event
     */
    related?: Array<RelatedResource>;
    /**
     * An open-ended set of data describing what happened
     */
    payload?: {
        [key: string]: unknown;
    };
    /**
     * The client-provided identifier of this event
     */
    id: string;
    /**
     * The ID of an event that is known to have occurred prior to this one. If set, this may be used to establish a more precise ordering of causally-related events when they occur close enough together in time that the system may receive them out-of-order.
     */
    follows?: string | null;
};

export type EventAnyResourceFilter = {
    /**
     * Only include events for resources with these IDs
     */
    id?: Array<(string)> | null;
    /**
     * Only include events for resources with IDs starting with these prefixes
     */
    id_prefix?: Array<(string)> | null;
    /**
     * Only include events for related resources with these labels
     */
    labels?: ResourceSpecification | null;
};

/**
 * The count of events with the given filter value
 */
export type EventCount = {
    /**
     * The value to use for filtering
     */
    value: string;
    /**
     * The value to display for this count
     */
    label: string;
    /**
     * The count of matching events
     */
    count: number;
    /**
     * The start time of this group of events
     */
    start_time: string;
    /**
     * The end time of this group of events
     */
    end_time: string;
};

export type EventFilter = {
    /**
     * Filter criteria for when the events occurred
     */
    occurred?: EventOccurredFilter;
    /**
     * Filter criteria for the event name
     */
    event?: EventNameFilter | null;
    /**
     * Filter criteria for any resource involved in the event
     */
    any_resource?: EventAnyResourceFilter | null;
    /**
     * Filter criteria for the resource of the event
     */
    resource?: EventResourceFilter | null;
    /**
     * Filter criteria for the related resources of the event
     */
    related?: EventRelatedFilter | null;
    /**
     * Filter criteria for the events' ID
     */
    id?: EventIDFilter;
    /**
     * The order to return filtered events
     */
    order?: EventOrder;
};

export type EventIDFilter = {
    /**
     * Only include events with one of these IDs
     */
    id?: Array<(string)> | null;
};

export type EventNameFilter = {
    /**
     * Only include events matching one of these prefixes
     */
    prefix?: Array<(string)> | null;
    /**
     * Exclude events matching one of these prefixes
     */
    exclude_prefix?: Array<(string)> | null;
    /**
     * Only include events matching one of these names exactly
     */
    name?: Array<(string)> | null;
    /**
     * Exclude events matching one of these names exactly
     */
    exclude_name?: Array<(string)> | null;
};

export type EventOccurredFilter = {
    /**
     * Only include events after this time (inclusive)
     */
    since?: string;
    /**
     * Only include events prior to this time (inclusive)
     */
    until?: string;
};

export type EventOrder = 'ASC' | 'DESC';

/**
 * A single page of events returned from the API, with an optional link to the
 * next page of results
 */
export type EventPage = {
    /**
     * The Events matching the query
     */
    events: Array<ReceivedEvent>;
    /**
     * The total number of matching Events
     */
    total: number;
    /**
     * The URL for the next page of results, if there are more
     */
    next_page: string | null;
};

export type EventRelatedFilter = {
    /**
     * Only include events for related resources with these IDs
     */
    id?: Array<(string)> | null;
    /**
     * Only include events for related resources in these roles
     */
    role?: Array<(string)> | null;
    /**
     * Only include events with specific related resources in specific roles
     */
    resources_in_roles?: Array<[
    string,
    string
]> | null;
    /**
     * Only include events for related resources with these labels
     */
    labels?: ResourceSpecification | null;
};

export type EventResourceFilter = {
    /**
     * Only include events for resources with these IDs
     */
    id?: Array<(string)> | null;
    /**
     * Only include events for resources with IDs starting with these prefixes.
     */
    id_prefix?: Array<(string)> | null;
    /**
     * Only include events for resources with these labels
     */
    labels?: ResourceSpecification | null;
    /**
     * Only include events for distinct resources
     */
    distinct?: boolean;
};

/**
 * A trigger that fires based on the presence or absence of events within a given
 * period of time.
 */
export type EventTrigger = {
    type?: "event";
    /**
     * The unique ID of this trigger
     */
    id?: string;
    /**
     * Labels for resources which this trigger will match.
     */
    match?: ResourceSpecification;
    /**
     * Labels for related resources which this trigger will match.
     */
    match_related?: ResourceSpecification;
    /**
     * The event(s) which must first been seen to fire this trigger.  If empty, then fire this trigger immediately.  Events may include trailing wildcards, like `prefect.flow-run.*`
     */
    after?: Array<(string)>;
    /**
     * The event(s) this trigger is expecting to see.  If empty, this trigger will match any event.  Events may include trailing wildcards, like `prefect.flow-run.*`
     */
    expect?: Array<(string)>;
    /**
     * Evaluate the trigger separately for each distinct value of these labels on the resource.  By default, labels refer to the primary resource of the triggering event.  You may also refer to labels from related resources by specifying `related:<role>:<label>`.  This will use the value of that label for the first related resource in that role.  For example, `"for_each": ["related:flow:prefect.resource.id"]` would evaluate the trigger for each flow.
     */
    for_each?: Array<(string)>;
    /**
     * The posture of this trigger, either Reactive or Proactive.  Reactive triggers respond to the _presence_ of the expected events, while Proactive triggers respond to the _absence_ of those expected events.
     */
    posture: 'Reactive' | 'Proactive';
    /**
     * The number of events required for this trigger to fire (for Reactive triggers), or the number of events expected (for Proactive triggers)
     */
    threshold?: number;
    /**
     * The time period over which the events must occur.  For Reactive triggers, this may be as low as 0 seconds, but must be at least 10 seconds for Proactive triggers
     */
    within?: number;
};

/**
 * The posture of this trigger, either Reactive or Proactive.  Reactive triggers respond to the _presence_ of the expected events, while Proactive triggers respond to the _absence_ of those expected events.
 */
export type posture = 'Reactive' | 'Proactive';

/**
 * An ORM representation of flow data.
 */
export type Flow = {
    id: string;
    created: string | null;
    updated: string | null;
    /**
     * The name of the flow
     */
    name: string;
    /**
     * A list of flow tags
     */
    tags?: Array<(string)>;
    /**
     * A dictionary of key-value labels. Values can be strings, numbers, or booleans.
     */
    labels?: {
    [key: string]: (boolean | number | string);
} | null;
};

/**
 * Data used by the Prefect REST API to create a flow.
 */
export type FlowCreate = {
    /**
     * The name of the flow
     */
    name: string;
    /**
     * A list of flow tags
     */
    tags?: Array<(string)>;
    /**
     * A dictionary of key-value labels. Values can be strings, numbers, or booleans.
     */
    labels?: {
    [key: string]: (boolean | number | string);
} | null;
};

/**
 * Filter for flows. Only flows matching all criteria will be returned.
 */
export type FlowFilter = {
    /**
     * Operator for combining filter criteria. Defaults to 'and_'.
     */
    operator?: Operator;
    /**
     * Filter criteria for `Flow.id`
     */
    id?: FlowFilterId | null;
    /**
     * Filter criteria for Flow deployments
     */
    deployment?: FlowFilterDeployment | null;
    /**
     * Filter criteria for `Flow.name`
     */
    name?: FlowFilterName | null;
    /**
     * Filter criteria for `Flow.tags`
     */
    tags?: FlowFilterTags | null;
};

/**
 * Filter by flows by deployment
 */
export type FlowFilterDeployment = {
    /**
     * Operator for combining filter criteria. Defaults to 'and_'.
     */
    operator?: Operator;
    /**
     * If true, only include flows without deployments
     */
    is_null_?: boolean | null;
};

/**
 * Filter by `Flow.id`.
 */
export type FlowFilterId = {
    /**
     * A list of flow ids to include
     */
    any_?: Array<(string)> | null;
};

/**
 * Filter by `Flow.name`.
 */
export type FlowFilterName = {
    /**
     * A list of flow names to include
     */
    any_?: Array<(string)> | null;
    /**
     * A case-insensitive partial match. For example,  passing 'marvin' will match 'marvin', 'sad-Marvin', and 'marvin-robot'.
     */
    like_?: string | null;
};

/**
 * Filter by `Flow.tags`.
 */
export type FlowFilterTags = {
    /**
     * Operator for combining filter criteria. Defaults to 'and_'.
     */
    operator?: Operator;
    /**
     * A list of tags. Flows will be returned only if their tags are a superset of the list
     */
    all_?: Array<(string)> | null;
    /**
     * If true, only include flows without tags
     */
    is_null_?: boolean | null;
};

export type FlowPaginationResponse = {
    results: Array<Flow>;
    count: number;
    limit: number;
    pages: number;
    page: number;
};

/**
 * An ORM representation of flow run data.
 */
export type FlowRun = {
    id: string;
    created: string | null;
    updated: string | null;
    /**
     * The name of the flow run. Defaults to a random slug if not specified.
     */
    name?: string;
    /**
     * The id of the flow being run.
     */
    flow_id: string;
    /**
     * The id of the flow run's current state.
     */
    state_id?: string | null;
    /**
     * The id of the deployment associated with this flow run, if available.
     */
    deployment_id?: string | null;
    /**
     * The version of the deployment associated with this flow run.
     */
    deployment_version?: string | null;
    /**
     * The work queue that handled this flow run.
     */
    work_queue_name?: string | null;
    /**
     * The version of the flow executed in this flow run.
     */
    flow_version?: string | null;
    /**
     * Parameters for the flow run.
     */
    parameters?: {
        [key: string]: unknown;
    };
    /**
     * An optional idempotency key for the flow run. Used to ensure the same flow run is not created multiple times.
     */
    idempotency_key?: string | null;
    /**
     * Additional context for the flow run.
     */
    context?: {
        [key: string]: unknown;
    };
    empirical_policy?: FlowRunPolicy;
    /**
     * A list of tags on the flow run
     */
    tags?: Array<(string)>;
    /**
     * A dictionary of key-value labels. Values can be strings, numbers, or booleans.
     */
    labels?: {
    [key: string]: (boolean | number | string);
} | null;
    /**
     * If the flow run is a subflow, the id of the 'dummy' task in the parent flow used to track subflow state.
     */
    parent_task_run_id?: string | null;
    /**
     * The type of the current flow run state.
     */
    state_type?: StateType | null;
    /**
     * The name of the current flow run state.
     */
    state_name?: string | null;
    /**
     * The number of times the flow run was executed.
     */
    run_count?: number;
    /**
     * The flow run's expected start time.
     */
    expected_start_time?: string | null;
    /**
     * The next time the flow run is scheduled to start.
     */
    next_scheduled_start_time?: string | null;
    /**
     * The actual start time.
     */
    start_time?: string | null;
    /**
     * The actual end time.
     */
    end_time?: string | null;
    /**
     * Total run time. If the flow run was executed multiple times, the time of each run will be summed.
     */
    total_run_time?: number;
    /**
     * A real-time estimate of the total run time.
     */
    estimated_run_time?: number;
    /**
     * The difference between actual and expected start time.
     */
    estimated_start_time_delta?: number;
    /**
     * Whether or not the flow run was automatically scheduled.
     */
    auto_scheduled?: boolean;
    /**
     * The block document defining infrastructure to use this flow run.
     */
    infrastructure_document_id?: string | null;
    /**
     * The id of the flow run as returned by an infrastructure block.
     */
    infrastructure_pid?: string | null;
    /**
     * Optional information about the creator of this flow run.
     */
    created_by?: CreatedBy | null;
    /**
     * The id of the run's work pool queue.
     */
    work_queue_id?: string | null;
    /**
     * The current state of the flow run.
     */
    state?: State | null;
    /**
     * Variables used as overrides in the base job template
     */
    job_variables?: {
    [key: string]: unknown;
} | null;
};

/**
 * Data used by the Prefect REST API to create a flow run.
 */
export type FlowRunCreate = {
    /**
     * The state of the flow run to create
     */
    state?: StateCreate | null;
    /**
     * The name of the flow run. Defaults to a random slug if not specified.
     */
    name?: string;
    /**
     * The id of the flow being run.
     */
    flow_id: string;
    /**
     * The version of the flow being run.
     */
    flow_version?: string | null;
    parameters?: {
        [key: string]: unknown;
    };
    /**
     * The context of the flow run.
     */
    context?: {
        [key: string]: unknown;
    };
    parent_task_run_id?: string | null;
    infrastructure_document_id?: string | null;
    /**
     * The empirical policy for the flow run.
     */
    empirical_policy?: FlowRunPolicy;
    /**
     * A list of tags for the flow run.
     */
    tags?: Array<(string)>;
    /**
     * A dictionary of key-value labels. Values can be strings, numbers, or booleans.
     */
    labels?: {
    [key: string]: (boolean | number | string);
} | null;
    /**
     * An optional idempotency key. If a flow run with the same idempotency key has already been created, the existing flow run will be returned.
     */
    idempotency_key?: string | null;
    /**
     * DEPRECATED: The id of the deployment associated with this flow run, if available.
     * @deprecated
     */
    deployment_id?: string | null;
};

/**
 * Filter flow runs. Only flow runs matching all criteria will be returned
 */
export type FlowRunFilter = {
    /**
     * Operator for combining filter criteria. Defaults to 'and_'.
     */
    operator?: Operator;
    /**
     * Filter criteria for `FlowRun.id`
     */
    id?: FlowRunFilterId | null;
    /**
     * Filter criteria for `FlowRun.name`
     */
    name?: FlowRunFilterName | null;
    /**
     * Filter criteria for `FlowRun.tags`
     */
    tags?: FlowRunFilterTags | null;
    /**
     * Filter criteria for `FlowRun.deployment_id`
     */
    deployment_id?: FlowRunFilterDeploymentId | null;
    /**
     * Filter criteria for `FlowRun.work_queue_name
     */
    work_queue_name?: FlowRunFilterWorkQueueName | null;
    /**
     * Filter criteria for `FlowRun.state`
     */
    state?: FlowRunFilterState | null;
    /**
     * Filter criteria for `FlowRun.flow_version`
     */
    flow_version?: FlowRunFilterFlowVersion | null;
    /**
     * Filter criteria for `FlowRun.start_time`
     */
    start_time?: FlowRunFilterStartTime | null;
    /**
     * Filter criteria for `FlowRun.end_time`
     */
    end_time?: FlowRunFilterEndTime | null;
    /**
     * Filter criteria for `FlowRun.expected_start_time`
     */
    expected_start_time?: FlowRunFilterExpectedStartTime | null;
    /**
     * Filter criteria for `FlowRun.next_scheduled_start_time`
     */
    next_scheduled_start_time?: FlowRunFilterNextScheduledStartTime | null;
    /**
     * Filter criteria for subflows of the given flow runs
     */
    parent_flow_run_id?: FlowRunFilterParentFlowRunId | null;
    /**
     * Filter criteria for `FlowRun.parent_task_run_id`
     */
    parent_task_run_id?: FlowRunFilterParentTaskRunId | null;
    /**
     * Filter criteria for `FlowRun.idempotency_key`
     */
    idempotency_key?: FlowRunFilterIdempotencyKey | null;
};

/**
 * Filter by `FlowRun.deployment_id`.
 */
export type FlowRunFilterDeploymentId = {
    /**
     * Operator for combining filter criteria. Defaults to 'and_'.
     */
    operator?: Operator;
    /**
     * A list of flow run deployment ids to include
     */
    any_?: Array<(string)> | null;
    /**
     * If true, only include flow runs without deployment ids
     */
    is_null_?: boolean | null;
};

/**
 * Filter by `FlowRun.end_time`.
 */
export type FlowRunFilterEndTime = {
    /**
     * Only include flow runs ending at or before this time
     */
    before_?: string | null;
    /**
     * Only include flow runs ending at or after this time
     */
    after_?: string | null;
    /**
     * If true, only return flow runs without an end time
     */
    is_null_?: boolean | null;
};

/**
 * Filter by `FlowRun.expected_start_time`.
 */
export type FlowRunFilterExpectedStartTime = {
    /**
     * Only include flow runs scheduled to start at or before this time
     */
    before_?: string | null;
    /**
     * Only include flow runs scheduled to start at or after this time
     */
    after_?: string | null;
};

/**
 * Filter by `FlowRun.flow_version`.
 */
export type FlowRunFilterFlowVersion = {
    /**
     * A list of flow run flow_versions to include
     */
    any_?: Array<(string)> | null;
};

/**
 * Filter by `FlowRun.id`.
 */
export type FlowRunFilterId = {
    /**
     * A list of flow run ids to include
     */
    any_?: Array<(string)> | null;
    /**
     * A list of flow run ids to exclude
     */
    not_any_?: Array<(string)> | null;
};

/**
 * Filter by FlowRun.idempotency_key.
 */
export type FlowRunFilterIdempotencyKey = {
    /**
     * A list of flow run idempotency keys to include
     */
    any_?: Array<(string)> | null;
    /**
     * A list of flow run idempotency keys to exclude
     */
    not_any_?: Array<(string)> | null;
};

/**
 * Filter by `FlowRun.name`.
 */
export type FlowRunFilterName = {
    /**
     * A list of flow run names to include
     */
    any_?: Array<(string)> | null;
    /**
     * A case-insensitive partial match. For example,  passing 'marvin' will match 'marvin', 'sad-Marvin', and 'marvin-robot'.
     */
    like_?: string | null;
};

/**
 * Filter by `FlowRun.next_scheduled_start_time`.
 */
export type FlowRunFilterNextScheduledStartTime = {
    /**
     * Only include flow runs with a next_scheduled_start_time or before this time
     */
    before_?: string | null;
    /**
     * Only include flow runs with a next_scheduled_start_time at or after this time
     */
    after_?: string | null;
};

/**
 * Filter for subflows of a given flow run
 */
export type FlowRunFilterParentFlowRunId = {
    /**
     * Operator for combining filter criteria. Defaults to 'and_'.
     */
    operator?: Operator;
    /**
     * A list of parent flow run ids to include
     */
    any_?: Array<(string)> | null;
};

/**
 * Filter by `FlowRun.parent_task_run_id`.
 */
export type FlowRunFilterParentTaskRunId = {
    /**
     * Operator for combining filter criteria. Defaults to 'and_'.
     */
    operator?: Operator;
    /**
     * A list of flow run parent_task_run_ids to include
     */
    any_?: Array<(string)> | null;
    /**
     * If true, only include flow runs without parent_task_run_id
     */
    is_null_?: boolean | null;
};

/**
 * Filter by `FlowRun.start_time`.
 */
export type FlowRunFilterStartTime = {
    /**
     * Only include flow runs starting at or before this time
     */
    before_?: string | null;
    /**
     * Only include flow runs starting at or after this time
     */
    after_?: string | null;
    /**
     * If true, only return flow runs without a start time
     */
    is_null_?: boolean | null;
};

/**
 * Filter by `FlowRun.state_type` and `FlowRun.state_name`.
 */
export type FlowRunFilterState = {
    /**
     * Operator for combining filter criteria. Defaults to 'and_'.
     */
    operator?: Operator;
    /**
     * Filter criteria for `FlowRun.state_type`
     */
    type?: FlowRunFilterStateType | null;
    /**
     * Filter criteria for `FlowRun.state_name`
     */
    name?: FlowRunFilterStateName | null;
};

/**
 * Filter by `FlowRun.state_name`.
 */
export type FlowRunFilterStateName = {
    /**
     * A list of flow run state names to include
     */
    any_?: Array<(string)> | null;
    /**
     * A list of flow run state names to exclude
     */
    not_any_?: Array<(string)> | null;
};

/**
 * Filter by `FlowRun.state_type`.
 */
export type FlowRunFilterStateType = {
    /**
     * A list of flow run state types to include
     */
    any_?: Array<StateType> | null;
    /**
     * A list of flow run state types to exclude
     */
    not_any_?: Array<StateType> | null;
};

/**
 * Filter by `FlowRun.tags`.
 */
export type FlowRunFilterTags = {
    /**
     * Operator for combining filter criteria. Defaults to 'and_'.
     */
    operator?: Operator;
    /**
     * A list of tags. Flow runs will be returned only if their tags are a superset of the list
     */
    all_?: Array<(string)> | null;
    /**
     * A list of tags to include
     */
    any_?: Array<(string)> | null;
    /**
     * If true, only include flow runs without tags
     */
    is_null_?: boolean | null;
};

/**
 * Filter by `FlowRun.work_queue_name`.
 */
export type FlowRunFilterWorkQueueName = {
    /**
     * Operator for combining filter criteria. Defaults to 'and_'.
     */
    operator?: Operator;
    /**
     * A list of work queue names to include
     */
    any_?: Array<(string)> | null;
    /**
     * If true, only include flow runs without work queue names
     */
    is_null_?: boolean | null;
};

export type FlowRunInput = {
    id: string;
    created: string | null;
    updated: string | null;
    /**
     * The flow run ID associated with the input.
     */
    flow_run_id: string;
    /**
     * The key of the input.
     */
    key: string;
    /**
     * The value of the input.
     */
    value: string;
    /**
     * The sender of the input.
     */
    sender?: string | null;
};

/**
 * An ORM representation of a flow run notification.
 */
export type FlowRunNotificationPolicy = {
    id: string;
    created: string | null;
    updated: string | null;
    /**
     * Whether the policy is currently active
     */
    is_active?: boolean;
    /**
     * The flow run states that trigger notifications
     */
    state_names: Array<(string)>;
    /**
     * The flow run tags that trigger notifications (set [] to disable)
     */
    tags: Array<(string)>;
    /**
     * The block document ID used for sending notifications
     */
    block_document_id: string;
    /**
     * A templatable notification message. Use {braces} to add variables. Valid variables include: 'flow_id', 'flow_name', 'flow_run_id', 'flow_run_name', 'flow_run_notification_policy_id', 'flow_run_parameters', 'flow_run_state_message', 'flow_run_state_name', 'flow_run_state_timestamp', 'flow_run_state_type', 'flow_run_url'
     */
    message_template?: string | null;
};

/**
 * Data used by the Prefect REST API to create a flow run notification policy.
 */
export type FlowRunNotificationPolicyCreate = {
    /**
     * Whether the policy is currently active
     */
    is_active?: boolean;
    /**
     * The flow run states that trigger notifications
     */
    state_names: Array<(string)>;
    /**
     * The flow run tags that trigger notifications (set [] to disable)
     */
    tags: Array<(string)>;
    /**
     * The block document ID used for sending notifications
     */
    block_document_id: string;
    /**
     * A templatable notification message. Use {braces} to add variables. Valid variables include: 'flow_id', 'flow_name', 'flow_run_id', 'flow_run_name', 'flow_run_notification_policy_id', 'flow_run_parameters', 'flow_run_state_message', 'flow_run_state_name', 'flow_run_state_timestamp', 'flow_run_state_type', 'flow_run_url'
     */
    message_template?: string | null;
};

/**
 * Filter FlowRunNotificationPolicies.
 */
export type FlowRunNotificationPolicyFilter = {
    /**
     * Filter criteria for `FlowRunNotificationPolicy.is_active`.
     */
    is_active?: FlowRunNotificationPolicyFilterIsActive | null;
};

/**
 * Filter by `FlowRunNotificationPolicy.is_active`.
 */
export type FlowRunNotificationPolicyFilterIsActive = {
    /**
     * Filter notification policies for only those that are or are not active.
     */
    eq_?: boolean | null;
};

/**
 * Data used by the Prefect REST API to update a flow run notification policy.
 */
export type FlowRunNotificationPolicyUpdate = {
    is_active?: boolean | null;
    state_names?: Array<(string)> | null;
    tags?: Array<(string)> | null;
    block_document_id?: string | null;
    message_template?: string | null;
};

export type FlowRunPaginationResponse = {
    results: Array<FlowRunResponse>;
    count: number;
    limit: number;
    pages: number;
    page: number;
};

/**
 * Defines of how a flow run should retry.
 */
export type FlowRunPolicy = {
    /**
     * The maximum number of retries. Field is not used. Please use `retries` instead.
     * @deprecated
     */
    max_retries?: number;
    /**
     * The delay between retries. Field is not used. Please use `retry_delay` instead.
     * @deprecated
     */
    retry_delay_seconds?: number;
    /**
     * The number of retries.
     */
    retries?: number | null;
    /**
     * The delay time between retries, in seconds.
     */
    retry_delay?: number | null;
    /**
     * Tracks pauses this run has observed.
     */
    pause_keys?: Array<(string)> | null;
    /**
     * Indicates if this run is resuming from a pause.
     */
    resuming?: boolean | null;
    /**
     * The type of retry this run is undergoing.
     */
    retry_type?: 'in_process' | 'reschedule' | null;
};

export type FlowRunResponse = {
    id: string;
    created: string | null;
    updated: string | null;
    /**
     * The name of the flow run. Defaults to a random slug if not specified.
     */
    name?: string;
    /**
     * The id of the flow being run.
     */
    flow_id: string;
    /**
     * The id of the flow run's current state.
     */
    state_id?: string | null;
    /**
     * The id of the deployment associated with this flow run, if available.
     */
    deployment_id?: string | null;
    /**
     * The version of the deployment associated with this flow run.
     */
    deployment_version?: string | null;
    /**
     * The id of the run's work pool queue.
     */
    work_queue_id?: string | null;
    /**
     * The work queue that handled this flow run.
     */
    work_queue_name?: string | null;
    /**
     * The version of the flow executed in this flow run.
     */
    flow_version?: string | null;
    /**
     * Parameters for the flow run.
     */
    parameters?: {
        [key: string]: unknown;
    };
    /**
     * An optional idempotency key for the flow run. Used to ensure the same flow run is not created multiple times.
     */
    idempotency_key?: string | null;
    /**
     * Additional context for the flow run.
     */
    context?: {
        [key: string]: unknown;
    };
    empirical_policy?: FlowRunPolicy;
    /**
     * A list of tags on the flow run
     */
    tags?: Array<(string)>;
    /**
     * A dictionary of key-value labels. Values can be strings, numbers, or booleans.
     */
    labels?: {
        [key: string]: (boolean | number | string);
    };
    /**
     * If the flow run is a subflow, the id of the 'dummy' task in the parent flow used to track subflow state.
     */
    parent_task_run_id?: string | null;
    /**
     * The type of the current flow run state.
     */
    state_type?: StateType | null;
    /**
     * The name of the current flow run state.
     */
    state_name?: string | null;
    /**
     * The number of times the flow run was executed.
     */
    run_count?: number;
    /**
     * The flow run's expected start time.
     */
    expected_start_time?: string | null;
    /**
     * The next time the flow run is scheduled to start.
     */
    next_scheduled_start_time?: string | null;
    /**
     * The actual start time.
     */
    start_time?: string | null;
    /**
     * The actual end time.
     */
    end_time?: string | null;
    /**
     * Total run time. If the flow run was executed multiple times, the time of each run will be summed.
     */
    total_run_time?: number;
    /**
     * A real-time estimate of the total run time.
     */
    estimated_run_time?: number;
    /**
     * The difference between actual and expected start time.
     */
    estimated_start_time_delta?: number;
    /**
     * Whether or not the flow run was automatically scheduled.
     */
    auto_scheduled?: boolean;
    /**
     * The block document defining infrastructure to use this flow run.
     */
    infrastructure_document_id?: string | null;
    /**
     * The id of the flow run as returned by an infrastructure block.
     */
    infrastructure_pid?: string | null;
    /**
     * Optional information about the creator of this flow run.
     */
    created_by?: CreatedBy | null;
    /**
     * The id of the flow run's work pool.
     */
    work_pool_id?: string | null;
    /**
     * The name of the flow run's work pool.
     */
    work_pool_name?: string | null;
    /**
     * The current state of the flow run.
     */
    state?: State | null;
    /**
     * Variables used as overrides in the base job template
     */
    job_variables?: {
    [key: string]: unknown;
} | null;
};

/**
 * Defines flow run sorting options.
 */
export type FlowRunSort = 'ID_DESC' | 'START_TIME_ASC' | 'START_TIME_DESC' | 'EXPECTED_START_TIME_ASC' | 'EXPECTED_START_TIME_DESC' | 'NAME_ASC' | 'NAME_DESC' | 'NEXT_SCHEDULED_START_TIME_ASC' | 'END_TIME_DESC';

/**
 * Data used by the Prefect REST API to update a flow run.
 */
export type FlowRunUpdate = {
    name?: string | null;
    flow_version?: string | null;
    parameters?: {
        [key: string]: unknown;
    };
    empirical_policy?: FlowRunPolicy;
    tags?: Array<(string)>;
    infrastructure_pid?: string | null;
    job_variables?: {
    [key: string]: unknown;
} | null;
};

/**
 * Defines flow sorting options.
 */
export type FlowSort = 'CREATED_DESC' | 'UPDATED_DESC' | 'NAME_ASC' | 'NAME_DESC';

/**
 * Data used by the Prefect REST API to update a flow.
 */
export type FlowUpdate = {
    /**
     * A list of flow tags
     */
    tags?: Array<(string)>;
};

/**
 * A response object for global concurrency limits.
 */
export type GlobalConcurrencyLimitResponse = {
    id: string;
    created: string | null;
    updated: string | null;
    /**
     * Whether the global concurrency limit is active.
     */
    active?: boolean;
    /**
     * The name of the global concurrency limit.
     */
    name: string;
    /**
     * The concurrency limit.
     */
    limit: number;
    /**
     * The number of active slots.
     */
    active_slots: number;
    /**
     * The decay rate for active slots when used as a rate limit.
     */
    slot_decay_per_second?: number;
};

export type Graph = {
    start_time: string | null;
    end_time: string | null;
    root_node_ids: Array<(string)>;
    nodes: Array<[
        string,
        Node
    ]>;
    artifacts: Array<GraphArtifact>;
    states: Array<GraphState>;
};

export type GraphArtifact = {
    id: string;
    created: string;
    key: string | null;
    type: string | null;
    is_latest: boolean;
    data: unknown | null;
};

export type GraphState = {
    id: string;
    timestamp: string;
    type: StateType;
    name: string;
};

export type HTTPValidationError = {
    detail?: Array<ValidationError>;
};

/**
 * Represents a history of aggregation states over an interval
 */
export type HistoryResponse = {
    /**
     * The start date of the interval.
     */
    interval_start: string;
    /**
     * The end date of the interval.
     */
    interval_end: string;
    /**
     * A list of state histories during the interval.
     */
    states: Array<HistoryResponseState>;
};

/**
 * Represents a single state's history over an interval.
 */
export type HistoryResponseState = {
    /**
     * The state type.
     */
    state_type: StateType;
    /**
     * The state name.
     */
    state_name: string;
    /**
     * The number of runs in the specified state during the interval.
     */
    count_runs: number;
    /**
     * The total estimated run time of all runs during the interval.
     */
    sum_estimated_run_time: number;
    /**
     * The sum of differences between actual and expected start time during the interval.
     */
    sum_estimated_lateness: number;
};

/**
 * A schedule formed by adding `interval` increments to an `anchor_date`. If no
 * `anchor_date` is supplied, the current UTC time is used.  If a
 * timezone-naive datetime is provided for `anchor_date`, it is assumed to be
 * in the schedule's timezone (or UTC). Even if supplied with an IANA timezone,
 * anchor dates are always stored as UTC offsets, so a `timezone` can be
 * provided to determine localization behaviors like DST boundary handling. If
 * none is provided it will be inferred from the anchor date.
 *
 * NOTE: If the `IntervalSchedule` `anchor_date` or `timezone` is provided in a
 * DST-observing timezone, then the schedule will adjust itself appropriately.
 * Intervals greater than 24 hours will follow DST conventions, while intervals
 * of less than 24 hours will follow UTC intervals. For example, an hourly
 * schedule will fire every UTC hour, even across DST boundaries. When clocks
 * are set back, this will result in two runs that *appear* to both be
 * scheduled for 1am local time, even though they are an hour apart in UTC
 * time. For longer intervals, like a daily schedule, the interval schedule
 * will adjust for DST boundaries so that the clock-hour remains constant. This
 * means that a daily schedule that always fires at 9am will observe DST and
 * continue to fire at 9am in the local time zone.
 *
 * Args:
 * interval (datetime.timedelta): an interval to schedule on.
 * anchor_date (DateTime, optional): an anchor date to schedule increments against;
 * if not provided, the current timestamp will be used.
 * timezone (str, optional): a valid timezone string.
 */
export type IntervalSchedule = {
    interval: number;
    anchor_date?: string;
    timezone?: string | null;
};

/**
 * An ORM representation of log data.
 */
export type Log = {
    id: string;
    created: string | null;
    updated: string | null;
    /**
     * The logger name.
     */
    name: string;
    /**
     * The log level.
     */
    level: number;
    /**
     * The log message.
     */
    message: string;
    /**
     * The log timestamp.
     */
    timestamp: string;
    /**
     * The flow run ID associated with the log.
     */
    flow_run_id?: string | null;
    /**
     * The task run ID associated with the log.
     */
    task_run_id?: string | null;
};

/**
 * Data used by the Prefect REST API to create a log.
 */
export type LogCreate = {
    /**
     * The logger name.
     */
    name: string;
    /**
     * The log level.
     */
    level: number;
    /**
     * The log message.
     */
    message: string;
    /**
     * The log timestamp.
     */
    timestamp: string;
    flow_run_id?: string | null;
    task_run_id?: string | null;
};

/**
 * Filter logs. Only logs matching all criteria will be returned
 */
export type LogFilter = {
    /**
     * Operator for combining filter criteria. Defaults to 'and_'.
     */
    operator?: Operator;
    /**
     * Filter criteria for `Log.level`
     */
    level?: LogFilterLevel | null;
    /**
     * Filter criteria for `Log.timestamp`
     */
    timestamp?: LogFilterTimestamp | null;
    /**
     * Filter criteria for `Log.flow_run_id`
     */
    flow_run_id?: LogFilterFlowRunId | null;
    /**
     * Filter criteria for `Log.task_run_id`
     */
    task_run_id?: LogFilterTaskRunId | null;
};

/**
 * Filter by `Log.flow_run_id`.
 */
export type LogFilterFlowRunId = {
    /**
     * A list of flow run IDs to include
     */
    any_?: Array<(string)> | null;
};

/**
 * Filter by `Log.level`.
 */
export type LogFilterLevel = {
    /**
     * Include logs with a level greater than or equal to this level
     */
    ge_?: number | null;
    /**
     * Include logs with a level less than or equal to this level
     */
    le_?: number | null;
};

/**
 * Filter by `Log.task_run_id`.
 */
export type LogFilterTaskRunId = {
    /**
     * A list of task run IDs to include
     */
    any_?: Array<(string)> | null;
    /**
     * If true, only include logs without a task run id
     */
    is_null_?: boolean | null;
};

/**
 * Filter by `Log.timestamp`.
 */
export type LogFilterTimestamp = {
    /**
     * Only include logs with a timestamp at or before this time
     */
    before_?: string | null;
    /**
     * Only include logs with a timestamp at or after this time
     */
    after_?: string | null;
};

/**
 * Defines log sorting options.
 */
export type LogSort = 'TIMESTAMP_ASC' | 'TIMESTAMP_DESC';

export type MinimalConcurrencyLimitResponse = {
    id: string;
    name: string;
    limit: number;
};

export type Node = {
    kind: 'flow-run' | 'task-run';
    id: string;
    label: string;
    state_type: StateType;
    start_time: string;
    end_time: string | null;
    parents: Array<Edge>;
    children: Array<Edge>;
    encapsulating: Array<Edge>;
    artifacts: Array<GraphArtifact>;
};

export type kind = 'flow-run' | 'task-run';

/**
 * Operators for combining filter criteria.
 */
export type Operator = 'and_' | 'or_';

/**
 * A container for the output of state orchestration.
 */
export type OrchestrationResult = {
    state: State | null;
    status: SetStateStatus;
    details: StateAcceptDetails | StateWaitDetails | StateRejectDetails | StateAbortDetails;
};

/**
 * Represents a parameter input to a task run.
 */
export type Parameter = {
    input_type?: "parameter";
    name: string;
};

/**
 * Pauses a Work Queue
 */
export type PauseAutomation = {
    type?: "pause-automation";
    /**
     * Whether this Action applies to a specific selected automation (given by `automation_id`), or to an automation that is inferred from the triggering event.  If the source is 'inferred', the `automation_id` may not be set.  If the source is 'selected', the `automation_id` must be set.
     */
    source?: 'selected' | 'inferred';
    /**
     * The identifier of the automation to act on
     */
    automation_id?: string | null;
};

/**
 * Whether this Action applies to a specific selected automation (given by `automation_id`), or to an automation that is inferred from the triggering event.  If the source is 'inferred', the `automation_id` may not be set.  If the source is 'selected', the `automation_id` must be set.
 */
export type source = 'selected' | 'inferred';

/**
 * Pauses the given Deployment
 */
export type PauseDeployment = {
    type?: "pause-deployment";
    /**
     * Whether this Action applies to a specific selected deployment (given by `deployment_id`), or to a deployment that is inferred from the triggering event.  If the source is 'inferred', the `deployment_id` may not be set.  If the source is 'selected', the `deployment_id` must be set.
     */
    source?: 'selected' | 'inferred';
    /**
     * The identifier of the deployment
     */
    deployment_id?: string | null;
};

/**
 * Pauses a Work Pool
 */
export type PauseWorkPool = {
    type?: "pause-work-pool";
    /**
     * Whether this Action applies to a specific selected work pool (given by `work_pool_id`), or to a work pool that is inferred from the triggering event.  If the source is 'inferred', the `work_pool_id` may not be set.  If the source is 'selected', the `work_pool_id` must be set.
     */
    source?: 'selected' | 'inferred';
    /**
     * The identifier of the work pool to pause
     */
    work_pool_id?: string | null;
};

/**
 * Pauses a Work Queue
 */
export type PauseWorkQueue = {
    type?: "pause-work-queue";
    /**
     * Whether this Action applies to a specific selected work queue (given by `work_queue_id`), or to a work queue that is inferred from the triggering event.  If the source is 'inferred', the `work_queue_id` may not be set.  If the source is 'selected', the `work_queue_id` must be set.
     */
    source?: 'selected' | 'inferred';
    /**
     * The identifier of the work queue to pause
     */
    work_queue_id?: string | null;
};

/**
 * Filter criteria definition for a work queue.
 */
export type QueueFilter = {
    /**
     * Only include flow runs with these tags in the work queue.
     */
    tags?: Array<(string)> | null;
    /**
     * Only include flow runs from these deployments in the work queue.
     */
    deployment_ids?: Array<(string)> | null;
};

/**
 * RRule schedule, based on the iCalendar standard
 * ([RFC 5545](https://datatracker.ietf.org/doc/html/rfc5545)) as
 * implemented in `dateutils.rrule`.
 *
 * RRules are appropriate for any kind of calendar-date manipulation, including
 * irregular intervals, repetition, exclusions, week day or day-of-month
 * adjustments, and more.
 *
 * Note that as a calendar-oriented standard, `RRuleSchedules` are sensitive to
 * to the initial timezone provided. A 9am daily schedule with a daylight saving
 * time-aware start date will maintain a local 9am time through DST boundaries;
 * a 9am daily schedule with a UTC start date will maintain a 9am UTC time.
 *
 * Args:
 * rrule (str): a valid RRule string
 * timezone (str, optional): a valid timezone string
 */
export type RRuleSchedule = {
    rrule: string;
    timezone?: string | null;
};

/**
 * The server-side view of an event that has happened to a Resource after it has
 * been received by the server
 */
export type ReceivedEvent = {
    /**
     * When the event happened from the sender's perspective
     */
    occurred: string;
    /**
     * The name of the event that happened
     */
    event: string;
    /**
     * The primary Resource this event concerns
     */
    resource: Resource;
    /**
     * A list of additional Resources involved in this event
     */
    related?: Array<RelatedResource>;
    /**
     * An open-ended set of data describing what happened
     */
    payload?: {
        [key: string]: unknown;
    };
    /**
     * The client-provided identifier of this event
     */
    id: string;
    /**
     * The ID of an event that is known to have occurred prior to this one. If set, this may be used to establish a more precise ordering of causally-related events when they occur close enough together in time that the system may receive them out-of-order.
     */
    follows?: string | null;
    /**
     * When the event was received by Prefect Cloud
     */
    received?: string;
};

/**
 * A Resource with a specific role in an Event
 */
export type RelatedResource = {
    [key: string]: (string);
};

/**
 * An observable business object of interest to the user
 */
export type Resource = {
    [key: string]: (string);
};

export type ResourceSpecification = {
    [key: string]: (string | Array<(string)>);
};

/**
 * Resumes a Work Queue
 */
export type ResumeAutomation = {
    type?: "resume-automation";
    /**
     * Whether this Action applies to a specific selected automation (given by `automation_id`), or to an automation that is inferred from the triggering event.  If the source is 'inferred', the `automation_id` may not be set.  If the source is 'selected', the `automation_id` must be set.
     */
    source?: 'selected' | 'inferred';
    /**
     * The identifier of the automation to act on
     */
    automation_id?: string | null;
};

/**
 * Resumes the given Deployment
 */
export type ResumeDeployment = {
    type?: "resume-deployment";
    /**
     * Whether this Action applies to a specific selected deployment (given by `deployment_id`), or to a deployment that is inferred from the triggering event.  If the source is 'inferred', the `deployment_id` may not be set.  If the source is 'selected', the `deployment_id` must be set.
     */
    source?: 'selected' | 'inferred';
    /**
     * The identifier of the deployment
     */
    deployment_id?: string | null;
};

/**
 * Resumes a paused or suspended flow run associated with the trigger
 */
export type ResumeFlowRun = {
    type?: "resume-flow-run";
};

/**
 * Resumes a Work Pool
 */
export type ResumeWorkPool = {
    type?: "resume-work-pool";
    /**
     * Whether this Action applies to a specific selected work pool (given by `work_pool_id`), or to a work pool that is inferred from the triggering event.  If the source is 'inferred', the `work_pool_id` may not be set.  If the source is 'selected', the `work_pool_id` must be set.
     */
    source?: 'selected' | 'inferred';
    /**
     * The identifier of the work pool to pause
     */
    work_pool_id?: string | null;
};

/**
 * Resumes a Work Queue
 */
export type ResumeWorkQueue = {
    type?: "resume-work-queue";
    /**
     * Whether this Action applies to a specific selected work queue (given by `work_queue_id`), or to a work queue that is inferred from the triggering event.  If the source is 'inferred', the `work_queue_id` may not be set.  If the source is 'selected', the `work_queue_id` must be set.
     */
    source?: 'selected' | 'inferred';
    /**
     * The identifier of the work queue to pause
     */
    work_queue_id?: string | null;
};

/**
 * Runs the given deployment with the given parameters
 */
export type RunDeployment = {
    type?: "run-deployment";
    /**
     * Whether this Action applies to a specific selected deployment (given by `deployment_id`), or to a deployment that is inferred from the triggering event.  If the source is 'inferred', the `deployment_id` may not be set.  If the source is 'selected', the `deployment_id` must be set.
     */
    source?: 'selected' | 'inferred';
    /**
     * The identifier of the deployment
     */
    deployment_id?: string | null;
    /**
     * The parameters to pass to the deployment, or None to use the deployment's default parameters
     */
    parameters?: {
    [key: string]: unknown;
} | null;
    /**
     * The job variables to pass to the created flow run, or None to use the deployment's default job variables
     */
    job_variables?: {
    [key: string]: unknown;
} | null;
};

/**
 * An ORM representation of saved search data. Represents a set of filter criteria.
 */
export type SavedSearch = {
    id: string;
    created: string | null;
    updated: string | null;
    /**
     * The name of the saved search.
     */
    name: string;
    /**
     * The filter set for the saved search.
     */
    filters?: Array<SavedSearchFilter>;
};

/**
 * Data used by the Prefect REST API to create a saved search.
 */
export type SavedSearchCreate = {
    /**
     * The name of the saved search.
     */
    name: string;
    /**
     * The filter set for the saved search.
     */
    filters?: Array<SavedSearchFilter>;
};

/**
 * A filter for a saved search model. Intended for use by the Prefect UI.
 */
export type SavedSearchFilter = {
    /**
     * The object over which to filter.
     */
    object: string;
    /**
     * The property of the object on which to filter.
     */
    property: string;
    /**
     * The type of the property.
     */
    type: string;
    /**
     * The operator to apply to the object. For example, `equals`.
     */
    operation: string;
    /**
     * A JSON-compatible value for the filter.
     */
    value: unknown;
};

/**
 * Send a notification when an Automation is triggered
 */
export type SendNotification = {
    type?: "send-notification";
    /**
     * The identifier of the notification block to use
     */
    block_document_id: string;
    subject?: string;
    /**
     * The text of the notification to send
     */
    body: string;
};

/**
 * A composite trigger that requires some number of triggers to have fired
 * within the given time period in a specific order
 */
export type SequenceTrigger_Input = {
    type?: "sequence";
    /**
     * The unique ID of this trigger
     */
    id?: string;
    triggers: Array<(EventTrigger | CompoundTrigger_Input | SequenceTrigger_Input)>;
    within: number | null;
};

/**
 * A composite trigger that requires some number of triggers to have fired
 * within the given time period in a specific order
 */
export type SequenceTrigger_Output = {
    type?: "sequence";
    /**
     * The unique ID of this trigger
     */
    id?: string;
    triggers: Array<(EventTrigger | CompoundTrigger_Output | SequenceTrigger_Output)>;
    within: number | null;
};

/**
 * Enumerates return statuses for setting run states.
 */
export type SetStateStatus = 'ACCEPT' | 'REJECT' | 'ABORT' | 'WAIT';

export type Settings = unknown;

export type SimpleFlowRun = {
    /**
     * The flow run id.
     */
    id: string;
    /**
     * The state type.
     */
    state_type: StateType;
    /**
     * The start time of the run, or the expected start time if it hasn't run yet.
     */
    timestamp: string;
    /**
     * The total run time of the run.
     */
    duration: number;
    /**
     * The delay between the expected and actual start time.
     */
    lateness: number;
};

export type SimpleNextFlowRun = {
    /**
     * The flow run id.
     */
    id: string;
    /**
     * The flow id.
     */
    flow_id: string;
    /**
     * The flow run name
     */
    name: string;
    /**
     * The state name.
     */
    state_name: string;
    /**
     * The state type.
     */
    state_type: StateType;
    /**
     * The next scheduled start time
     */
    next_scheduled_start_time: string;
};

/**
 * Represents the state of a run.
 */
export type State = {
    id: string;
    type: StateType;
    name?: string | null;
    timestamp?: string;
    message?: string | null;
    /**
     * Data associated with the state, e.g. a result. Content must be storable as JSON.
     */
    data?: unknown | null;
    state_details?: StateDetails;
};

/**
 * Details associated with an ABORT state transition.
 */
export type StateAbortDetails = {
    /**
     * The type of state transition detail. Used to ensure pydantic does not coerce into a different type.
     */
    type?: "abort_details";
    /**
     * The reason why the state transition was aborted.
     */
    reason?: string | null;
};

/**
 * Details associated with an ACCEPT state transition.
 */
export type StateAcceptDetails = {
    /**
     * The type of state transition detail. Used to ensure pydantic does not coerce into a different type.
     */
    type?: "accept_details";
};

/**
 * Data used by the Prefect REST API to create a new state.
 */
export type StateCreate = {
    /**
     * The type of the state to create
     */
    type: StateType;
    /**
     * The name of the state to create
     */
    name?: string | null;
    /**
     * The message of the state to create
     */
    message?: string | null;
    /**
     * The data of the state to create
     */
    data?: unknown | null;
    /**
     * The details of the state to create
     */
    state_details?: StateDetails;
};

export type StateDetails = {
    flow_run_id?: string | null;
    task_run_id?: string | null;
    child_flow_run_id?: string | null;
    scheduled_time?: string | null;
    cache_key?: string | null;
    cache_expiration?: string | null;
    deferred?: boolean | null;
    untrackable_result?: boolean;
    pause_timeout?: string | null;
    pause_reschedule?: boolean;
    pause_key?: string | null;
    run_input_keyset?: {
    [key: string]: (string);
} | null;
    refresh_cache?: boolean | null;
    retriable?: boolean | null;
    transition_id?: string | null;
    task_parameters_id?: string | null;
    traceparent?: string | null;
};

/**
 * Details associated with a REJECT state transition.
 */
export type StateRejectDetails = {
    /**
     * The type of state transition detail. Used to ensure pydantic does not coerce into a different type.
     */
    type?: "reject_details";
    /**
     * The reason why the state transition was rejected.
     */
    reason?: string | null;
};

/**
 * Enumeration of state types.
 */
export type StateType = 'SCHEDULED' | 'PENDING' | 'RUNNING' | 'COMPLETED' | 'FAILED' | 'CANCELLED' | 'CRASHED' | 'PAUSED' | 'CANCELLING';

/**
 * Details associated with a WAIT state transition.
 */
export type StateWaitDetails = {
    /**
     * The type of state transition detail. Used to ensure pydantic does not coerce into a different type.
     */
    type?: "wait_details";
    /**
     * The length of time in seconds the client should wait before transitioning states.
     */
    delay_seconds: number;
    /**
     * The reason why the state transition should wait.
     */
    reason?: string | null;
};

/**
 * Suspends a flow run associated with the trigger
 */
export type SuspendFlowRun = {
    type?: "suspend-flow-run";
};

/**
 * An ORM representation of task run data.
 */
export type TaskRun = {
    id: string;
    created: string | null;
    updated: string | null;
    name?: string;
    /**
     * The flow run id of the task run.
     */
    flow_run_id?: string | null;
    /**
     * A unique identifier for the task being run.
     */
    task_key: string;
    /**
     * A dynamic key used to differentiate between multiple runs of the same task within the same flow run.
     */
    dynamic_key: string;
    /**
     * An optional cache key. If a COMPLETED state associated with this cache key is found, the cached COMPLETED state will be used instead of executing the task run.
     */
    cache_key?: string | null;
    /**
     * Specifies when the cached state should expire.
     */
    cache_expiration?: string | null;
    /**
     * The version of the task being run.
     */
    task_version?: string | null;
    empirical_policy?: TaskRunPolicy;
    /**
     * A list of tags for the task run.
     */
    tags?: Array<(string)>;
    /**
     * A dictionary of key-value labels. Values can be strings, numbers, or booleans.
     */
    labels?: {
    [key: string]: (boolean | number | string);
} | null;
    /**
     * The id of the current task run state.
     */
    state_id?: string | null;
    /**
     * Tracks the source of inputs to a task run. Used for internal bookkeeping.
     */
    task_inputs?: {
        [key: string]: Array<(TaskRunResult | Parameter | Constant)>;
    };
    /**
     * The type of the current task run state.
     */
    state_type?: StateType | null;
    /**
     * The name of the current task run state.
     */
    state_name?: string | null;
    /**
     * The number of times the task run has been executed.
     */
    run_count?: number;
    /**
     * If the parent flow has retried, this indicates the flow retry this run is associated with.
     */
    flow_run_run_count?: number;
    /**
     * The task run's expected start time.
     */
    expected_start_time?: string | null;
    /**
     * The next time the task run is scheduled to start.
     */
    next_scheduled_start_time?: string | null;
    /**
     * The actual start time.
     */
    start_time?: string | null;
    /**
     * The actual end time.
     */
    end_time?: string | null;
    /**
     * Total run time. If the task run was executed multiple times, the time of each run will be summed.
     */
    total_run_time?: number;
    /**
     * A real-time estimate of total run time.
     */
    estimated_run_time?: number;
    /**
     * The difference between actual and expected start time.
     */
    estimated_start_time_delta?: number;
    /**
     * The current task run state.
     */
    state?: State | null;
};

export type TaskRunCount = {
    [key: string]: (number);
};

/**
 * Data used by the Prefect REST API to create a task run
 */
export type TaskRunCreate = {
    /**
     * The ID to assign to the task run. If not provided, a random UUID will be generated.
     */
    id?: string | null;
    /**
     * The state of the task run to create
     */
    state?: StateCreate | null;
    name?: string;
    /**
     * The flow run id of the task run.
     */
    flow_run_id?: string | null;
    /**
     * A unique identifier for the task being run.
     */
    task_key: string;
    /**
     * A dynamic key used to differentiate between multiple runs of the same task within the same flow run.
     */
    dynamic_key: string;
    /**
     * An optional cache key. If a COMPLETED state associated with this cache key is found, the cached COMPLETED state will be used instead of executing the task run.
     */
    cache_key?: string | null;
    /**
     * Specifies when the cached state should expire.
     */
    cache_expiration?: string | null;
    /**
     * The version of the task being run.
     */
    task_version?: string | null;
    empirical_policy?: TaskRunPolicy;
    /**
     * A list of tags for the task run.
     */
    tags?: Array<(string)>;
    /**
     * A dictionary of key-value labels. Values can be strings, numbers, or booleans.
     */
    labels?: {
    [key: string]: (boolean | number | string);
} | null;
    /**
     * The inputs to the task run.
     */
    task_inputs?: {
        [key: string]: Array<(TaskRunResult | Parameter | Constant)>;
    };
};

/**
 * Filter task runs. Only task runs matching all criteria will be returned
 */
export type TaskRunFilter = {
    /**
     * Operator for combining filter criteria. Defaults to 'and_'.
     */
    operator?: Operator;
    /**
     * Filter criteria for `TaskRun.id`
     */
    id?: TaskRunFilterId | null;
    /**
     * Filter criteria for `TaskRun.name`
     */
    name?: TaskRunFilterName | null;
    /**
     * Filter criteria for `TaskRun.tags`
     */
    tags?: TaskRunFilterTags | null;
    /**
     * Filter criteria for `TaskRun.state`
     */
    state?: TaskRunFilterState | null;
    /**
     * Filter criteria for `TaskRun.start_time`
     */
    start_time?: TaskRunFilterStartTime | null;
    /**
     * Filter criteria for `TaskRun.expected_start_time`
     */
    expected_start_time?: TaskRunFilterExpectedStartTime | null;
    /**
     * Filter criteria for `TaskRun.subflow_run`
     */
    subflow_runs?: TaskRunFilterSubFlowRuns | null;
    /**
     * Filter criteria for `TaskRun.flow_run_id`
     */
    flow_run_id?: TaskRunFilterFlowRunId | null;
};

/**
 * Filter by `TaskRun.expected_start_time`.
 */
export type TaskRunFilterExpectedStartTime = {
    /**
     * Only include task runs expected to start at or before this time
     */
    before_?: string | null;
    /**
     * Only include task runs expected to start at or after this time
     */
    after_?: string | null;
};

/**
 * Filter by `TaskRun.flow_run_id`.
 */
export type TaskRunFilterFlowRunId = {
    /**
     * Operator for combining filter criteria. Defaults to 'and_'.
     */
    operator?: Operator;
    /**
     * A list of task run flow run ids to include
     */
    any_?: Array<(string)> | null;
    /**
     * Filter for task runs with None as their flow run id
     */
    is_null_?: boolean | null;
};

/**
 * Filter by `TaskRun.id`.
 */
export type TaskRunFilterId = {
    /**
     * A list of task run ids to include
     */
    any_?: Array<(string)> | null;
};

/**
 * Filter by `TaskRun.name`.
 */
export type TaskRunFilterName = {
    /**
     * A list of task run names to include
     */
    any_?: Array<(string)> | null;
    /**
     * A case-insensitive partial match. For example,  passing 'marvin' will match 'marvin', 'sad-Marvin', and 'marvin-robot'.
     */
    like_?: string | null;
};

/**
 * Filter by `TaskRun.start_time`.
 */
export type TaskRunFilterStartTime = {
    /**
     * Only include task runs starting at or before this time
     */
    before_?: string | null;
    /**
     * Only include task runs starting at or after this time
     */
    after_?: string | null;
    /**
     * If true, only return task runs without a start time
     */
    is_null_?: boolean | null;
};

/**
 * Filter by `TaskRun.type` and `TaskRun.name`.
 */
export type TaskRunFilterState = {
    /**
     * Operator for combining filter criteria. Defaults to 'and_'.
     */
    operator?: Operator;
    /**
     * Filter criteria for `TaskRun.state_type`
     */
    type?: TaskRunFilterStateType | null;
    /**
     * Filter criteria for `TaskRun.state_name`
     */
    name?: TaskRunFilterStateName | null;
};

/**
 * Filter by `TaskRun.state_name`.
 */
export type TaskRunFilterStateName = {
    /**
     * A list of task run state names to include
     */
    any_?: Array<(string)> | null;
};

/**
 * Filter by `TaskRun.state_type`.
 */
export type TaskRunFilterStateType = {
    /**
     * A list of task run state types to include
     */
    any_?: Array<StateType> | null;
};

/**
 * Filter by `TaskRun.subflow_run`.
 */
export type TaskRunFilterSubFlowRuns = {
    /**
     * If true, only include task runs that are subflow run parents; if false, exclude parent task runs
     */
    exists_?: boolean | null;
};

/**
 * Filter by `TaskRun.tags`.
 */
export type TaskRunFilterTags = {
    /**
     * Operator for combining filter criteria. Defaults to 'and_'.
     */
    operator?: Operator;
    /**
     * A list of tags. Task runs will be returned only if their tags are a superset of the list
     */
    all_?: Array<(string)> | null;
    /**
     * If true, only include task runs without tags
     */
    is_null_?: boolean | null;
};

/**
 * Defines of how a task run should retry.
 */
export type TaskRunPolicy = {
    /**
     * The maximum number of retries. Field is not used. Please use `retries` instead.
     * @deprecated
     */
    max_retries?: number;
    /**
     * The delay between retries. Field is not used. Please use `retry_delay` instead.
     * @deprecated
     */
    retry_delay_seconds?: number;
    /**
     * The number of retries.
     */
    retries?: number | null;
    /**
     * A delay time or list of delay times between retries, in seconds.
     */
    retry_delay?: number | Array<(number)> | null;
    /**
     * Determines the amount a retry should jitter
     */
    retry_jitter_factor?: number | null;
};

/**
 * Represents a task run result input to another task run.
 */
export type TaskRunResult = {
    input_type?: "task_run";
    id: string;
};

/**
 * Defines task run sorting options.
 */
export type TaskRunSort = 'ID_DESC' | 'EXPECTED_START_TIME_ASC' | 'EXPECTED_START_TIME_DESC' | 'NAME_ASC' | 'NAME_DESC' | 'NEXT_SCHEDULED_START_TIME_ASC' | 'END_TIME_DESC';

/**
 * Data used by the Prefect REST API to update a task run
 */
export type TaskRunUpdate = {
    name?: string;
};

export type TaskWorkerFilter = {
    task_keys: Array<(string)>;
};

export type TaskWorkerResponse = {
    identifier: string;
    task_keys: Array<(string)>;
    timestamp: string;
};

export type TimeUnit = 'week' | 'day' | 'hour' | 'minute' | 'second';

export type UpdatedBy = {
    /**
     * The id of the updater of the object.
     */
    id?: string | null;
    /**
     * The type of the updater of the object.
     */
    type?: string | null;
    /**
     * The display value for the updater.
     */
    display_value?: string | null;
};

export type ValidationError = {
    loc: Array<(string | number)>;
    msg: string;
    type: string;
};

export type Variable = {
    id: string;
    created: string | null;
    updated: string | null;
    /**
     * The name of the variable
     */
    name: string;
    /**
     * The value of the variable
     */
    value: string | number | boolean | {
    [key: string]: unknown;
} | Array<unknown> | null;
    /**
     * A list of variable tags
     */
    tags?: Array<(string)>;
};

/**
 * Data used by the Prefect REST API to create a Variable.
 */
export type VariableCreate = {
    /**
     * The name of the variable
     */
    name: string;
    /**
     * The value of the variable
     */
    value: string | number | boolean | {
    [key: string]: unknown;
} | Array<unknown> | null;
    /**
     * A list of variable tags
     */
    tags?: Array<(string)>;
};

/**
 * Filter variables. Only variables matching all criteria will be returned
 */
export type VariableFilter = {
    /**
     * Operator for combining filter criteria. Defaults to 'and_'.
     */
    operator?: Operator;
    /**
     * Filter criteria for `Variable.id`
     */
    id?: VariableFilterId | null;
    /**
     * Filter criteria for `Variable.name`
     */
    name?: VariableFilterName | null;
    /**
     * Filter criteria for `Variable.tags`
     */
    tags?: VariableFilterTags | null;
};

/**
 * Filter by `Variable.id`.
 */
export type VariableFilterId = {
    /**
     * A list of variable ids to include
     */
    any_?: Array<(string)> | null;
};

/**
 * Filter by `Variable.name`.
 */
export type VariableFilterName = {
    /**
     * A list of variables names to include
     */
    any_?: Array<(string)> | null;
    /**
     * A string to match variable names against. This can include SQL wildcard characters like `%` and `_`.
     */
    like_?: string | null;
};

/**
 * Filter by `Variable.tags`.
 */
export type VariableFilterTags = {
    /**
     * Operator for combining filter criteria. Defaults to 'and_'.
     */
    operator?: Operator;
    /**
     * A list of tags. Variables will be returned only if their tags are a superset of the list
     */
    all_?: Array<(string)> | null;
    /**
     * If true, only include Variables without tags
     */
    is_null_?: boolean | null;
};

/**
 * Defines variables sorting options.
 */
export type VariableSort = 'CREATED_DESC' | 'UPDATED_DESC' | 'NAME_DESC' | 'NAME_ASC';

/**
 * Data used by the Prefect REST API to update a Variable.
 */
export type VariableUpdate = {
    /**
     * The name of the variable
     */
    name?: string | null;
    /**
     * The value of the variable
     */
    value?: string | number | boolean | {
    [key: string]: unknown;
} | Array<unknown> | null;
    /**
     * A list of variable tags
     */
    tags?: Array<(string)> | null;
};

/**
 * An ORM representation of a work pool
 */
export type WorkPool = {
    id: string;
    created: string | null;
    updated: string | null;
    /**
     * The name of the work pool.
     */
    name: string;
    /**
     * A description of the work pool.
     */
    description?: string | null;
    /**
     * The work pool type.
     */
    type: string;
    /**
     * The work pool's base job template.
     */
    base_job_template?: {
        [key: string]: unknown;
    };
    /**
     * Pausing the work pool stops the delivery of all work.
     */
    is_paused?: boolean;
    /**
     * A concurrency limit for the work pool.
     */
    concurrency_limit?: number | null;
    /**
     * The current status of the work pool.
     */
    status?: WorkPoolStatus | null;
    /**
     * The id of the pool's default queue.
     */
    default_queue_id?: string | null;
};

/**
 * Data used by the Prefect REST API to create a work pool.
 */
export type WorkPoolCreate = {
    /**
     * The name of the work pool.
     */
    name: string;
    /**
     * The work pool description.
     */
    description?: string | null;
    /**
     * The work pool type.
     */
    type?: string;
    /**
     * The work pool's base job template.
     */
    base_job_template?: {
        [key: string]: unknown;
    };
    /**
     * Pausing the work pool stops the delivery of all work.
     */
    is_paused?: boolean;
    /**
     * A concurrency limit for the work pool.
     */
    concurrency_limit?: number | null;
};

/**
 * Filter work pools. Only work pools matching all criteria will be returned
 */
export type WorkPoolFilter = {
    /**
     * Operator for combining filter criteria. Defaults to 'and_'.
     */
    operator?: Operator;
    /**
     * Filter criteria for `WorkPool.id`
     */
    id?: WorkPoolFilterId | null;
    /**
     * Filter criteria for `WorkPool.name`
     */
    name?: WorkPoolFilterName | null;
    /**
     * Filter criteria for `WorkPool.type`
     */
    type?: WorkPoolFilterType | null;
};

/**
 * Filter by `WorkPool.id`.
 */
export type WorkPoolFilterId = {
    /**
     * A list of work pool ids to include
     */
    any_?: Array<(string)> | null;
};

/**
 * Filter by `WorkPool.name`.
 */
export type WorkPoolFilterName = {
    /**
     * A list of work pool names to include
     */
    any_?: Array<(string)> | null;
};

/**
 * Filter by `WorkPool.type`.
 */
export type WorkPoolFilterType = {
    /**
     * A list of work pool types to include
     */
    any_?: Array<(string)> | null;
};

/**
 * Enumeration of work pool statuses.
 */
export type WorkPoolStatus = 'READY' | 'NOT_READY' | 'PAUSED';

/**
 * Data used by the Prefect REST API to update a work pool.
 */
export type WorkPoolUpdate = {
    description?: string | null;
    is_paused?: boolean | null;
    base_job_template?: {
    [key: string]: unknown;
} | null;
    concurrency_limit?: number | null;
};

/**
 * An ORM representation of a work queue
 */
export type WorkQueue = {
    id: string;
    created: string | null;
    updated: string | null;
    /**
     * The name of the work queue.
     */
    name: string;
    /**
     * An optional description for the work queue.
     */
    description?: string | null;
    /**
     * Whether or not the work queue is paused.
     */
    is_paused?: boolean;
    /**
     * An optional concurrency limit for the work queue.
     */
    concurrency_limit?: number | null;
    /**
     * The queue's priority. Lower values are higher priority (1 is the highest).
     */
    priority?: number;
    /**
     * The work pool with which the queue is associated.
     */
    work_pool_id?: string | null;
    /**
     * DEPRECATED: Filter criteria for the work queue.
     * @deprecated
     */
    filter?: QueueFilter | null;
    /**
     * The last time an agent polled this queue for work.
     */
    last_polled?: string | null;
};

/**
 * Data used by the Prefect REST API to create a work queue.
 */
export type WorkQueueCreate = {
    /**
     * The name of the work queue.
     */
    name: string;
    /**
     * An optional description for the work queue.
     */
    description?: string | null;
    /**
     * Whether or not the work queue is paused.
     */
    is_paused?: boolean;
    /**
     * The work queue's concurrency limit.
     */
    concurrency_limit?: number | null;
    /**
     * The queue's priority. Lower values are higher priority (1 is the highest).
     */
    priority?: number | null;
    /**
     * DEPRECATED: Filter criteria for the work queue.
     * @deprecated
     */
    filter?: QueueFilter | null;
};

/**
 * Filter work queues. Only work queues matching all criteria will be
 * returned
 */
export type WorkQueueFilter = {
    /**
     * Operator for combining filter criteria. Defaults to 'and_'.
     */
    operator?: Operator;
    /**
     * Filter criteria for `WorkQueue.id`
     */
    id?: WorkQueueFilterId | null;
    /**
     * Filter criteria for `WorkQueue.name`
     */
    name?: WorkQueueFilterName | null;
};

/**
 * Filter by `WorkQueue.id`.
 */
export type WorkQueueFilterId = {
    /**
     * A list of work queue ids to include
     */
    any_?: Array<(string)> | null;
};

/**
 * Filter by `WorkQueue.name`.
 */
export type WorkQueueFilterName = {
    /**
     * A list of work queue names to include
     */
    any_?: Array<(string)> | null;
    /**
     * A list of case-insensitive starts-with matches. For example,  passing 'marvin' will match 'marvin', and 'Marvin-robot', but not 'sad-marvin'.
     */
    startswith_?: Array<(string)> | null;
};

export type WorkQueueHealthPolicy = {
    /**
     * The maximum number of late runs in the work queue before it is deemed unhealthy. Defaults to `0`.
     */
    maximum_late_runs?: number | null;
    /**
     * The maximum number of time in seconds elapsed since work queue has been polled before it is deemed unhealthy. Defaults to `60`.
     */
    maximum_seconds_since_last_polled?: number | null;
};

export type WorkQueueResponse = {
    id: string;
    created: string | null;
    updated: string | null;
    /**
     * The name of the work queue.
     */
    name: string;
    /**
     * An optional description for the work queue.
     */
    description?: string | null;
    /**
     * Whether or not the work queue is paused.
     */
    is_paused?: boolean;
    /**
     * An optional concurrency limit for the work queue.
     */
    concurrency_limit?: number | null;
    /**
     * The queue's priority. Lower values are higher priority (1 is the highest).
     */
    priority?: number;
    /**
     * The work pool with which the queue is associated.
     */
    work_pool_id?: string | null;
    /**
     * DEPRECATED: Filter criteria for the work queue.
     * @deprecated
     */
    filter?: QueueFilter | null;
    /**
     * The last time an agent polled this queue for work.
     */
    last_polled?: string | null;
    /**
     * The name of the work pool the work pool resides within.
     */
    work_pool_name?: string | null;
    /**
     * The queue status.
     */
    status?: WorkQueueStatus | null;
};

/**
 * Enumeration of work queue statuses.
 */
export type WorkQueueStatus = 'READY' | 'NOT_READY' | 'PAUSED';

export type WorkQueueStatusDetail = {
    /**
     * Whether or not the work queue is healthy.
     */
    healthy: boolean;
    /**
     * The number of late flow runs in the work queue.
     */
    late_runs_count?: number;
    /**
     * The last time an agent polled this queue for work.
     */
    last_polled?: string | null;
    /**
     * The policy used to determine whether or not the work queue is healthy.
     */
    health_check_policy: WorkQueueHealthPolicy;
};

/**
 * Data used by the Prefect REST API to update a work queue.
 */
export type WorkQueueUpdate = {
    name?: string | null;
    description?: string | null;
    /**
     * Whether or not the work queue is paused.
     */
    is_paused?: boolean;
    concurrency_limit?: number | null;
    priority?: number | null;
    last_polled?: string | null;
    /**
     * DEPRECATED: Filter criteria for the work queue.
     * @deprecated
     */
    filter?: QueueFilter | null;
};

/**
 * Filter by `Worker.last_heartbeat_time`.
 */
export type WorkerFilter = {
    /**
     * Operator for combining filter criteria. Defaults to 'and_'.
     */
    operator?: Operator;
    /**
     * Filter criteria for `Worker.last_heartbeat_time`
     */
    last_heartbeat_time?: WorkerFilterLastHeartbeatTime | null;
    /**
     * Filter criteria for `Worker.status`
     */
    status?: WorkerFilterStatus | null;
};

/**
 * Filter by `Worker.last_heartbeat_time`.
 */
export type WorkerFilterLastHeartbeatTime = {
    /**
     * Only include processes whose last heartbeat was at or before this time
     */
    before_?: string | null;
    /**
     * Only include processes whose last heartbeat was at or after this time
     */
    after_?: string | null;
};

/**
 * Filter by `Worker.status`.
 */
export type WorkerFilterStatus = {
    /**
     * A list of worker statuses to include
     */
    any_?: Array<WorkerStatus> | null;
    /**
     * A list of worker statuses to exclude
     */
    not_any_?: Array<WorkerStatus> | null;
};

export type WorkerFlowRunResponse = {
    work_pool_id: string;
    work_queue_id: string;
    flow_run: FlowRun;
};

export type WorkerResponse = {
    id: string;
    created: string | null;
    updated: string | null;
    /**
     * The name of the worker.
     */
    name: string;
    /**
     * The work pool with which the queue is associated.
     */
    work_pool_id: string;
    /**
     * The last time the worker process sent a heartbeat.
     */
    last_heartbeat_time?: string;
    /**
     * The number of seconds to expect between heartbeats sent by the worker.
     */
    heartbeat_interval_seconds?: number | null;
    /**
     * Current status of the worker.
     */
    status?: WorkerStatus;
};

/**
 * Enumeration of worker statuses.
 */
export type WorkerStatus = 'ONLINE' | 'OFFLINE';

export type GetHealthResponse = boolean;

export type GetVersionResponse = string;

export type GetHelloData = {
    xPrefectApiVersion?: string;
};

export type GetHelloResponse = string;

export type GetReadyData = {
    xPrefectApiVersion?: string;
};

export type GetReadyResponse = unknown;

export type PostFlowsData = {
    requestBody: FlowCreate;
    xPrefectApiVersion?: string;
};

export type PostFlowsResponse = Flow;

export type PatchFlowsByIdData = {
    /**
     * The flow id
     */
    id: string;
    requestBody: FlowUpdate;
    xPrefectApiVersion?: string;
};

export type PatchFlowsByIdResponse = void;

export type GetFlowsByIdData = {
    /**
     * The flow id
     */
    id: string;
    xPrefectApiVersion?: string;
};

export type GetFlowsByIdResponse = Flow;

export type DeleteFlowsByIdData = {
    /**
     * The flow id
     */
    id: string;
    xPrefectApiVersion?: string;
};

export type DeleteFlowsByIdResponse = void;

export type PostFlowsCountData = {
    requestBody?: Body_count_flows_flows_count_post;
    xPrefectApiVersion?: string;
};

export type PostFlowsCountResponse = number;

export type GetFlowsNameByNameData = {
    /**
     * The name of the flow
     */
    name: string;
    xPrefectApiVersion?: string;
};

export type GetFlowsNameByNameResponse = Flow;

export type PostFlowsFilterData = {
    requestBody?: Body_read_flows_flows_filter_post;
    xPrefectApiVersion?: string;
};

export type PostFlowsFilterResponse = Array<Flow>;

export type PostFlowsPaginateData = {
    requestBody?: Body_paginate_flows_flows_paginate_post;
    xPrefectApiVersion?: string;
};

export type PostFlowsPaginateResponse = FlowPaginationResponse;

export type PostUiFlowsCountDeploymentsData = {
    requestBody: Body_count_deployments_by_flow_ui_flows_count_deployments_post;
    xPrefectApiVersion?: string;
};

export type PostUiFlowsCountDeploymentsResponse = {
    [key: string]: (number);
};

export type PostUiFlowsNextRunsData = {
    requestBody: Body_next_runs_by_flow_ui_flows_next_runs_post;
    xPrefectApiVersion?: string;
};

export type PostUiFlowsNextRunsResponse = {
    [key: string]: (SimpleNextFlowRun | null);
};

export type PostFlowRunsData = {
    requestBody: FlowRunCreate;
    xPrefectApiVersion?: string;
};

export type PostFlowRunsResponse = FlowRunResponse;

export type PatchFlowRunsByIdData = {
    /**
     * The flow run id
     */
    id: string;
    requestBody: FlowRunUpdate;
    xPrefectApiVersion?: string;
};

export type PatchFlowRunsByIdResponse = void;

export type GetFlowRunsByIdData = {
    /**
     * The flow run id
     */
    id: string;
    xPrefectApiVersion?: string;
};

export type GetFlowRunsByIdResponse = FlowRunResponse;

export type DeleteFlowRunsByIdData = {
    /**
     * The flow run id
     */
    id: string;
    xPrefectApiVersion?: string;
};

export type DeleteFlowRunsByIdResponse = void;

export type PostFlowRunsCountData = {
    requestBody?: Body_count_flow_runs_flow_runs_count_post;
    xPrefectApiVersion?: string;
};

export type PostFlowRunsCountResponse = number;

export type PostFlowRunsLatenessData = {
    requestBody?: Body_average_flow_run_lateness_flow_runs_lateness_post;
    xPrefectApiVersion?: string;
};

export type PostFlowRunsLatenessResponse = number | null;

export type PostFlowRunsHistoryData = {
    requestBody: Body_flow_run_history_flow_runs_history_post;
    xPrefectApiVersion?: string;
};

export type PostFlowRunsHistoryResponse = Array<HistoryResponse>;

export type GetFlowRunsByIdGraphData = {
    /**
     * The flow run id
     */
    id: string;
    xPrefectApiVersion?: string;
};

export type GetFlowRunsByIdGraphResponse = Array<DependencyResult>;

export type GetFlowRunsByIdGraphV2Data = {
    /**
     * The flow run id
     */
    id: string;
    /**
     * Only include runs that start or end after this time.
     */
    since?: string;
    xPrefectApiVersion?: string;
};

export type GetFlowRunsByIdGraphV2Response = Graph;

export type PostFlowRunsByIdResumeData = {
    /**
     * The flow run id
     */
    id: string;
    requestBody?: Body_resume_flow_run_flow_runs__id__resume_post;
    xPrefectApiVersion?: string;
};

export type PostFlowRunsByIdResumeResponse = OrchestrationResult;

export type PostFlowRunsFilterData = {
    requestBody?: Body_read_flow_runs_flow_runs_filter_post;
    xPrefectApiVersion?: string;
};

export type PostFlowRunsFilterResponse = Array<FlowRunResponse>;

export type PostFlowRunsByIdSetStateData = {
    /**
     * The flow run id
     */
    id: string;
    requestBody: Body_set_flow_run_state_flow_runs__id__set_state_post;
    xPrefectApiVersion?: string;
};

export type PostFlowRunsByIdSetStateResponse = OrchestrationResult;

export type PostFlowRunsByIdInputData = {
    /**
     * The flow run id
     */
    id: string;
    requestBody: Body_create_flow_run_input_flow_runs__id__input_post;
    xPrefectApiVersion?: string;
};

export type PostFlowRunsByIdInputResponse = unknown;

export type PostFlowRunsByIdInputFilterData = {
    /**
     * The flow run id
     */
    id: string;
    requestBody: Body_filter_flow_run_input_flow_runs__id__input_filter_post;
    xPrefectApiVersion?: string;
};

export type PostFlowRunsByIdInputFilterResponse = Array<FlowRunInput>;

export type GetFlowRunsByIdInputByKeyData = {
    /**
     * The flow run id
     */
    id: string;
    /**
     * The input key
     */
    key: string;
    xPrefectApiVersion?: string;
};

export type GetFlowRunsByIdInputByKeyResponse = unknown;

export type DeleteFlowRunsByIdInputByKeyData = {
    /**
     * The flow run id
     */
    id: string;
    /**
     * The input key
     */
    key: string;
    xPrefectApiVersion?: string;
};

export type DeleteFlowRunsByIdInputByKeyResponse = void;

export type PostFlowRunsPaginateData = {
    requestBody?: Body_paginate_flow_runs_flow_runs_paginate_post;
    xPrefectApiVersion?: string;
};

export type PostFlowRunsPaginateResponse = FlowRunPaginationResponse;

export type GetFlowRunsByIdLogsDownloadData = {
    /**
     * The flow run id
     */
    id: string;
    xPrefectApiVersion?: string;
};

export type GetFlowRunsByIdLogsDownloadResponse = unknown;

export type PatchFlowRunsByIdLabelsData = {
    /**
     * The flow run id
     */
    id: string;
    requestBody: {
        [key: string]: unknown;
    };
    xPrefectApiVersion?: string;
};

export type PatchFlowRunsByIdLabelsResponse = void;

export type PostUiFlowRunsHistoryData = {
    requestBody?: Body_read_flow_run_history_ui_flow_runs_history_post;
    xPrefectApiVersion?: string;
};

export type PostUiFlowRunsHistoryResponse = Array<SimpleFlowRun>;

export type PostUiFlowRunsCountTaskRunsData = {
    requestBody: Body_count_task_runs_by_flow_run_ui_flow_runs_count_task_runs_post;
    xPrefectApiVersion?: string;
};

export type PostUiFlowRunsCountTaskRunsResponse = {
    [key: string]: (number);
};

export type PostTaskRunsData = {
    requestBody: TaskRunCreate;
    xPrefectApiVersion?: string;
};

export type PostTaskRunsResponse = TaskRun;

export type PatchTaskRunsByIdData = {
    /**
     * The task run id
     */
    id: string;
    requestBody: TaskRunUpdate;
    xPrefectApiVersion?: string;
};

export type PatchTaskRunsByIdResponse = void;

export type GetTaskRunsByIdData = {
    /**
     * The task run id
     */
    id: string;
    xPrefectApiVersion?: string;
};

export type GetTaskRunsByIdResponse = TaskRun;

export type DeleteTaskRunsByIdData = {
    /**
     * The task run id
     */
    id: string;
    xPrefectApiVersion?: string;
};

export type DeleteTaskRunsByIdResponse = void;

export type PostTaskRunsCountData = {
    requestBody?: Body_count_task_runs_task_runs_count_post;
    xPrefectApiVersion?: string;
};

export type PostTaskRunsCountResponse = number;

export type PostTaskRunsHistoryData = {
    requestBody: Body_task_run_history_task_runs_history_post;
    xPrefectApiVersion?: string;
};

export type PostTaskRunsHistoryResponse = Array<HistoryResponse>;

export type PostTaskRunsFilterData = {
    requestBody?: Body_read_task_runs_task_runs_filter_post;
    xPrefectApiVersion?: string;
};

export type PostTaskRunsFilterResponse = Array<TaskRun>;

export type PostTaskRunsByIdSetStateData = {
    /**
     * The task run id
     */
    id: string;
    requestBody: Body_set_task_run_state_task_runs__id__set_state_post;
    xPrefectApiVersion?: string;
};

export type PostTaskRunsByIdSetStateResponse = OrchestrationResult;

export type PostUiTaskRunsDashboardCountsData = {
    requestBody: Body_read_dashboard_task_run_counts_ui_task_runs_dashboard_counts_post;
    xPrefectApiVersion?: string;
};

export type PostUiTaskRunsDashboardCountsResponse = Array<TaskRunCount>;

export type PostUiTaskRunsCountData = {
    requestBody?: Body_read_task_run_counts_by_state_ui_task_runs_count_post;
    xPrefectApiVersion?: string;
};

export type PostUiTaskRunsCountResponse = CountByState;

export type GetFlowRunStatesByIdData = {
    /**
     * The flow run state id
     */
    id: string;
    xPrefectApiVersion?: string;
};

export type GetFlowRunStatesByIdResponse = State;

export type GetFlowRunStatesData = {
    flowRunId: string;
    xPrefectApiVersion?: string;
};

export type GetFlowRunStatesResponse = Array<State>;

export type GetTaskRunStatesByIdData = {
    /**
     * The task run state id
     */
    id: string;
    xPrefectApiVersion?: string;
};

export type GetTaskRunStatesByIdResponse = State;

export type GetTaskRunStatesData = {
    taskRunId: string;
    xPrefectApiVersion?: string;
};

export type GetTaskRunStatesResponse = Array<State>;

export type PostFlowRunNotificationPoliciesData = {
    requestBody: FlowRunNotificationPolicyCreate;
    xPrefectApiVersion?: string;
};

export type PostFlowRunNotificationPoliciesResponse = FlowRunNotificationPolicy;

export type PatchFlowRunNotificationPoliciesByIdData = {
    /**
     * The flow run notification policy id
     */
    id: string;
    requestBody: FlowRunNotificationPolicyUpdate;
    xPrefectApiVersion?: string;
};

export type PatchFlowRunNotificationPoliciesByIdResponse = void;

export type GetFlowRunNotificationPoliciesByIdData = {
    /**
     * The flow run notification policy id
     */
    id: string;
    xPrefectApiVersion?: string;
};

export type GetFlowRunNotificationPoliciesByIdResponse = FlowRunNotificationPolicy;

export type DeleteFlowRunNotificationPoliciesByIdData = {
    /**
     * The flow run notification policy id
     */
    id: string;
    xPrefectApiVersion?: string;
};

export type DeleteFlowRunNotificationPoliciesByIdResponse = void;

export type PostFlowRunNotificationPoliciesFilterData = {
    requestBody?: Body_read_flow_run_notification_policies_flow_run_notification_policies_filter_post;
    xPrefectApiVersion?: string;
};

export type PostFlowRunNotificationPoliciesFilterResponse = Array<FlowRunNotificationPolicy>;

export type PostDeploymentsData = {
    requestBody: DeploymentCreate;
    xPrefectApiVersion?: string;
};

export type PostDeploymentsResponse = DeploymentResponse;

export type PatchDeploymentsByIdData = {
    /**
     * The deployment id
     */
    id: string;
    requestBody: DeploymentUpdate;
    xPrefectApiVersion?: string;
};

export type PatchDeploymentsByIdResponse = void;

export type GetDeploymentsByIdData = {
    /**
     * The deployment id
     */
    id: string;
    xPrefectApiVersion?: string;
};

export type GetDeploymentsByIdResponse = DeploymentResponse;

export type DeleteDeploymentsByIdData = {
    /**
     * The deployment id
     */
    id: string;
    xPrefectApiVersion?: string;
};

export type DeleteDeploymentsByIdResponse = void;

export type GetDeploymentsNameByFlowNameByDeploymentNameData = {
    /**
     * The name of the deployment
     */
    deploymentName: string;
    /**
     * The name of the flow
     */
    flowName: string;
    xPrefectApiVersion?: string;
};

export type GetDeploymentsNameByFlowNameByDeploymentNameResponse = DeploymentResponse;

export type PostDeploymentsFilterData = {
    requestBody?: Body_read_deployments_deployments_filter_post;
    xPrefectApiVersion?: string;
};

export type PostDeploymentsFilterResponse = Array<DeploymentResponse>;

export type PostDeploymentsPaginateData = {
    requestBody?: Body_paginate_deployments_deployments_paginate_post;
    xPrefectApiVersion?: string;
};

export type PostDeploymentsPaginateResponse = DeploymentPaginationResponse;

export type PostDeploymentsGetScheduledFlowRunsData = {
    requestBody: Body_get_scheduled_flow_runs_for_deployments_deployments_get_scheduled_flow_runs_post;
    xPrefectApiVersion?: string;
};

export type PostDeploymentsGetScheduledFlowRunsResponse = Array<FlowRunResponse>;

export type PostDeploymentsCountData = {
    requestBody?: Body_count_deployments_deployments_count_post;
    xPrefectApiVersion?: string;
};

export type PostDeploymentsCountResponse = number;

export type PostDeploymentsByIdScheduleData = {
    /**
     * The deployment id
     */
    id: string;
    requestBody?: Body_schedule_deployment_deployments__id__schedule_post;
    xPrefectApiVersion?: string;
};

export type PostDeploymentsByIdScheduleResponse = unknown;

export type PostDeploymentsByIdResumeDeploymentData = {
    /**
     * The deployment id
     */
    id: string;
    xPrefectApiVersion?: string;
};

export type PostDeploymentsByIdResumeDeploymentResponse = unknown;

export type PostDeploymentsByIdPauseDeploymentData = {
    /**
     * The deployment id
     */
    id: string;
    xPrefectApiVersion?: string;
};

export type PostDeploymentsByIdPauseDeploymentResponse = unknown;

export type PostDeploymentsByIdCreateFlowRunData = {
    /**
     * The deployment id
     */
    id: string;
    requestBody: DeploymentFlowRunCreate;
    xPrefectApiVersion?: string;
};

export type PostDeploymentsByIdCreateFlowRunResponse = FlowRunResponse;

export type GetDeploymentsByIdWorkQueueCheckData = {
    /**
     * The deployment id
     */
    id: string;
    xPrefectApiVersion?: string;
};

export type GetDeploymentsByIdWorkQueueCheckResponse = Array<WorkQueue>;

export type GetDeploymentsByIdSchedulesData = {
    /**
     * The deployment id
     */
    id: string;
    xPrefectApiVersion?: string;
};

export type GetDeploymentsByIdSchedulesResponse = Array<DeploymentSchedule>;

export type PostDeploymentsByIdSchedulesData = {
    /**
     * The deployment id
     */
    id: string;
    requestBody: Array<DeploymentScheduleCreate>;
    xPrefectApiVersion?: string;
};

export type PostDeploymentsByIdSchedulesResponse = Array<DeploymentSchedule>;

export type PatchDeploymentsByIdSchedulesByScheduleIdData = {
    /**
     * The deployment id
     */
    id: string;
    requestBody: DeploymentScheduleUpdate;
    /**
     * The schedule id
     */
    scheduleId: string;
    xPrefectApiVersion?: string;
};

export type PatchDeploymentsByIdSchedulesByScheduleIdResponse = void;

export type DeleteDeploymentsByIdSchedulesByScheduleIdData = {
    /**
     * The deployment id
     */
    id: string;
    /**
     * The schedule id
     */
    scheduleId: string;
    xPrefectApiVersion?: string;
};

export type DeleteDeploymentsByIdSchedulesByScheduleIdResponse = void;

export type PutSavedSearchesData = {
    requestBody: SavedSearchCreate;
    xPrefectApiVersion?: string;
};

export type PutSavedSearchesResponse = SavedSearch;

export type GetSavedSearchesByIdData = {
    /**
     * The saved search id
     */
    id: string;
    xPrefectApiVersion?: string;
};

export type GetSavedSearchesByIdResponse = SavedSearch;

export type DeleteSavedSearchesByIdData = {
    /**
     * The saved search id
     */
    id: string;
    xPrefectApiVersion?: string;
};

export type DeleteSavedSearchesByIdResponse = void;

export type PostSavedSearchesFilterData = {
    requestBody?: Body_read_saved_searches_saved_searches_filter_post;
    xPrefectApiVersion?: string;
};

export type PostSavedSearchesFilterResponse = Array<SavedSearch>;

export type PostLogsData = {
    requestBody: Array<LogCreate>;
    xPrefectApiVersion?: string;
};

export type PostLogsResponse = unknown;

export type PostLogsFilterData = {
    requestBody?: Body_read_logs_logs_filter_post;
    xPrefectApiVersion?: string;
};

export type PostLogsFilterResponse = Array<Log>;

export type PostConcurrencyLimitsData = {
    requestBody: ConcurrencyLimitCreate;
    xPrefectApiVersion?: string;
};

export type PostConcurrencyLimitsResponse = ConcurrencyLimit;

export type GetConcurrencyLimitsByIdData = {
    /**
     * The concurrency limit id
     */
    id: string;
    xPrefectApiVersion?: string;
};

export type GetConcurrencyLimitsByIdResponse = ConcurrencyLimit;

export type DeleteConcurrencyLimitsByIdData = {
    /**
     * The concurrency limit id
     */
    id: string;
    xPrefectApiVersion?: string;
};

export type DeleteConcurrencyLimitsByIdResponse = unknown;

export type GetConcurrencyLimitsTagByTagData = {
    /**
     * The tag name
     */
    tag: string;
    xPrefectApiVersion?: string;
};

export type GetConcurrencyLimitsTagByTagResponse = ConcurrencyLimit;

export type DeleteConcurrencyLimitsTagByTagData = {
    /**
     * The tag name
     */
    tag: string;
    xPrefectApiVersion?: string;
};

export type DeleteConcurrencyLimitsTagByTagResponse = unknown;

export type PostConcurrencyLimitsFilterData = {
    requestBody?: Body_read_concurrency_limits_concurrency_limits_filter_post;
    xPrefectApiVersion?: string;
};

export type PostConcurrencyLimitsFilterResponse = Array<ConcurrencyLimit>;

export type PostConcurrencyLimitsTagByTagResetData = {
    requestBody?: Body_reset_concurrency_limit_by_tag_concurrency_limits_tag__tag__reset_post;
    /**
     * The tag name
     */
    tag: string;
    xPrefectApiVersion?: string;
};

export type PostConcurrencyLimitsTagByTagResetResponse = unknown;

export type PostConcurrencyLimitsIncrementData = {
    requestBody: Body_increment_concurrency_limits_v1_concurrency_limits_increment_post;
    xPrefectApiVersion?: string;
};

export type PostConcurrencyLimitsIncrementResponse = Array<MinimalConcurrencyLimitResponse>;

export type PostConcurrencyLimitsDecrementData = {
    requestBody: Body_decrement_concurrency_limits_v1_concurrency_limits_decrement_post;
    xPrefectApiVersion?: string;
};

export type PostConcurrencyLimitsDecrementResponse = unknown;

export type PostV2ConcurrencyLimitsData = {
    requestBody: ConcurrencyLimitV2Create;
    xPrefectApiVersion?: string;
};

export type PostV2ConcurrencyLimitsResponse = ConcurrencyLimitV2;

export type GetV2ConcurrencyLimitsByIdOrNameData = {
    /**
     * The ID or name of the concurrency limit
     */
    idOrName: string;
    xPrefectApiVersion?: string;
};

export type GetV2ConcurrencyLimitsByIdOrNameResponse = GlobalConcurrencyLimitResponse;

export type PatchV2ConcurrencyLimitsByIdOrNameData = {
    /**
     * The ID or name of the concurrency limit
     */
    idOrName: string;
    requestBody: ConcurrencyLimitV2Update;
    xPrefectApiVersion?: string;
};

export type PatchV2ConcurrencyLimitsByIdOrNameResponse = void;

export type DeleteV2ConcurrencyLimitsByIdOrNameData = {
    /**
     * The ID or name of the concurrency limit
     */
    idOrName: string;
    xPrefectApiVersion?: string;
};

export type DeleteV2ConcurrencyLimitsByIdOrNameResponse = void;

export type PostV2ConcurrencyLimitsFilterData = {
    requestBody?: Body_read_all_concurrency_limits_v2_v2_concurrency_limits_filter_post;
    xPrefectApiVersion?: string;
};

export type PostV2ConcurrencyLimitsFilterResponse = Array<GlobalConcurrencyLimitResponse>;

export type PostV2ConcurrencyLimitsIncrementData = {
    requestBody: Body_bulk_increment_active_slots_v2_concurrency_limits_increment_post;
    xPrefectApiVersion?: string;
};

export type PostV2ConcurrencyLimitsIncrementResponse = Array<MinimalConcurrencyLimitResponse>;

export type PostV2ConcurrencyLimitsDecrementData = {
    requestBody: Body_bulk_decrement_active_slots_v2_concurrency_limits_decrement_post;
    xPrefectApiVersion?: string;
};

export type PostV2ConcurrencyLimitsDecrementResponse = Array<MinimalConcurrencyLimitResponse>;

export type PostBlockTypesData = {
    requestBody: BlockTypeCreate;
    xPrefectApiVersion?: string;
};

export type PostBlockTypesResponse = BlockType;

export type GetBlockTypesByIdData = {
    /**
     * The block type ID
     */
    id: string;
    xPrefectApiVersion?: string;
};

export type GetBlockTypesByIdResponse = BlockType;

export type PatchBlockTypesByIdData = {
    /**
     * The block type ID
     */
    id: string;
    requestBody: BlockTypeUpdate;
    xPrefectApiVersion?: string;
};

export type PatchBlockTypesByIdResponse = void;

export type DeleteBlockTypesByIdData = {
    /**
     * The block type ID
     */
    id: string;
    xPrefectApiVersion?: string;
};

export type DeleteBlockTypesByIdResponse = void;

export type GetBlockTypesSlugBySlugData = {
    /**
     * The block type name
     */
    slug: string;
    xPrefectApiVersion?: string;
};

export type GetBlockTypesSlugBySlugResponse = BlockType;

export type PostBlockTypesFilterData = {
    requestBody?: Body_read_block_types_block_types_filter_post;
    xPrefectApiVersion?: string;
};

export type PostBlockTypesFilterResponse = Array<BlockType>;

export type GetBlockTypesSlugBySlugBlockDocumentsData = {
    /**
     * Whether to include sensitive values in the block document.
     */
    includeSecrets?: boolean;
    /**
     * The block type name
     */
    slug: string;
    xPrefectApiVersion?: string;
};

export type GetBlockTypesSlugBySlugBlockDocumentsResponse = Array<BlockDocument>;

export type GetBlockTypesSlugBySlugBlockDocumentsNameByBlockDocumentNameData = {
    /**
     * The block type name
     */
    blockDocumentName: string;
    /**
     * Whether to include sensitive values in the block document.
     */
    includeSecrets?: boolean;
    /**
     * The block type name
     */
    slug: string;
    xPrefectApiVersion?: string;
};

export type GetBlockTypesSlugBySlugBlockDocumentsNameByBlockDocumentNameResponse = BlockDocument;

export type PostBlockTypesInstallSystemBlockTypesData = {
    xPrefectApiVersion?: string;
};

export type PostBlockTypesInstallSystemBlockTypesResponse = unknown;

export type PostBlockDocumentsData = {
    requestBody: BlockDocumentCreate;
    xPrefectApiVersion?: string;
};

export type PostBlockDocumentsResponse = BlockDocument;

export type PostBlockDocumentsFilterData = {
    requestBody?: Body_read_block_documents_block_documents_filter_post;
    xPrefectApiVersion?: string;
};

export type PostBlockDocumentsFilterResponse = Array<BlockDocument>;

export type PostBlockDocumentsCountData = {
    requestBody?: Body_count_block_documents_block_documents_count_post;
    xPrefectApiVersion?: string;
};

export type PostBlockDocumentsCountResponse = number;

export type GetBlockDocumentsByIdData = {
    /**
     * The block document id
     */
    id: string;
    /**
     * Whether to include sensitive values in the block document.
     */
    includeSecrets?: boolean;
    xPrefectApiVersion?: string;
};

export type GetBlockDocumentsByIdResponse = BlockDocument;

export type DeleteBlockDocumentsByIdData = {
    /**
     * The block document id
     */
    id: string;
    xPrefectApiVersion?: string;
};

export type DeleteBlockDocumentsByIdResponse = void;

export type PatchBlockDocumentsByIdData = {
    /**
     * The block document id
     */
    id: string;
    requestBody: BlockDocumentUpdate;
    xPrefectApiVersion?: string;
};

export type PatchBlockDocumentsByIdResponse = void;

export type PostWorkPoolsData = {
    requestBody: WorkPoolCreate;
    xPrefectApiVersion?: string;
};

export type PostWorkPoolsResponse = WorkPool;

export type GetWorkPoolsByNameData = {
    /**
     * The work pool name
     */
    name: string;
    xPrefectApiVersion?: string;
};

export type GetWorkPoolsByNameResponse = WorkPool;

export type PatchWorkPoolsByNameData = {
    /**
     * The work pool name
     */
    name: string;
    requestBody: WorkPoolUpdate;
    xPrefectApiVersion?: string;
};

export type PatchWorkPoolsByNameResponse = void;

export type DeleteWorkPoolsByNameData = {
    /**
     * The work pool name
     */
    name: string;
    xPrefectApiVersion?: string;
};

export type DeleteWorkPoolsByNameResponse = void;

export type PostWorkPoolsFilterData = {
    requestBody?: Body_read_work_pools_work_pools_filter_post;
    xPrefectApiVersion?: string;
};

export type PostWorkPoolsFilterResponse = Array<WorkPool>;

export type PostWorkPoolsCountData = {
    requestBody?: Body_count_work_pools_work_pools_count_post;
    xPrefectApiVersion?: string;
};

export type PostWorkPoolsCountResponse = number;

export type PostWorkPoolsByNameGetScheduledFlowRunsData = {
    /**
     * The work pool name
     */
    name: string;
    requestBody?: Body_get_scheduled_flow_runs_work_pools__name__get_scheduled_flow_runs_post;
    xPrefectApiVersion?: string;
};

export type PostWorkPoolsByNameGetScheduledFlowRunsResponse = Array<WorkerFlowRunResponse>;

export type PostWorkPoolsByWorkPoolNameQueuesData = {
    requestBody: WorkQueueCreate;
    /**
     * The work pool name
     */
    workPoolName: string;
    xPrefectApiVersion?: string;
};

export type PostWorkPoolsByWorkPoolNameQueuesResponse = WorkQueueResponse;

export type GetWorkPoolsByWorkPoolNameQueuesByNameData = {
    /**
     * The work pool queue name
     */
    name: string;
    /**
     * The work pool name
     */
    workPoolName: string;
    xPrefectApiVersion?: string;
};

export type GetWorkPoolsByWorkPoolNameQueuesByNameResponse = WorkQueueResponse;

export type PatchWorkPoolsByWorkPoolNameQueuesByNameData = {
    /**
     * The work pool queue name
     */
    name: string;
    requestBody: WorkQueueUpdate;
    /**
     * The work pool name
     */
    workPoolName: string;
    xPrefectApiVersion?: string;
};

export type PatchWorkPoolsByWorkPoolNameQueuesByNameResponse = void;

export type DeleteWorkPoolsByWorkPoolNameQueuesByNameData = {
    /**
     * The work pool queue name
     */
    name: string;
    /**
     * The work pool name
     */
    workPoolName: string;
    xPrefectApiVersion?: string;
};

export type DeleteWorkPoolsByWorkPoolNameQueuesByNameResponse = void;

export type PostWorkPoolsByWorkPoolNameQueuesFilterData = {
    requestBody?: Body_read_work_queues_work_pools__work_pool_name__queues_filter_post;
    /**
     * The work pool name
     */
    workPoolName: string;
    xPrefectApiVersion?: string;
};

export type PostWorkPoolsByWorkPoolNameQueuesFilterResponse = Array<WorkQueueResponse>;

export type PostWorkPoolsByWorkPoolNameWorkersHeartbeatData = {
    requestBody: Body_worker_heartbeat_work_pools__work_pool_name__workers_heartbeat_post;
    /**
     * The work pool name
     */
    workPoolName: string;
    xPrefectApiVersion?: string;
};

export type PostWorkPoolsByWorkPoolNameWorkersHeartbeatResponse = void;

export type PostWorkPoolsByWorkPoolNameWorkersFilterData = {
    requestBody?: Body_read_workers_work_pools__work_pool_name__workers_filter_post;
    /**
     * The work pool name
     */
    workPoolName: string;
    xPrefectApiVersion?: string;
};

export type PostWorkPoolsByWorkPoolNameWorkersFilterResponse = Array<WorkerResponse>;

export type DeleteWorkPoolsByWorkPoolNameWorkersByNameData = {
    /**
     * The work pool's worker name
     */
    name: string;
    /**
     * The work pool name
     */
    workPoolName: string;
    xPrefectApiVersion?: string;
};

export type DeleteWorkPoolsByWorkPoolNameWorkersByNameResponse = void;

export type PostTaskWorkersFilterData = {
    requestBody?: Body_read_task_workers_task_workers_filter_post;
    xPrefectApiVersion?: string;
};

export type PostTaskWorkersFilterResponse = Array<TaskWorkerResponse>;

export type PostWorkQueuesData = {
    requestBody: WorkQueueCreate;
    xPrefectApiVersion?: string;
};

export type PostWorkQueuesResponse = WorkQueueResponse;

export type PatchWorkQueuesByIdData = {
    /**
     * The work queue id
     */
    id: string;
    requestBody: WorkQueueUpdate;
    xPrefectApiVersion?: string;
};

export type PatchWorkQueuesByIdResponse = void;

export type GetWorkQueuesByIdData = {
    /**
     * The work queue id
     */
    id: string;
    xPrefectApiVersion?: string;
};

export type GetWorkQueuesByIdResponse = WorkQueueResponse;

export type DeleteWorkQueuesByIdData = {
    /**
     * The work queue id
     */
    id: string;
    xPrefectApiVersion?: string;
};

export type DeleteWorkQueuesByIdResponse = void;

export type GetWorkQueuesNameByNameData = {
    /**
     * The work queue name
     */
    name: string;
    xPrefectApiVersion?: string;
};

export type GetWorkQueuesNameByNameResponse = WorkQueueResponse;

export type PostWorkQueuesByIdGetRunsData = {
    /**
     * The work queue id
     */
    id: string;
    requestBody?: Body_read_work_queue_runs_work_queues__id__get_runs_post;
    xPrefectApiVersion?: string;
    /**
     * A header to indicate this request came from the Prefect UI.
     */
    xPrefectUi?: boolean | null;
};

export type PostWorkQueuesByIdGetRunsResponse = Array<FlowRunResponse>;

export type PostWorkQueuesFilterData = {
    requestBody?: Body_read_work_queues_work_queues_filter_post;
    xPrefectApiVersion?: string;
};

export type PostWorkQueuesFilterResponse = Array<WorkQueueResponse>;

export type GetWorkQueuesByIdStatusData = {
    /**
     * The work queue id
     */
    id: string;
    xPrefectApiVersion?: string;
};

export type GetWorkQueuesByIdStatusResponse = WorkQueueStatusDetail;

export type PostArtifactsData = {
    requestBody: ArtifactCreate;
    xPrefectApiVersion?: string;
};

export type PostArtifactsResponse = Artifact;

export type GetArtifactsByIdData = {
    /**
     * The ID of the artifact to retrieve.
     */
    id: string;
    xPrefectApiVersion?: string;
};

export type GetArtifactsByIdResponse = Artifact;

export type PatchArtifactsByIdData = {
    /**
     * The ID of the artifact to update.
     */
    id: string;
    requestBody: ArtifactUpdate;
    xPrefectApiVersion?: string;
};

export type PatchArtifactsByIdResponse = void;

export type DeleteArtifactsByIdData = {
    /**
     * The ID of the artifact to delete.
     */
    id: string;
    xPrefectApiVersion?: string;
};

export type DeleteArtifactsByIdResponse = void;

export type GetArtifactsByKeyLatestData = {
    /**
     * The key of the artifact to retrieve.
     */
    key: string;
    xPrefectApiVersion?: string;
};

export type GetArtifactsByKeyLatestResponse = Artifact;

export type PostArtifactsFilterData = {
    requestBody?: Body_read_artifacts_artifacts_filter_post;
    xPrefectApiVersion?: string;
};

export type PostArtifactsFilterResponse = Array<Artifact>;

export type PostArtifactsLatestFilterData = {
    requestBody?: Body_read_latest_artifacts_artifacts_latest_filter_post;
    xPrefectApiVersion?: string;
};

export type PostArtifactsLatestFilterResponse = Array<ArtifactCollection>;

export type PostArtifactsCountData = {
    requestBody?: Body_count_artifacts_artifacts_count_post;
    xPrefectApiVersion?: string;
};

export type PostArtifactsCountResponse = number;

export type PostArtifactsLatestCountData = {
    requestBody?: Body_count_latest_artifacts_artifacts_latest_count_post;
    xPrefectApiVersion?: string;
};

export type PostArtifactsLatestCountResponse = number;

export type PostBlockSchemasData = {
    requestBody: BlockSchemaCreate;
    xPrefectApiVersion?: string;
};

export type PostBlockSchemasResponse = BlockSchema;

export type DeleteBlockSchemasByIdData = {
    /**
     * The block schema id
     */
    id: string;
    xPrefectApiVersion?: string;
};

export type DeleteBlockSchemasByIdResponse = void;

export type GetBlockSchemasByIdData = {
    /**
     * The block schema id
     */
    id: string;
    xPrefectApiVersion?: string;
};

export type GetBlockSchemasByIdResponse = BlockSchema;

export type PostBlockSchemasFilterData = {
    requestBody?: Body_read_block_schemas_block_schemas_filter_post;
    xPrefectApiVersion?: string;
};

export type PostBlockSchemasFilterResponse = Array<BlockSchema>;

export type GetBlockSchemasChecksumByChecksumData = {
    /**
     * The block schema checksum
     */
    checksum: string;
    /**
     * Version of block schema. If not provided the most recently created block schema with the matching checksum will be returned.
     */
    version?: string | null;
    xPrefectApiVersion?: string;
};

export type GetBlockSchemasChecksumByChecksumResponse = BlockSchema;

export type GetBlockCapabilitiesData = {
    xPrefectApiVersion?: string;
};

export type GetBlockCapabilitiesResponse = Array<(string)>;

export type GetCollectionsViewsByViewData = {
    view: string;
    xPrefectApiVersion?: string;
};

export type GetCollectionsViewsByViewResponse = {
    [key: string]: unknown;
};

export type PostVariablesData = {
    requestBody: VariableCreate;
    xPrefectApiVersion?: string;
};

export type PostVariablesResponse = Variable;

export type GetVariablesByIdData = {
    id: string;
    xPrefectApiVersion?: string;
};

export type GetVariablesByIdResponse = Variable;

export type PatchVariablesByIdData = {
    id: string;
    requestBody: VariableUpdate;
    xPrefectApiVersion?: string;
};

export type PatchVariablesByIdResponse = void;

export type DeleteVariablesByIdData = {
    id: string;
    xPrefectApiVersion?: string;
};

export type DeleteVariablesByIdResponse = void;

export type GetVariablesNameByNameData = {
    name: string;
    xPrefectApiVersion?: string;
};

export type GetVariablesNameByNameResponse = Variable;

export type PatchVariablesNameByNameData = {
    name: string;
    requestBody: VariableUpdate;
    xPrefectApiVersion?: string;
};

export type PatchVariablesNameByNameResponse = void;

export type DeleteVariablesNameByNameData = {
    name: string;
    xPrefectApiVersion?: string;
};

export type DeleteVariablesNameByNameResponse = void;

export type PostVariablesFilterData = {
    requestBody?: Body_read_variables_variables_filter_post;
    xPrefectApiVersion?: string;
};

export type PostVariablesFilterResponse = Array<Variable>;

export type PostVariablesCountData = {
    requestBody?: Body_count_variables_variables_count_post;
    xPrefectApiVersion?: string;
};

export type PostVariablesCountResponse = number;

export type GetCsrfTokenData = {
    /**
     * The client to create a CSRF token for
     */
    client: string;
    xPrefectApiVersion?: string;
};

export type GetCsrfTokenResponse = CsrfToken;

export type PostEventsData = {
    requestBody: Array<Event>;
    xPrefectApiVersion?: string;
};

export type PostEventsResponse = void;

export type PostEventsFilterData = {
    requestBody?: Body_read_events_events_filter_post;
    xPrefectApiVersion?: string;
};

export type PostEventsFilterResponse = EventPage;

export type GetEventsFilterNextData = {
    pageToken: string;
    xPrefectApiVersion?: string;
};

export type GetEventsFilterNextResponse = EventPage;

export type PostEventsCountByByCountableData = {
    countable: Countable;
    requestBody: Body_count_account_events_events_count_by__countable__post;
    xPrefectApiVersion?: string;
};

export type PostEventsCountByByCountableResponse = Array<EventCount>;

export type PostAutomationsData = {
    requestBody: AutomationCreate;
    xPrefectApiVersion?: string;
};

export type PostAutomationsResponse = Automation;

export type PutAutomationsByIdData = {
    id: string;
    requestBody: AutomationUpdate;
    xPrefectApiVersion?: string;
};

export type PutAutomationsByIdResponse = void;

export type PatchAutomationsByIdData = {
    id: string;
    requestBody: AutomationPartialUpdate;
    xPrefectApiVersion?: string;
};

export type PatchAutomationsByIdResponse = void;

export type DeleteAutomationsByIdData = {
    id: string;
    xPrefectApiVersion?: string;
};

export type DeleteAutomationsByIdResponse = void;

export type GetAutomationsByIdData = {
    id: string;
    xPrefectApiVersion?: string;
};

export type GetAutomationsByIdResponse = Automation;

export type PostAutomationsFilterData = {
    requestBody?: Body_read_automations_automations_filter_post;
    xPrefectApiVersion?: string;
};

export type PostAutomationsFilterResponse = Array<Automation>;

export type PostAutomationsCountData = {
    xPrefectApiVersion?: string;
};

export type PostAutomationsCountResponse = number;

export type GetAutomationsRelatedToByResourceIdData = {
    resourceId: string;
    xPrefectApiVersion?: string;
};

export type GetAutomationsRelatedToByResourceIdResponse = Array<Automation>;

export type DeleteAutomationsOwnedByByResourceIdData = {
    resourceId: string;
    xPrefectApiVersion?: string;
};

export type DeleteAutomationsOwnedByByResourceIdResponse = unknown;

export type PostTemplatesValidateData = {
    requestBody?: string;
    xPrefectApiVersion?: string;
};

export type PostTemplatesValidateResponse = unknown;

export type PostUiSchemasValidateData = {
    requestBody: Body_validate_obj_ui_schemas_validate_post;
    xPrefectApiVersion?: string;
};

export type PostUiSchemasValidateResponse = {
    [key: string]: unknown;
};

export type GetAdminSettingsData = {
    xPrefectApiVersion?: string;
};

export type GetAdminSettingsResponse = Settings;

export type GetAdminVersionData = {
    xPrefectApiVersion?: string;
};

export type GetAdminVersionResponse = string;

export type PostAdminDatabaseClearData = {
    requestBody?: Body_clear_database_admin_database_clear_post;
    xPrefectApiVersion?: string;
};

export type PostAdminDatabaseClearResponse = void;

export type PostAdminDatabaseDropData = {
    requestBody?: Body_drop_database_admin_database_drop_post;
    xPrefectApiVersion?: string;
};

export type PostAdminDatabaseDropResponse = void;

export type PostAdminDatabaseCreateData = {
    requestBody?: Body_create_database_admin_database_create_post;
    xPrefectApiVersion?: string;
};

export type PostAdminDatabaseCreateResponse = void;

export type $OpenApiTs = {
    '/health': {
        get: {
            res: {
                /**
                 * Successful Response
                 */
                200: boolean;
            };
        };
    };
    '/version': {
        get: {
            res: {
                /**
                 * Successful Response
                 */
                200: string;
            };
        };
    };
    '/hello': {
        get: {
            req: GetHelloData;
            res: {
                /**
                 * Successful Response
                 */
                200: string;
                /**
                 * Validation Error
                 */
                422: HTTPValidationError;
            };
        };
    };
    '/ready': {
        get: {
            req: GetReadyData;
            res: {
                /**
                 * Successful Response
                 */
                200: unknown;
                /**
                 * Validation Error
                 */
                422: HTTPValidationError;
            };
        };
    };
    '/flows/': {
        post: {
            req: PostFlowsData;
            res: {
                /**
                 * Successful Response
                 */
                200: Flow;
                /**
                 * Validation Error
                 */
                422: HTTPValidationError;
            };
        };
    };
    '/flows/{id}': {
        patch: {
            req: PatchFlowsByIdData;
            res: {
                /**
                 * Successful Response
                 */
                204: void;
                /**
                 * Validation Error
                 */
                422: HTTPValidationError;
            };
        };
        get: {
            req: GetFlowsByIdData;
            res: {
                /**
                 * Successful Response
                 */
                200: Flow;
                /**
                 * Validation Error
                 */
                422: HTTPValidationError;
            };
        };
        delete: {
            req: DeleteFlowsByIdData;
            res: {
                /**
                 * Successful Response
                 */
                204: void;
                /**
                 * Validation Error
                 */
                422: HTTPValidationError;
            };
        };
    };
    '/flows/count': {
        post: {
            req: PostFlowsCountData;
            res: {
                /**
                 * Successful Response
                 */
                200: number;
                /**
                 * Validation Error
                 */
                422: HTTPValidationError;
            };
        };
    };
    '/flows/name/{name}': {
        get: {
            req: GetFlowsNameByNameData;
            res: {
                /**
                 * Successful Response
                 */
                200: Flow;
                /**
                 * Validation Error
                 */
                422: HTTPValidationError;
            };
        };
    };
    '/flows/filter': {
        post: {
            req: PostFlowsFilterData;
            res: {
                /**
                 * Successful Response
                 */
                200: Array<Flow>;
                /**
                 * Validation Error
                 */
                422: HTTPValidationError;
            };
        };
    };
    '/flows/paginate': {
        post: {
            req: PostFlowsPaginateData;
            res: {
                /**
                 * Successful Response
                 */
                200: FlowPaginationResponse;
                /**
                 * Validation Error
                 */
                422: HTTPValidationError;
            };
        };
    };
    '/ui/flows/count-deployments': {
        post: {
            req: PostUiFlowsCountDeploymentsData;
            res: {
                /**
                 * Successful Response
                 */
                200: {
                    [key: string]: (number);
                };
                /**
                 * Validation Error
                 */
                422: HTTPValidationError;
            };
        };
    };
    '/ui/flows/next-runs': {
        post: {
            req: PostUiFlowsNextRunsData;
            res: {
                /**
                 * Successful Response
                 */
                200: {
                    [key: string]: (SimpleNextFlowRun | null);
                };
                /**
                 * Validation Error
                 */
                422: HTTPValidationError;
            };
        };
    };
    '/flow_runs/': {
        post: {
            req: PostFlowRunsData;
            res: {
                /**
                 * Successful Response
                 */
                200: FlowRunResponse;
                /**
                 * Validation Error
                 */
                422: HTTPValidationError;
            };
        };
    };
    '/flow_runs/{id}': {
        patch: {
            req: PatchFlowRunsByIdData;
            res: {
                /**
                 * Successful Response
                 */
                204: void;
                /**
                 * Validation Error
                 */
                422: HTTPValidationError;
            };
        };
        get: {
            req: GetFlowRunsByIdData;
            res: {
                /**
                 * Successful Response
                 */
                200: FlowRunResponse;
                /**
                 * Validation Error
                 */
                422: HTTPValidationError;
            };
        };
        delete: {
            req: DeleteFlowRunsByIdData;
            res: {
                /**
                 * Successful Response
                 */
                204: void;
                /**
                 * Validation Error
                 */
                422: HTTPValidationError;
            };
        };
    };
    '/flow_runs/count': {
        post: {
            req: PostFlowRunsCountData;
            res: {
                /**
                 * Successful Response
                 */
                200: number;
                /**
                 * Validation Error
                 */
                422: HTTPValidationError;
            };
        };
    };
    '/flow_runs/lateness': {
        post: {
            req: PostFlowRunsLatenessData;
            res: {
                /**
                 * Successful Response
                 */
                200: number | null;
                /**
                 * Validation Error
                 */
                422: HTTPValidationError;
            };
        };
    };
    '/flow_runs/history': {
        post: {
            req: PostFlowRunsHistoryData;
            res: {
                /**
                 * Successful Response
                 */
                200: Array<HistoryResponse>;
                /**
                 * Validation Error
                 */
                422: HTTPValidationError;
            };
        };
    };
    '/flow_runs/{id}/graph': {
        get: {
            req: GetFlowRunsByIdGraphData;
            res: {
                /**
                 * Successful Response
                 */
                200: Array<DependencyResult>;
                /**
                 * Validation Error
                 */
                422: HTTPValidationError;
            };
        };
    };
    '/flow_runs/{id}/graph-v2': {
        get: {
            req: GetFlowRunsByIdGraphV2Data;
            res: {
                /**
                 * Successful Response
                 */
                200: Graph;
                /**
                 * Validation Error
                 */
                422: HTTPValidationError;
            };
        };
    };
    '/flow_runs/{id}/resume': {
        post: {
            req: PostFlowRunsByIdResumeData;
            res: {
                /**
                 * Successful Response
                 */
                200: OrchestrationResult;
                /**
                 * Validation Error
                 */
                422: HTTPValidationError;
            };
        };
    };
    '/flow_runs/filter': {
        post: {
            req: PostFlowRunsFilterData;
            res: {
                /**
                 * Successful Response
                 */
                200: Array<FlowRunResponse>;
                /**
                 * Validation Error
                 */
                422: HTTPValidationError;
            };
        };
    };
    '/flow_runs/{id}/set_state': {
        post: {
            req: PostFlowRunsByIdSetStateData;
            res: {
                /**
                 * Successful Response
                 */
                200: OrchestrationResult;
                /**
                 * Validation Error
                 */
                422: HTTPValidationError;
            };
        };
    };
    '/flow_runs/{id}/input': {
        post: {
            req: PostFlowRunsByIdInputData;
            res: {
                /**
                 * Successful Response
                 */
                201: unknown;
                /**
                 * Validation Error
                 */
                422: HTTPValidationError;
            };
        };
    };
    '/flow_runs/{id}/input/filter': {
        post: {
            req: PostFlowRunsByIdInputFilterData;
            res: {
                /**
                 * Successful Response
                 */
                200: Array<FlowRunInput>;
                /**
                 * Validation Error
                 */
                422: HTTPValidationError;
            };
        };
    };
    '/flow_runs/{id}/input/{key}': {
        get: {
            req: GetFlowRunsByIdInputByKeyData;
            res: {
                /**
                 * Successful Response
                 */
                200: unknown;
                /**
                 * Validation Error
                 */
                422: HTTPValidationError;
            };
        };
        delete: {
            req: DeleteFlowRunsByIdInputByKeyData;
            res: {
                /**
                 * Successful Response
                 */
                204: void;
                /**
                 * Validation Error
                 */
                422: HTTPValidationError;
            };
        };
    };
    '/flow_runs/paginate': {
        post: {
            req: PostFlowRunsPaginateData;
            res: {
                /**
                 * Successful Response
                 */
                200: FlowRunPaginationResponse;
                /**
                 * Validation Error
                 */
                422: HTTPValidationError;
            };
        };
    };
    '/flow_runs/{id}/logs/download': {
        get: {
            req: GetFlowRunsByIdLogsDownloadData;
            res: {
                /**
                 * Successful Response
                 */
                200: unknown;
                /**
                 * Validation Error
                 */
                422: HTTPValidationError;
            };
        };
    };
    '/flow_runs/{id}/labels': {
        patch: {
            req: PatchFlowRunsByIdLabelsData;
            res: {
                /**
                 * Successful Response
                 */
                204: void;
                /**
                 * Validation Error
                 */
                422: HTTPValidationError;
            };
        };
    };
    '/ui/flow_runs/history': {
        post: {
            req: PostUiFlowRunsHistoryData;
            res: {
                /**
                 * Successful Response
                 */
                200: Array<SimpleFlowRun>;
                /**
                 * Validation Error
                 */
                422: HTTPValidationError;
            };
        };
    };
    '/ui/flow_runs/count-task-runs': {
        post: {
            req: PostUiFlowRunsCountTaskRunsData;
            res: {
                /**
                 * Successful Response
                 */
                200: {
                    [key: string]: (number);
                };
                /**
                 * Validation Error
                 */
                422: HTTPValidationError;
            };
        };
    };
    '/task_runs/': {
        post: {
            req: PostTaskRunsData;
            res: {
                /**
                 * Successful Response
                 */
                200: TaskRun;
                /**
                 * Validation Error
                 */
                422: HTTPValidationError;
            };
        };
    };
    '/task_runs/{id}': {
        patch: {
            req: PatchTaskRunsByIdData;
            res: {
                /**
                 * Successful Response
                 */
                204: void;
                /**
                 * Validation Error
                 */
                422: HTTPValidationError;
            };
        };
        get: {
            req: GetTaskRunsByIdData;
            res: {
                /**
                 * Successful Response
                 */
                200: TaskRun;
                /**
                 * Validation Error
                 */
                422: HTTPValidationError;
            };
        };
        delete: {
            req: DeleteTaskRunsByIdData;
            res: {
                /**
                 * Successful Response
                 */
                204: void;
                /**
                 * Validation Error
                 */
                422: HTTPValidationError;
            };
        };
    };
    '/task_runs/count': {
        post: {
            req: PostTaskRunsCountData;
            res: {
                /**
                 * Successful Response
                 */
                200: number;
                /**
                 * Validation Error
                 */
                422: HTTPValidationError;
            };
        };
    };
    '/task_runs/history': {
        post: {
            req: PostTaskRunsHistoryData;
            res: {
                /**
                 * Successful Response
                 */
                200: Array<HistoryResponse>;
                /**
                 * Validation Error
                 */
                422: HTTPValidationError;
            };
        };
    };
    '/task_runs/filter': {
        post: {
            req: PostTaskRunsFilterData;
            res: {
                /**
                 * Successful Response
                 */
                200: Array<TaskRun>;
                /**
                 * Validation Error
                 */
                422: HTTPValidationError;
            };
        };
    };
    '/task_runs/{id}/set_state': {
        post: {
            req: PostTaskRunsByIdSetStateData;
            res: {
                /**
                 * Successful Response
                 */
                200: OrchestrationResult;
                /**
                 * Validation Error
                 */
                422: HTTPValidationError;
            };
        };
    };
    '/ui/task_runs/dashboard/counts': {
        post: {
            req: PostUiTaskRunsDashboardCountsData;
            res: {
                /**
                 * Successful Response
                 */
                200: Array<TaskRunCount>;
                /**
                 * Validation Error
                 */
                422: HTTPValidationError;
            };
        };
    };
    '/ui/task_runs/count': {
        post: {
            req: PostUiTaskRunsCountData;
            res: {
                /**
                 * Successful Response
                 */
                200: CountByState;
                /**
                 * Validation Error
                 */
                422: HTTPValidationError;
            };
        };
    };
    '/flow_run_states/{id}': {
        get: {
            req: GetFlowRunStatesByIdData;
            res: {
                /**
                 * Successful Response
                 */
                200: State;
                /**
                 * Validation Error
                 */
                422: HTTPValidationError;
            };
        };
    };
    '/flow_run_states/': {
        get: {
            req: GetFlowRunStatesData;
            res: {
                /**
                 * Successful Response
                 */
                200: Array<State>;
                /**
                 * Validation Error
                 */
                422: HTTPValidationError;
            };
        };
    };
    '/task_run_states/{id}': {
        get: {
            req: GetTaskRunStatesByIdData;
            res: {
                /**
                 * Successful Response
                 */
                200: State;
                /**
                 * Validation Error
                 */
                422: HTTPValidationError;
            };
        };
    };
    '/task_run_states/': {
        get: {
            req: GetTaskRunStatesData;
            res: {
                /**
                 * Successful Response
                 */
                200: Array<State>;
                /**
                 * Validation Error
                 */
                422: HTTPValidationError;
            };
        };
    };
    '/flow_run_notification_policies/': {
        post: {
            req: PostFlowRunNotificationPoliciesData;
            res: {
                /**
                 * Successful Response
                 */
                201: FlowRunNotificationPolicy;
                /**
                 * Validation Error
                 */
                422: HTTPValidationError;
            };
        };
    };
    '/flow_run_notification_policies/{id}': {
        patch: {
            req: PatchFlowRunNotificationPoliciesByIdData;
            res: {
                /**
                 * Successful Response
                 */
                204: void;
                /**
                 * Validation Error
                 */
                422: HTTPValidationError;
            };
        };
        get: {
            req: GetFlowRunNotificationPoliciesByIdData;
            res: {
                /**
                 * Successful Response
                 */
                200: FlowRunNotificationPolicy;
                /**
                 * Validation Error
                 */
                422: HTTPValidationError;
            };
        };
        delete: {
            req: DeleteFlowRunNotificationPoliciesByIdData;
            res: {
                /**
                 * Successful Response
                 */
                204: void;
                /**
                 * Validation Error
                 */
                422: HTTPValidationError;
            };
        };
    };
    '/flow_run_notification_policies/filter': {
        post: {
            req: PostFlowRunNotificationPoliciesFilterData;
            res: {
                /**
                 * Successful Response
                 */
                200: Array<FlowRunNotificationPolicy>;
                /**
                 * Validation Error
                 */
                422: HTTPValidationError;
            };
        };
    };
    '/deployments/': {
        post: {
            req: PostDeploymentsData;
            res: {
                /**
                 * Successful Response
                 */
                200: DeploymentResponse;
                /**
                 * Validation Error
                 */
                422: HTTPValidationError;
            };
        };
    };
    '/deployments/{id}': {
        patch: {
            req: PatchDeploymentsByIdData;
            res: {
                /**
                 * Successful Response
                 */
                204: void;
                /**
                 * Validation Error
                 */
                422: HTTPValidationError;
            };
        };
        get: {
            req: GetDeploymentsByIdData;
            res: {
                /**
                 * Successful Response
                 */
                200: DeploymentResponse;
                /**
                 * Validation Error
                 */
                422: HTTPValidationError;
            };
        };
        delete: {
            req: DeleteDeploymentsByIdData;
            res: {
                /**
                 * Successful Response
                 */
                204: void;
                /**
                 * Validation Error
                 */
                422: HTTPValidationError;
            };
        };
    };
    '/deployments/name/{flow_name}/{deployment_name}': {
        get: {
            req: GetDeploymentsNameByFlowNameByDeploymentNameData;
            res: {
                /**
                 * Successful Response
                 */
                200: DeploymentResponse;
                /**
                 * Validation Error
                 */
                422: HTTPValidationError;
            };
        };
    };
    '/deployments/filter': {
        post: {
            req: PostDeploymentsFilterData;
            res: {
                /**
                 * Successful Response
                 */
                200: Array<DeploymentResponse>;
                /**
                 * Validation Error
                 */
                422: HTTPValidationError;
            };
        };
    };
    '/deployments/paginate': {
        post: {
            req: PostDeploymentsPaginateData;
            res: {
                /**
                 * Successful Response
                 */
                200: DeploymentPaginationResponse;
                /**
                 * Validation Error
                 */
                422: HTTPValidationError;
            };
        };
    };
    '/deployments/get_scheduled_flow_runs': {
        post: {
            req: PostDeploymentsGetScheduledFlowRunsData;
            res: {
                /**
                 * Successful Response
                 */
                200: Array<FlowRunResponse>;
                /**
                 * Validation Error
                 */
                422: HTTPValidationError;
            };
        };
    };
    '/deployments/count': {
        post: {
            req: PostDeploymentsCountData;
            res: {
                /**
                 * Successful Response
                 */
                200: number;
                /**
                 * Validation Error
                 */
                422: HTTPValidationError;
            };
        };
    };
    '/deployments/{id}/schedule': {
        post: {
            req: PostDeploymentsByIdScheduleData;
            res: {
                /**
                 * Successful Response
                 */
                200: unknown;
                /**
                 * Validation Error
                 */
                422: HTTPValidationError;
            };
        };
    };
    '/deployments/{id}/resume_deployment': {
        post: {
            req: PostDeploymentsByIdResumeDeploymentData;
            res: {
                /**
                 * Successful Response
                 */
                200: unknown;
                /**
                 * Validation Error
                 */
                422: HTTPValidationError;
            };
        };
    };
    '/deployments/{id}/pause_deployment': {
        post: {
            req: PostDeploymentsByIdPauseDeploymentData;
            res: {
                /**
                 * Successful Response
                 */
                200: unknown;
                /**
                 * Validation Error
                 */
                422: HTTPValidationError;
            };
        };
    };
    '/deployments/{id}/create_flow_run': {
        post: {
            req: PostDeploymentsByIdCreateFlowRunData;
            res: {
                /**
                 * Successful Response
                 */
                200: FlowRunResponse;
                /**
                 * Validation Error
                 */
                422: HTTPValidationError;
            };
        };
    };
    '/deployments/{id}/work_queue_check': {
        get: {
            req: GetDeploymentsByIdWorkQueueCheckData;
            res: {
                /**
                 * Successful Response
                 */
                200: Array<WorkQueue>;
                /**
                 * Validation Error
                 */
                422: HTTPValidationError;
            };
        };
    };
    '/deployments/{id}/schedules': {
        get: {
            req: GetDeploymentsByIdSchedulesData;
            res: {
                /**
                 * Successful Response
                 */
                200: Array<DeploymentSchedule>;
                /**
                 * Validation Error
                 */
                422: HTTPValidationError;
            };
        };
        post: {
            req: PostDeploymentsByIdSchedulesData;
            res: {
                /**
                 * Successful Response
                 */
                201: Array<DeploymentSchedule>;
                /**
                 * Validation Error
                 */
                422: HTTPValidationError;
            };
        };
    };
    '/deployments/{id}/schedules/{schedule_id}': {
        patch: {
            req: PatchDeploymentsByIdSchedulesByScheduleIdData;
            res: {
                /**
                 * Successful Response
                 */
                204: void;
                /**
                 * Validation Error
                 */
                422: HTTPValidationError;
            };
        };
        delete: {
            req: DeleteDeploymentsByIdSchedulesByScheduleIdData;
            res: {
                /**
                 * Successful Response
                 */
                204: void;
                /**
                 * Validation Error
                 */
                422: HTTPValidationError;
            };
        };
    };
    '/saved_searches/': {
        put: {
            req: PutSavedSearchesData;
            res: {
                /**
                 * Successful Response
                 */
                200: SavedSearch;
                /**
                 * Validation Error
                 */
                422: HTTPValidationError;
            };
        };
    };
    '/saved_searches/{id}': {
        get: {
            req: GetSavedSearchesByIdData;
            res: {
                /**
                 * Successful Response
                 */
                200: SavedSearch;
                /**
                 * Validation Error
                 */
                422: HTTPValidationError;
            };
        };
        delete: {
            req: DeleteSavedSearchesByIdData;
            res: {
                /**
                 * Successful Response
                 */
                204: void;
                /**
                 * Validation Error
                 */
                422: HTTPValidationError;
            };
        };
    };
    '/saved_searches/filter': {
        post: {
            req: PostSavedSearchesFilterData;
            res: {
                /**
                 * Successful Response
                 */
                200: Array<SavedSearch>;
                /**
                 * Validation Error
                 */
                422: HTTPValidationError;
            };
        };
    };
    '/logs/': {
        post: {
            req: PostLogsData;
            res: {
                /**
                 * Successful Response
                 */
                201: unknown;
                /**
                 * Validation Error
                 */
                422: HTTPValidationError;
            };
        };
    };
    '/logs/filter': {
        post: {
            req: PostLogsFilterData;
            res: {
                /**
                 * Successful Response
                 */
                200: Array<Log>;
                /**
                 * Validation Error
                 */
                422: HTTPValidationError;
            };
        };
    };
    '/concurrency_limits/': {
        post: {
            req: PostConcurrencyLimitsData;
            res: {
                /**
                 * Successful Response
                 */
                200: ConcurrencyLimit;
                /**
                 * Validation Error
                 */
                422: HTTPValidationError;
            };
        };
    };
    '/concurrency_limits/{id}': {
        get: {
            req: GetConcurrencyLimitsByIdData;
            res: {
                /**
                 * Successful Response
                 */
                200: ConcurrencyLimit;
                /**
                 * Validation Error
                 */
                422: HTTPValidationError;
            };
        };
        delete: {
            req: DeleteConcurrencyLimitsByIdData;
            res: {
                /**
                 * Successful Response
                 */
                200: unknown;
                /**
                 * Validation Error
                 */
                422: HTTPValidationError;
            };
        };
    };
    '/concurrency_limits/tag/{tag}': {
        get: {
            req: GetConcurrencyLimitsTagByTagData;
            res: {
                /**
                 * Successful Response
                 */
                200: ConcurrencyLimit;
                /**
                 * Validation Error
                 */
                422: HTTPValidationError;
            };
        };
        delete: {
            req: DeleteConcurrencyLimitsTagByTagData;
            res: {
                /**
                 * Successful Response
                 */
                200: unknown;
                /**
                 * Validation Error
                 */
                422: HTTPValidationError;
            };
        };
    };
    '/concurrency_limits/filter': {
        post: {
            req: PostConcurrencyLimitsFilterData;
            res: {
                /**
                 * Successful Response
                 */
                200: Array<ConcurrencyLimit>;
                /**
                 * Validation Error
                 */
                422: HTTPValidationError;
            };
        };
    };
    '/concurrency_limits/tag/{tag}/reset': {
        post: {
            req: PostConcurrencyLimitsTagByTagResetData;
            res: {
                /**
                 * Successful Response
                 */
                200: unknown;
                /**
                 * Validation Error
                 */
                422: HTTPValidationError;
            };
        };
    };
    '/concurrency_limits/increment': {
        post: {
            req: PostConcurrencyLimitsIncrementData;
            res: {
                /**
                 * Successful Response
                 */
                200: Array<MinimalConcurrencyLimitResponse>;
                /**
                 * Validation Error
                 */
                422: HTTPValidationError;
            };
        };
    };
    '/concurrency_limits/decrement': {
        post: {
            req: PostConcurrencyLimitsDecrementData;
            res: {
                /**
                 * Successful Response
                 */
                200: unknown;
                /**
                 * Validation Error
                 */
                422: HTTPValidationError;
            };
        };
    };
    '/v2/concurrency_limits/': {
        post: {
            req: PostV2ConcurrencyLimitsData;
            res: {
                /**
                 * Successful Response
                 */
                201: ConcurrencyLimitV2;
                /**
                 * Validation Error
                 */
                422: HTTPValidationError;
            };
        };
    };
    '/v2/concurrency_limits/{id_or_name}': {
        get: {
            req: GetV2ConcurrencyLimitsByIdOrNameData;
            res: {
                /**
                 * Successful Response
                 */
                200: GlobalConcurrencyLimitResponse;
                /**
                 * Validation Error
                 */
                422: HTTPValidationError;
            };
        };
        patch: {
            req: PatchV2ConcurrencyLimitsByIdOrNameData;
            res: {
                /**
                 * Successful Response
                 */
                204: void;
                /**
                 * Validation Error
                 */
                422: HTTPValidationError;
            };
        };
        delete: {
            req: DeleteV2ConcurrencyLimitsByIdOrNameData;
            res: {
                /**
                 * Successful Response
                 */
                204: void;
                /**
                 * Validation Error
                 */
                422: HTTPValidationError;
            };
        };
    };
    '/v2/concurrency_limits/filter': {
        post: {
            req: PostV2ConcurrencyLimitsFilterData;
            res: {
                /**
                 * Successful Response
                 */
                200: Array<GlobalConcurrencyLimitResponse>;
                /**
                 * Validation Error
                 */
                422: HTTPValidationError;
            };
        };
    };
    '/v2/concurrency_limits/increment': {
        post: {
            req: PostV2ConcurrencyLimitsIncrementData;
            res: {
                /**
                 * Successful Response
                 */
                200: Array<MinimalConcurrencyLimitResponse>;
                /**
                 * Validation Error
                 */
                422: HTTPValidationError;
            };
        };
    };
    '/v2/concurrency_limits/decrement': {
        post: {
            req: PostV2ConcurrencyLimitsDecrementData;
            res: {
                /**
                 * Successful Response
                 */
                200: Array<MinimalConcurrencyLimitResponse>;
                /**
                 * Validation Error
                 */
                422: HTTPValidationError;
            };
        };
    };
    '/block_types/': {
        post: {
            req: PostBlockTypesData;
            res: {
                /**
                 * Successful Response
                 */
                201: BlockType;
                /**
                 * Validation Error
                 */
                422: HTTPValidationError;
            };
        };
    };
    '/block_types/{id}': {
        get: {
            req: GetBlockTypesByIdData;
            res: {
                /**
                 * Successful Response
                 */
                200: BlockType;
                /**
                 * Validation Error
                 */
                422: HTTPValidationError;
            };
        };
        patch: {
            req: PatchBlockTypesByIdData;
            res: {
                /**
                 * Successful Response
                 */
                204: void;
                /**
                 * Validation Error
                 */
                422: HTTPValidationError;
            };
        };
        delete: {
            req: DeleteBlockTypesByIdData;
            res: {
                /**
                 * Successful Response
                 */
                204: void;
                /**
                 * Validation Error
                 */
                422: HTTPValidationError;
            };
        };
    };
    '/block_types/slug/{slug}': {
        get: {
            req: GetBlockTypesSlugBySlugData;
            res: {
                /**
                 * Successful Response
                 */
                200: BlockType;
                /**
                 * Validation Error
                 */
                422: HTTPValidationError;
            };
        };
    };
    '/block_types/filter': {
        post: {
            req: PostBlockTypesFilterData;
            res: {
                /**
                 * Successful Response
                 */
                200: Array<BlockType>;
                /**
                 * Validation Error
                 */
                422: HTTPValidationError;
            };
        };
    };
    '/block_types/slug/{slug}/block_documents': {
        get: {
            req: GetBlockTypesSlugBySlugBlockDocumentsData;
            res: {
                /**
                 * Successful Response
                 */
                200: Array<BlockDocument>;
                /**
                 * Validation Error
                 */
                422: HTTPValidationError;
            };
        };
    };
    '/block_types/slug/{slug}/block_documents/name/{block_document_name}': {
        get: {
            req: GetBlockTypesSlugBySlugBlockDocumentsNameByBlockDocumentNameData;
            res: {
                /**
                 * Successful Response
                 */
                200: BlockDocument;
                /**
                 * Validation Error
                 */
                422: HTTPValidationError;
            };
        };
    };
    '/block_types/install_system_block_types': {
        post: {
            req: PostBlockTypesInstallSystemBlockTypesData;
            res: {
                /**
                 * Successful Response
                 */
                200: unknown;
                /**
                 * Validation Error
                 */
                422: HTTPValidationError;
            };
        };
    };
    '/block_documents/': {
        post: {
            req: PostBlockDocumentsData;
            res: {
                /**
                 * Successful Response
                 */
                201: BlockDocument;
                /**
                 * Validation Error
                 */
                422: HTTPValidationError;
            };
        };
    };
    '/block_documents/filter': {
        post: {
            req: PostBlockDocumentsFilterData;
            res: {
                /**
                 * Successful Response
                 */
                200: Array<BlockDocument>;
                /**
                 * Validation Error
                 */
                422: HTTPValidationError;
            };
        };
    };
    '/block_documents/count': {
        post: {
            req: PostBlockDocumentsCountData;
            res: {
                /**
                 * Successful Response
                 */
                200: number;
                /**
                 * Validation Error
                 */
                422: HTTPValidationError;
            };
        };
    };
    '/block_documents/{id}': {
        get: {
            req: GetBlockDocumentsByIdData;
            res: {
                /**
                 * Successful Response
                 */
                200: BlockDocument;
                /**
                 * Validation Error
                 */
                422: HTTPValidationError;
            };
        };
        delete: {
            req: DeleteBlockDocumentsByIdData;
            res: {
                /**
                 * Successful Response
                 */
                204: void;
                /**
                 * Validation Error
                 */
                422: HTTPValidationError;
            };
        };
        patch: {
            req: PatchBlockDocumentsByIdData;
            res: {
                /**
                 * Successful Response
                 */
                204: void;
                /**
                 * Validation Error
                 */
                422: HTTPValidationError;
            };
        };
    };
    '/work_pools/': {
        post: {
            req: PostWorkPoolsData;
            res: {
                /**
                 * Successful Response
                 */
                201: WorkPool;
                /**
                 * Validation Error
                 */
                422: HTTPValidationError;
            };
        };
    };
    '/work_pools/{name}': {
        get: {
            req: GetWorkPoolsByNameData;
            res: {
                /**
                 * Successful Response
                 */
                200: WorkPool;
                /**
                 * Validation Error
                 */
                422: HTTPValidationError;
            };
        };
        patch: {
            req: PatchWorkPoolsByNameData;
            res: {
                /**
                 * Successful Response
                 */
                204: void;
                /**
                 * Validation Error
                 */
                422: HTTPValidationError;
            };
        };
        delete: {
            req: DeleteWorkPoolsByNameData;
            res: {
                /**
                 * Successful Response
                 */
                204: void;
                /**
                 * Validation Error
                 */
                422: HTTPValidationError;
            };
        };
    };
    '/work_pools/filter': {
        post: {
            req: PostWorkPoolsFilterData;
            res: {
                /**
                 * Successful Response
                 */
                200: Array<WorkPool>;
                /**
                 * Validation Error
                 */
                422: HTTPValidationError;
            };
        };
    };
    '/work_pools/count': {
        post: {
            req: PostWorkPoolsCountData;
            res: {
                /**
                 * Successful Response
                 */
                200: number;
                /**
                 * Validation Error
                 */
                422: HTTPValidationError;
            };
        };
    };
    '/work_pools/{name}/get_scheduled_flow_runs': {
        post: {
            req: PostWorkPoolsByNameGetScheduledFlowRunsData;
            res: {
                /**
                 * Successful Response
                 */
                200: Array<WorkerFlowRunResponse>;
                /**
                 * Validation Error
                 */
                422: HTTPValidationError;
            };
        };
    };
    '/work_pools/{work_pool_name}/queues': {
        post: {
            req: PostWorkPoolsByWorkPoolNameQueuesData;
            res: {
                /**
                 * Successful Response
                 */
                201: WorkQueueResponse;
                /**
                 * Validation Error
                 */
                422: HTTPValidationError;
            };
        };
    };
    '/work_pools/{work_pool_name}/queues/{name}': {
        get: {
            req: GetWorkPoolsByWorkPoolNameQueuesByNameData;
            res: {
                /**
                 * Successful Response
                 */
                200: WorkQueueResponse;
                /**
                 * Validation Error
                 */
                422: HTTPValidationError;
            };
        };
        patch: {
            req: PatchWorkPoolsByWorkPoolNameQueuesByNameData;
            res: {
                /**
                 * Successful Response
                 */
                204: void;
                /**
                 * Validation Error
                 */
                422: HTTPValidationError;
            };
        };
        delete: {
            req: DeleteWorkPoolsByWorkPoolNameQueuesByNameData;
            res: {
                /**
                 * Successful Response
                 */
                204: void;
                /**
                 * Validation Error
                 */
                422: HTTPValidationError;
            };
        };
    };
    '/work_pools/{work_pool_name}/queues/filter': {
        post: {
            req: PostWorkPoolsByWorkPoolNameQueuesFilterData;
            res: {
                /**
                 * Successful Response
                 */
                200: Array<WorkQueueResponse>;
                /**
                 * Validation Error
                 */
                422: HTTPValidationError;
            };
        };
    };
    '/work_pools/{work_pool_name}/workers/heartbeat': {
        post: {
            req: PostWorkPoolsByWorkPoolNameWorkersHeartbeatData;
            res: {
                /**
                 * Successful Response
                 */
                204: void;
                /**
                 * Validation Error
                 */
                422: HTTPValidationError;
            };
        };
    };
    '/work_pools/{work_pool_name}/workers/filter': {
        post: {
            req: PostWorkPoolsByWorkPoolNameWorkersFilterData;
            res: {
                /**
                 * Successful Response
                 */
                200: Array<WorkerResponse>;
                /**
                 * Validation Error
                 */
                422: HTTPValidationError;
            };
        };
    };
    '/work_pools/{work_pool_name}/workers/{name}': {
        delete: {
            req: DeleteWorkPoolsByWorkPoolNameWorkersByNameData;
            res: {
                /**
                 * Successful Response
                 */
                204: void;
                /**
                 * Validation Error
                 */
                422: HTTPValidationError;
            };
        };
    };
    '/task_workers/filter': {
        post: {
            req: PostTaskWorkersFilterData;
            res: {
                /**
                 * Successful Response
                 */
                200: Array<TaskWorkerResponse>;
                /**
                 * Validation Error
                 */
                422: HTTPValidationError;
            };
        };
    };
    '/work_queues/': {
        post: {
            req: PostWorkQueuesData;
            res: {
                /**
                 * Successful Response
                 */
                201: WorkQueueResponse;
                /**
                 * Validation Error
                 */
                422: HTTPValidationError;
            };
        };
    };
    '/work_queues/{id}': {
        patch: {
            req: PatchWorkQueuesByIdData;
            res: {
                /**
                 * Successful Response
                 */
                204: void;
                /**
                 * Validation Error
                 */
                422: HTTPValidationError;
            };
        };
        get: {
            req: GetWorkQueuesByIdData;
            res: {
                /**
                 * Successful Response
                 */
                200: WorkQueueResponse;
                /**
                 * Validation Error
                 */
                422: HTTPValidationError;
            };
        };
        delete: {
            req: DeleteWorkQueuesByIdData;
            res: {
                /**
                 * Successful Response
                 */
                204: void;
                /**
                 * Validation Error
                 */
                422: HTTPValidationError;
            };
        };
    };
    '/work_queues/name/{name}': {
        get: {
            req: GetWorkQueuesNameByNameData;
            res: {
                /**
                 * Successful Response
                 */
                200: WorkQueueResponse;
                /**
                 * Validation Error
                 */
                422: HTTPValidationError;
            };
        };
    };
    '/work_queues/{id}/get_runs': {
        post: {
            req: PostWorkQueuesByIdGetRunsData;
            res: {
                /**
                 * Successful Response
                 */
                200: Array<FlowRunResponse>;
                /**
                 * Validation Error
                 */
                422: HTTPValidationError;
            };
        };
    };
    '/work_queues/filter': {
        post: {
            req: PostWorkQueuesFilterData;
            res: {
                /**
                 * Successful Response
                 */
                200: Array<WorkQueueResponse>;
                /**
                 * Validation Error
                 */
                422: HTTPValidationError;
            };
        };
    };
    '/work_queues/{id}/status': {
        get: {
            req: GetWorkQueuesByIdStatusData;
            res: {
                /**
                 * Successful Response
                 */
                200: WorkQueueStatusDetail;
                /**
                 * Validation Error
                 */
                422: HTTPValidationError;
            };
        };
    };
    '/artifacts/': {
        post: {
            req: PostArtifactsData;
            res: {
                /**
                 * Successful Response
                 */
                200: Artifact;
                /**
                 * Validation Error
                 */
                422: HTTPValidationError;
            };
        };
    };
    '/artifacts/{id}': {
        get: {
            req: GetArtifactsByIdData;
            res: {
                /**
                 * Successful Response
                 */
                200: Artifact;
                /**
                 * Validation Error
                 */
                422: HTTPValidationError;
            };
        };
        patch: {
            req: PatchArtifactsByIdData;
            res: {
                /**
                 * Successful Response
                 */
                204: void;
                /**
                 * Validation Error
                 */
                422: HTTPValidationError;
            };
        };
        delete: {
            req: DeleteArtifactsByIdData;
            res: {
                /**
                 * Successful Response
                 */
                204: void;
                /**
                 * Validation Error
                 */
                422: HTTPValidationError;
            };
        };
    };
    '/artifacts/{key}/latest': {
        get: {
            req: GetArtifactsByKeyLatestData;
            res: {
                /**
                 * Successful Response
                 */
                200: Artifact;
                /**
                 * Validation Error
                 */
                422: HTTPValidationError;
            };
        };
    };
    '/artifacts/filter': {
        post: {
            req: PostArtifactsFilterData;
            res: {
                /**
                 * Successful Response
                 */
                200: Array<Artifact>;
                /**
                 * Validation Error
                 */
                422: HTTPValidationError;
            };
        };
    };
    '/artifacts/latest/filter': {
        post: {
            req: PostArtifactsLatestFilterData;
            res: {
                /**
                 * Successful Response
                 */
                200: Array<ArtifactCollection>;
                /**
                 * Validation Error
                 */
                422: HTTPValidationError;
            };
        };
    };
    '/artifacts/count': {
        post: {
            req: PostArtifactsCountData;
            res: {
                /**
                 * Successful Response
                 */
                200: number;
                /**
                 * Validation Error
                 */
                422: HTTPValidationError;
            };
        };
    };
    '/artifacts/latest/count': {
        post: {
            req: PostArtifactsLatestCountData;
            res: {
                /**
                 * Successful Response
                 */
                200: number;
                /**
                 * Validation Error
                 */
                422: HTTPValidationError;
            };
        };
    };
    '/block_schemas/': {
        post: {
            req: PostBlockSchemasData;
            res: {
                /**
                 * Successful Response
                 */
                201: BlockSchema;
                /**
                 * Validation Error
                 */
                422: HTTPValidationError;
            };
        };
    };
    '/block_schemas/{id}': {
        delete: {
            req: DeleteBlockSchemasByIdData;
            res: {
                /**
                 * Successful Response
                 */
                204: void;
                /**
                 * Validation Error
                 */
                422: HTTPValidationError;
            };
        };
        get: {
            req: GetBlockSchemasByIdData;
            res: {
                /**
                 * Successful Response
                 */
                200: BlockSchema;
                /**
                 * Validation Error
                 */
                422: HTTPValidationError;
            };
        };
    };
    '/block_schemas/filter': {
        post: {
            req: PostBlockSchemasFilterData;
            res: {
                /**
                 * Successful Response
                 */
                200: Array<BlockSchema>;
                /**
                 * Validation Error
                 */
                422: HTTPValidationError;
            };
        };
    };
    '/block_schemas/checksum/{checksum}': {
        get: {
            req: GetBlockSchemasChecksumByChecksumData;
            res: {
                /**
                 * Successful Response
                 */
                200: BlockSchema;
                /**
                 * Validation Error
                 */
                422: HTTPValidationError;
            };
        };
    };
    '/block_capabilities/': {
        get: {
            req: GetBlockCapabilitiesData;
            res: {
                /**
                 * Successful Response
                 */
                200: Array<(string)>;
                /**
                 * Validation Error
                 */
                422: HTTPValidationError;
            };
        };
    };
    '/collections/views/{view}': {
        get: {
            req: GetCollectionsViewsByViewData;
            res: {
                /**
                 * Successful Response
                 */
                200: {
                    [key: string]: unknown;
                };
                /**
                 * Validation Error
                 */
                422: HTTPValidationError;
            };
        };
    };
    '/variables/': {
        post: {
            req: PostVariablesData;
            res: {
                /**
                 * Successful Response
                 */
                201: Variable;
                /**
                 * Validation Error
                 */
                422: HTTPValidationError;
            };
        };
    };
    '/variables/{id}': {
        get: {
            req: GetVariablesByIdData;
            res: {
                /**
                 * Successful Response
                 */
                200: Variable;
                /**
                 * Validation Error
                 */
                422: HTTPValidationError;
            };
        };
        patch: {
            req: PatchVariablesByIdData;
            res: {
                /**
                 * Successful Response
                 */
                204: void;
                /**
                 * Validation Error
                 */
                422: HTTPValidationError;
            };
        };
        delete: {
            req: DeleteVariablesByIdData;
            res: {
                /**
                 * Successful Response
                 */
                204: void;
                /**
                 * Validation Error
                 */
                422: HTTPValidationError;
            };
        };
    };
    '/variables/name/{name}': {
        get: {
            req: GetVariablesNameByNameData;
            res: {
                /**
                 * Successful Response
                 */
                200: Variable;
                /**
                 * Validation Error
                 */
                422: HTTPValidationError;
            };
        };
        patch: {
            req: PatchVariablesNameByNameData;
            res: {
                /**
                 * Successful Response
                 */
                204: void;
                /**
                 * Validation Error
                 */
                422: HTTPValidationError;
            };
        };
        delete: {
            req: DeleteVariablesNameByNameData;
            res: {
                /**
                 * Successful Response
                 */
                204: void;
                /**
                 * Validation Error
                 */
                422: HTTPValidationError;
            };
        };
    };
    '/variables/filter': {
        post: {
            req: PostVariablesFilterData;
            res: {
                /**
                 * Successful Response
                 */
                200: Array<Variable>;
                /**
                 * Validation Error
                 */
                422: HTTPValidationError;
            };
        };
    };
    '/variables/count': {
        post: {
            req: PostVariablesCountData;
            res: {
                /**
                 * Successful Response
                 */
                200: number;
                /**
                 * Validation Error
                 */
                422: HTTPValidationError;
            };
        };
    };
    '/csrf-token': {
        get: {
            req: GetCsrfTokenData;
            res: {
                /**
                 * Successful Response
                 */
                200: CsrfToken;
                /**
                 * Validation Error
                 */
                422: HTTPValidationError;
            };
        };
    };
    '/events': {
        post: {
            req: PostEventsData;
            res: {
                /**
                 * Successful Response
                 */
                204: void;
                /**
                 * Validation Error
                 */
                422: HTTPValidationError;
            };
        };
    };
    '/events/filter': {
        post: {
            req: PostEventsFilterData;
            res: {
                /**
                 * Successful Response
                 */
                200: EventPage;
                /**
                 * Validation Error
                 */
                422: HTTPValidationError;
            };
        };
    };
    '/events/filter/next': {
        get: {
            req: GetEventsFilterNextData;
            res: {
                /**
                 * Successful Response
                 */
                200: EventPage;
                /**
                 * Validation Error
                 */
                422: HTTPValidationError;
            };
        };
    };
    '/events/count-by/{countable}': {
        post: {
            req: PostEventsCountByByCountableData;
            res: {
                /**
                 * Successful Response
                 */
                200: Array<EventCount>;
                /**
                 * Validation Error
                 */
                422: HTTPValidationError;
            };
        };
    };
    '/automations/': {
        post: {
            req: PostAutomationsData;
            res: {
                /**
                 * Successful Response
                 */
                201: Automation;
                /**
                 * Validation Error
                 */
                422: HTTPValidationError;
            };
        };
    };
    '/automations/{id}': {
        put: {
            req: PutAutomationsByIdData;
            res: {
                /**
                 * Successful Response
                 */
                204: void;
                /**
                 * Validation Error
                 */
                422: HTTPValidationError;
            };
        };
        patch: {
            req: PatchAutomationsByIdData;
            res: {
                /**
                 * Successful Response
                 */
                204: void;
                /**
                 * Validation Error
                 */
                422: HTTPValidationError;
            };
        };
        delete: {
            req: DeleteAutomationsByIdData;
            res: {
                /**
                 * Successful Response
                 */
                204: void;
                /**
                 * Validation Error
                 */
                422: HTTPValidationError;
            };
        };
        get: {
            req: GetAutomationsByIdData;
            res: {
                /**
                 * Successful Response
                 */
                200: Automation;
                /**
                 * Validation Error
                 */
                422: HTTPValidationError;
            };
        };
    };
    '/automations/filter': {
        post: {
            req: PostAutomationsFilterData;
            res: {
                /**
                 * Successful Response
                 */
                200: Array<Automation>;
                /**
                 * Validation Error
                 */
                422: HTTPValidationError;
            };
        };
    };
    '/automations/count': {
        post: {
            req: PostAutomationsCountData;
            res: {
                /**
                 * Successful Response
                 */
                200: number;
                /**
                 * Validation Error
                 */
                422: HTTPValidationError;
            };
        };
    };
    '/automations/related-to/{resource_id}': {
        get: {
            req: GetAutomationsRelatedToByResourceIdData;
            res: {
                /**
                 * Successful Response
                 */
                200: Array<Automation>;
                /**
                 * Validation Error
                 */
                422: HTTPValidationError;
            };
        };
    };
    '/automations/owned-by/{resource_id}': {
        delete: {
            req: DeleteAutomationsOwnedByByResourceIdData;
            res: {
                /**
                 * Successful Response
                 */
                202: unknown;
                /**
                 * Validation Error
                 */
                422: HTTPValidationError;
            };
        };
    };
    '/templates/validate': {
        post: {
            req: PostTemplatesValidateData;
            res: {
                /**
                 * Successful Response
                 */
                200: unknown;
                /**
                 * Validation Error
                 */
                422: HTTPValidationError;
            };
        };
    };
    '/ui/schemas/validate': {
        post: {
            req: PostUiSchemasValidateData;
            res: {
                /**
                 * Successful Response
                 */
                200: {
                    [key: string]: unknown;
                };
                /**
                 * Validation Error
                 */
                422: HTTPValidationError;
            };
        };
    };
    '/admin/settings': {
        get: {
            req: GetAdminSettingsData;
            res: {
                /**
                 * Successful Response
                 */
                200: Settings;
                /**
                 * Validation Error
                 */
                422: HTTPValidationError;
            };
        };
    };
    '/admin/version': {
        get: {
            req: GetAdminVersionData;
            res: {
                /**
                 * Successful Response
                 */
                200: string;
                /**
                 * Validation Error
                 */
                422: HTTPValidationError;
            };
        };
    };
    '/admin/database/clear': {
        post: {
            req: PostAdminDatabaseClearData;
            res: {
                /**
                 * Successful Response
                 */
                204: void;
                /**
                 * Validation Error
                 */
                422: HTTPValidationError;
            };
        };
    };
    '/admin/database/drop': {
        post: {
            req: PostAdminDatabaseDropData;
            res: {
                /**
                 * Successful Response
                 */
                204: void;
                /**
                 * Validation Error
                 */
                422: HTTPValidationError;
            };
        };
    };
    '/admin/database/create': {
        post: {
            req: PostAdminDatabaseCreateData;
            res: {
                /**
                 * Successful Response
                 */
                204: void;
                /**
                 * Validation Error
                 */
                422: HTTPValidationError;
            };
        };
    };
};